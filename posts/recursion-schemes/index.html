<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="generator" content="pandoc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
            <meta name="author" content="Iago Leal de Freitas" />
                <meta name="dcterms.date" content="2020-09-10" />
                <meta name="keywords" content="category-theory, recursion-schemes, functional-programming" />
            <title>Recursion Schemes: An introduction to programming with induction | Iago Leal</title>
        <style>
            code{white-space: pre-wrap;}
            span.smallcaps{font-variant: small-caps;}
            span.underline{text-decoration: underline;}
            div.column{display: inline-block; vertical-align: top; width: 50%;}
            div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
            ul.task-list{list-style: none;}
        </style>
        <link rel="stylesheet" href="/css/sakura-earthly.css"/>
        <link rel="stylesheet" href="/css/krkis.css"/>
            <link rel="stylesheet" href="/css/theorems.css" />
                <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
                <script>document.addEventListener("DOMContentLoaded", function () {
                 var mathElements = document.getElementsByClassName("math");
                 for (var i = 0; i < mathElements.length; i++) {
                  var texText = mathElements[i].firstChild;
                  if (mathElements[i].tagName == "SPAN") {
                   katex.render(texText.data, mathElements[i], {
                    displayMode: mathElements[i].classList.contains('display'),
                    throwOnError: false,
                    fleqn: false
                   });
                }}});
                </script>
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
            <!--[if lt IE 9]>
            <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
        <![endif]-->
        </head>
<body>
<header id="top-bar">
    <nav>
        <ul>
            <div class="home-button">
                <li><a href="/">home</a></li>
            </div>
            <div class="nav-links">
                <li><a href="/posts/">blog</a></li>
                <li><a href="/projects/">projects</a></li>
                <li><a href="/about/">about</a></li>
            </div>
        </ul>
    </nav>
</header><header id="title-block-header">
    <header class="subheading">
        <h1 class="title">Recursion Schemes</h1>
                <p>An introduction to programming with induction</p>
            </header>
            <p class="date">2020-09-10</p>
    </header>
<p>Recursion schemes are a neat construction that allows one to better structure and reason about recursive functions. Instead of viewing recursion as functions that call themselves, these schemes allow us to take a higher-order point of view. Most of recursive definitions may be abstracted as some operator that takes a function which knows how to deal with individual parts of a structure and turns it into a function defined for the entire structure. The canonical example for this perspective is turning the binary function <span class="math inline">+</span>, which adds two numbers, into a new function that sums all elements of a list with arbitrary length<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Another use case is, when writing an evaluator for an expression tree, to only tell your program how to deal with each node and let a recursion scheme turn it into a full evaluator.</p>
<p>In this post, we will take a look at the three simplest varieties of recursion schemes: catamorphims, anamorphisms, and hylomorphisms; all of them deeply linked with structural induction. As we will see, they respectively encapsulate the notions of folding a data structure, constructing a data structure and using a data structure as an intermediate step.</p>
<p>The first time I heard about recursion schemes was after stumbling with the paper <a href="https://maartenfokkinga.github.io/utwente/mmf91m.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</a> by Erik Meijer, Maarten Fokkinga, and Ross Paterson. It is a real gem of functional wisdom but the authors use a notation called <a href="https://en.wikipedia.org/wiki/Bird%E2%80%93Meertens_formalism">Squiggol</a>, which I had a really hard time trying to grasp. Fortunately, I later found <a href="https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html">Patrick Thomson’s excellent series of posts</a>, which explain recursion schemes using Haskell code. After absorbing this content, I tried to explain the idea to some friends who don’t know Haskell but know some category theory. This post is an enriched version of that presentation with more cohesion and much less of my bad drawings.</p>
<p>In the spirit of the original presentation, I’ve decided to make this post completely language-agnostic. I also tried to keep any type theory or lambda calculus to a minimum in order to make it easier to grasp. My hope is that anyone with some experience in programming and mathematics will be able to read this, instead of confining this post only to people that know a certain programming language. Of course, in doing that I’m risking that no one besides me will actually understand this post. But, very well, I will do my best.</p>
<h2 id="sec:intro">A not so historical introduction</h2>
<p>We begin our journey in the prehistory of programming; that time when computers where still mostly made of coconuts and mammoth fur. At the time, the way to program was quite unstructured. The code of a program was essentially given by a sequence of commands whereas the data was simply piled up in a stack.</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzU4Mi44NjkzNTNwdCcgaGVpZ2h0PScxNjguNDEyODc2cHQnIHZpZXdCb3g9Jy0xMzkuNTcwMyAtMTQ0LjAwMDEgNTgyLjg2OTM1MyAxNjguNDEyODc2Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpybS1sbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBajRBQTBBQUFBQUM4Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZjkwOVRMeklBQUFGTUFBQUFSUUFBQUZaVnFabW5ZMjFoY0FBQUFaUUFBQUNKQUFBQmlndkNIOVpqZG5RZ0FBQUNJQUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUlrQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWl3QUFBVVZBQUFHbkNZRHQ0bG9aV0ZrQUFBSFJBQUFBRElBQUFBMkdWMUU3V2hvWldFQUFBZDRBQUFBSGdBQUFDUUYzQUxNYUcxMGVBQUFCNWdBQUFBOEFBQUFQQnEzQWFoc2IyTmhBQUFIMUFBQUFDQUFBQUFnQ3hRTW9HMWhlSEFBQUFmMEFBQUFId0FBQUNBQVZRQjJibUZ0WlFBQUNCUUFBQUMzQUFBQktSOU1NNUZ3YjNOMEFBQUl6QUFBQUNvQUFBQkFBY29DTjNqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTmF5SDBRQmNZUWlCQUFCNDJtTmdaUHpQT0lHQmxZR0JxWk5wTndNRFF6ZUVacnpQWU1qSUJCUmxZR1ZtZ0FGR0J3WUVDRWh6VFFGU3pyK1ptS1gvbXpCRU1SMWtFQU9wQWNrQkFBbUNDellBQUFCNDJtTmdZR0JtZ0dBWkJrWUdFR2dCOGhqQmZCYUdEQ0F0eGlBQUZHRmpjR1lJWmtoa1NHYklZY2huS0dJb1lTai96ZlQvUDFBZUpwN05rSWNRLzMvZy84Yi9TLzR2L2ovbi8rei9NLy9QK0QrTmxRZHFQaGJBeU1ZQWwyUmtBaEpNNkFvWWlBSE1hSHdXRkI0cjBBOFF3TTdCd01uRndNRE53TVBBd010QUg4QkhTQUVBRTU0ZHJnQUFBQUFoQW5rQUFBQUIvLzhBQW5qYVpaUkxiQk5YRklidnZUUDJ6UGlac2VmaHNUMStqUjl4N0RpMXg5ZVRZTWRKU0doRHdxdEFRbmlrcE9WVlVDQU5WZFdLUWlHRlRZdDRpRTBGaTlKRkpaYUlWS29RcXFEZElMcEJxcWhnMDBVbEtsVlVaVk9LMUVXSmU2OGZFcWdienoxbjVEbmZmODUvTGtBZ0RnRE1vaXVBQVJ3bzNJQ2dyN2JNc2VCcDZZYmQ5a3R0bVVIa0NHNHdORzJqNldYT0R2K3RMVU9hTjhXNG1ERkZJdzc1MysvZVJWZGU3SStqR1FBUTZHLzhnUzZqSDBBSm1BQ2t5a2JDQXlYT0E0MUVnY0hsT21PV0ZEV0N6RkpsRUpiVENTOHNJQ05obHlXRlpEQzY3R1p0Q05yUFRBY3E2NnU1WEhVOURtejV5QXVSblhPeFRCZGZDaVkzNU0vZnYzLysvVXRQUkdSamJRZU9PYk9qUzF1blRvMWxuVXZ6dkozaHU1NTZCZGRFTUJ6NytZdkxENzdhM2VLQnp3alBLQmlqUE9rK1dJQzRYREZMcXRLbU1GN0NVQ21kcXNpUzNVaGswaG55enE1RFNtZFZyQWlra1BEWjlQQ3BnalU1Y0MyTUhBTEw4Qnh2S09FMTJjMkw0MVgrdUYrS3U2TVR0YjJycWd4MHR0NHk4ZUJjZlhyaDFzU2lOK29jejFmVy8rVGl1MzcwQ3U0QldRMGUzVlRmSnpFUkc2ZUk2Y3JBZE1YYTQzQjQ3NUdYTE5hekgwOEJGc1FheitGaitIMnpuNE9nVGpSZ1E1YU1SSnFnRjJDVHNOMCtFaHBFbDZKRE8wZHlUZHcyZElicVNSUFpsZ3dmYTBtNUM0bWl0WGxvSmlqSm1rMlRqYlhaa2VPMXZmMWp5YjQxWHFZbkh1eS9OdG1Ud25NTDIvdjdoMVB1ZTJFOUwxckRSVVVMU29Jb0ZWYlhVNXplTzVVdStZcnBlTEVIbThNanI2WEtNK3hlT3Y4RTRiMUtlTk1nMDVvL1Iwb1hVS3ZsSHRoaHBkejBXR2N3dk9wMk1QRjNsTjVDZUt2NVJqSWthYklVM0RXNDY4VEptZlNnRWVBL2REZ09Tcm10QTRmblVrajNTa0ZOS2E3NjdQWVp6ZWpXYkFEUW1tSGk0d2I2RmxpZ0g0QTRKdVg2YUhPbzNvcUY2U2hsTWxJdkZEbTVwTWdpYVlac3FaaTIwRkxvc0VsWVVtSERKMnFxNXlTTFJqMURRM3IyOVI1ZE9YZXhITlR3NFNOWUd6N2tZSkx6K1Z3VUNhci9HOGphSUxQS2FUSlJob2tpVmZJZmc3ODZvLzdVaTM5aWJwcHl4dzVZbHhTZVZVa0FtbnNHS0Y4WEVKdDhhZndLQ1doZ3JWbG9ZWUg4RXgxNjZVc3RmVEh5bzhKYklBOTYyL3FvYituc09mdy9TZVdXQjFvWnBBYmtnQ0Fva2NsOWZlZG9pY1gzc0xhbG5JdlNVeFRhM000NzQvMWE2dUJCV25QbDd3Nzl6YlhiYXVhVE5nRUx3bVNtajhoTUhjQUpkQkJwN2xGN2Z0UmJ6ZlhPRUh0WmRVajNTb2FQUHQwNXUzUm0rODdUV3hTeG5wck1hQUgvVUd3aUUzdzQ5L25aMjUrZWZvdmZrVTkwaitiZm5zM0hFeU81dWM0TTU0bkdicEFscCtiM1h4RlhVckhSa2FkNlVOdEhjTDRuVnF4NXpsSnBSN2QxeStYQWtDVWdSbkJxdnE0UVBLRWxSM05IWHBibTA2OXNPQUloNTNkSnFxTFF1bjZpYlIwNlFPcnI3ZDBpZnNHaWlRMXNlQkFubTZMVXZLOHdYS2VsOWRFTEZ6UW9EeGFtOUVMU1Z5d2RIN0J3ZFI0cTBadUZUU05JV2ZrelZ3MEliMWJvZDMyTjUrZ092QTR3SUNFa0pzeklFZUoremdsSm8wek1FVStTVnFrYzB3cEpwS2orQ0NRckc0SlVtdVd2V09oT3ZIczJGTFh0M0dPcnZwdnZOVjAyMy9SdVcvWHdiQ1lvZk1MeVBvN2R0NTl6Q3h6N2dWS0hGNmsrcUNtOHV3R2c2bVZETlBiYWkzOUJwOHZlREZ6cXlwY3VCKytDb1pYZi9JSURqdGNSOVJjTFFnVFlTKzdJSkVpQklybHBPaDVOdEM5QWczYWg0ekRTbTNiQUdLMnRKcGVOS2lNdjFwS01QVmFlV3RxNGtWb1phdy9vNCtMREhiVmtXTk9henJZem51bUpvOUdWN3pwR2cyUHRNN3krdUhxdDROUWp3dGNFNlQ5Wk15K1hBQUFBZU5wallHUmdZQURpUllicHh2SDhObDhadUptZkEwVVlibTlyV0ErbmhmNi9ZdHJQZEJESTVXQmdBb2tDQUZ1M0RRMEFBSGphWTJCa1lHQTYrUDhWUXhUVEpRWWdZTnJQd01pQUN2Z0JmUE1FclFBQUFXc0FJUUFBQUFBQlRRQUFBdElBT0FJc0FEZ0I5QUFnQWJ3QUlnSVFBQndCRmdBaEFpd0FJQUgwQUJ3QmlBQWNBWVVBRXdMU0FCSUNMQUFiQUFBQUtnQXFBQ29BY2dEU0FTb0JaQUcwQWRRQ0ZBSkdBb0lDcmdNRUEwNTQybU5nWkdCZzRHZHdaV0JoQUFFbUlHWmtBSWs1TU9pQkJBQUx6UURNQUhqYVhZMDdEc0l3RElZL0hrVzhCc1RBbklVeFZaS3hCK2pBQVRxeWxhcFNIMUxhSTNBTURzQVpPQjF1Q0JMQ2t1WFA5bS8vd0pvYk02YVlrN0NQdk9ETU5YTENqa2ZrbGVoZnNwMHRONkxmQnVYRUN5NGNJeWVjdUVkZWNlQkpRNHZIWXFCcHZaV1MwOU14aHVxcEtGRTRVbEVvTWtrdkYvcm43ak4xd2pyMFd0aUVKTys3TWU5OVZTcVhHcFVwMytwZ0l1aXN0a1k3NDBSV2lJZG5vQTdPU3I1TWJoU2xIK3ErVXphVjV0K1Y3eS9lK3ZVb0RnQjQybU5nWXNBUCtJR1lrWUdKUVkzQmpNR0Z3WTNCajhHZklaQWhpQ0dVSVp3aGl1RWdBQ2t0QkFJQUFBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6cm0tbG1yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMScgdHJhbnNmb3JtPSdzY2FsZSgyIDIpJz4KPHBhdGggZD0nTS00My42MzI4LTQ4Ljc1MzkxSC02Ny45NzI3Qy02OC44NjMzLTQ4Ljc1MzkxLTY5LjU4NTktNDguMDMxMjUtNjkuNTg1OS00Ny4xNDA2M1YtMzUuOTA2MjVDLTY5LjU4NTktMzUuMDE1NjMtNjguODYzMy0zNC4yOTI5Ny02Ny45NzI3LTM0LjI5Mjk3SC00My42MzI4Qy00Mi43NDIyLTM0LjI5Mjk3LTQyLjAxOTUtMzUuMDE1NjMtNDIuMDE5NS0zNS45MDYyNVYtNDcuMTQwNjNDLTQyLjAxOTUtNDguMDMxMjUtNDIuNzQyMi00OC43NTM5MS00My42MzI4LTQ4Ljc1MzkxWicgZmlsbD0nI2E2ODBkOScvPgo8cGF0aCBkPSdNLTQzLjYzMjgtNDguNzUzOTFILTY3Ljk3MjdDLTY4Ljg2MzMtNDguNzUzOTEtNjkuNTg1OS00OC4wMzEyNS02OS41ODU5LTQ3LjE0MDYzVi0zNS45MDYyNUMtNjkuNTg1OS0zNS4wMTU2My02OC44NjMzLTM0LjI5Mjk3LTY3Ljk3MjctMzQuMjkyOTdILTQzLjYzMjhDLTQyLjc0MjItMzQuMjkyOTctNDIuMDE5NS0zNS4wMTU2My00Mi4wMTk1LTM1LjkwNjI1Vi00Ny4xNDA2M0MtNDIuMDE5NS00OC4wMzEyNS00Mi43NDIyLTQ4Ljc1MzkxLTQzLjYzMjgtNDguNzUzOTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTE0LjgyMDMtNDguNzUzOTFILTM5LjE2MDJDLTQwLjA1MDgtNDguNzUzOTEtNDAuNzczNC00OC4wMzEyNS00MC43NzM0LTQ3LjE0MDYzVi0zNS45MDYyNUMtNDAuNzczNC0zNS4wMTU2My00MC4wNTA4LTM0LjI5Mjk3LTM5LjE2MDItMzQuMjkyOTdILTE0LjgyMDNDLTEzLjkyOTctMzQuMjkyOTctMTMuMjEwOS0zNS4wMTU2My0xMy4yMTA5LTM1LjkwNjI1Vi00Ny4xNDA2M0MtMTMuMjEwOS00OC4wMzEyNS0xMy45Mjk3LTQ4Ljc1MzkxLTE0LjgyMDMtNDguNzUzOTFaJyBmaWxsPScjZmY4MDgwJy8+CjxwYXRoIGQ9J00tMTQuODIwMy00OC43NTM5MUgtMzkuMTYwMkMtNDAuMDUwOC00OC43NTM5MS00MC43NzM0LTQ4LjAzMTI1LTQwLjc3MzQtNDcuMTQwNjNWLTM1LjkwNjI1Qy00MC43NzM0LTM1LjAxNTYzLTQwLjA1MDgtMzQuMjkyOTctMzkuMTYwMi0zNC4yOTI5N0gtMTQuODIwM0MtMTMuOTI5Ny0zNC4yOTI5Ny0xMy4yMTA5LTM1LjAxNTYzLTEzLjIxMDktMzUuOTA2MjVWLTQ3LjE0MDYzQy0xMy4yMTA5LTQ4LjAzMTI1LTEzLjkyOTctNDguNzUzOTEtMTQuODIwMy00OC43NTM5MVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tNTQuMjQ2MDktMzIuNjk5MjJDLTUxLjM3ODkxLTE2LjQ0NTMtMzguNDI1OC0xNS44OTg0LTMxLjI3NzMtMzAuMzc1JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTMwLjU0MjkyNC0zMi4wMTk1NTFDLTMwLjY4MzU0OS0zMS44Mzk4NjgtMzEuMzc0OTU3LTMxLjA3ODE0Ni0zMS45NDEzNjItMzAuNjY0MDgzTC0zMC42MzY2NzQtMzAuMDc0MjM5Qy0zMC42OTUyNjctMzAuNzczNDU4LTMwLjU4MTk4OS0zMS43OTI5ODYtMzAuNTQyOTI0LTMyLjAxOTU1MVonLz4KPHBhdGggZD0nTS0zMC41NDI5MjQtMzIuMDE5NTUxQy0zMC42ODM1NDktMzEuODM5ODY4LTMxLjM3NDk1Ny0zMS4wNzgxNDYtMzEuOTQxMzYyLTMwLjY2NDA4M0wtMzAuNjM2Njc0LTMwLjA3NDIzOUMtMzAuNjk1MjY3LTMwLjc3MzQ1OC0zMC41ODE5ODktMzEuNzkyOTg2LTMwLjU0MjkyNC0zMi4wMTk1NTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ3Mycgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00xMy45OTIyLTQ4Ljc1MzkxSC0xMC4zNDc3Qy0xMS4yMzgzLTQ4Ljc1MzkxLTExLjk2MDktNDguMDMxMjUtMTEuOTYwOS00Ny4xNDA2M1YtMzUuOTA2MjVDLTExLjk2MDktMzUuMDE1NjMtMTEuMjM4My0zNC4yOTI5Ny0xMC4zNDc3LTM0LjI5Mjk3SDEzLjk5MjJDMTQuODc4OS0zNC4yOTI5NyAxNS42MDE2LTM1LjAxNTYzIDE1LjYwMTYtMzUuOTA2MjVWLTQ3LjE0MDYzQzE1LjYwMTYtNDguMDMxMjUgMTQuODc4OS00OC43NTM5MSAxMy45OTIyLTQ4Ljc1MzkxWicgZmlsbD0nI2IzZmZiMycvPgo8cGF0aCBkPSdNMTMuOTkyMi00OC43NTM5MUgtMTAuMzQ3N0MtMTEuMjM4My00OC43NTM5MS0xMS45NjA5LTQ4LjAzMTI1LTExLjk2MDktNDcuMTQwNjNWLTM1LjkwNjI1Qy0xMS45NjA5LTM1LjAxNTYzLTExLjIzODMtMzQuMjkyOTctMTAuMzQ3Ny0zNC4yOTI5N0gxMy45OTIyQzE0Ljg3ODktMzQuMjkyOTcgMTUuNjAxNi0zNS4wMTU2MyAxNS42MDE2LTM1LjkwNjI1Vi00Ny4xNDA2M0MxNS42MDE2LTQ4LjAzMTI1IDE0Ljg3ODktNDguNzUzOTEgMTMuOTkyMi00OC43NTM5MVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMjUuNDMzNi0zMi42OTkyMkMtMjIuNTcwMy0xNi40NDUzLTkuNjEzMy0xNS44OTg0LTIuNDY0OC0zMC4zNzUnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMS43MzA0NjktMzIuMDE5NDk4Qy0xLjg3MTA5NC0zMS44Mzk4MTItMi41NjI0OTktMzEuMDc4MDk0LTMuMTI4OTA2LTMwLjY2NDAzTC0xLjgyNDIxOS0zMC4wNzQxODdDLTEuODg2NzE5LTMwLjc3MzQwNi0xLjc2OTUzMi0zMS43OTI5MzQtMS43MzA0NjktMzIuMDE5NDk4WicvPgo8cGF0aCBkPSdNLTEuNzMwNDY5LTMyLjAxOTQ5OEMtMS44NzEwOTQtMzEuODM5ODEyLTIuNTYyNDk5LTMxLjA3ODA5NC0zLjEyODkwNi0zMC42NjQwM0wtMS44MjQyMTktMzAuMDc0MTg3Qy0xLjg4NjcxOS0zMC43NzM0MDYtMS43Njk1MzItMzEuNzkyOTM0LTEuNzMwNDY5LTMyLjAxOTQ5OFonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDc2JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTQyLjgwMDgtNDguNzUzOTFIMTguNDY0OEMxNy41NzQyLTQ4Ljc1MzkxIDE2Ljg1MTYtNDguMDMxMjUgMTYuODUxNi00Ny4xNDA2M1YtMzUuOTA2MjVDMTYuODUxNi0zNS4wMTU2MyAxNy41NzQyLTM0LjI5Mjk3IDE4LjQ2NDgtMzQuMjkyOTdINDIuODAwOEM0My42OTE0LTM0LjI5Mjk3IDQ0LjQxNDQtMzUuMDE1NjMgNDQuNDE0NC0zNS45MDYyNVYtNDcuMTQwNjNDNDQuNDE0NC00OC4wMzEyNSA0My42OTE0LTQ4Ljc1MzkxIDQyLjgwMDgtNDguNzUzOTFaJyBmaWxsPScjODA4MGZmJy8+CjxwYXRoIGQ9J000Mi44MDA4LTQ4Ljc1MzkxSDE4LjQ2NDhDMTcuNTc0Mi00OC43NTM5MSAxNi44NTE2LTQ4LjAzMTI1IDE2Ljg1MTYtNDcuMTQwNjNWLTM1LjkwNjI1QzE2Ljg1MTYtMzUuMDE1NjMgMTcuNTc0Mi0zNC4yOTI5NyAxOC40NjQ4LTM0LjI5Mjk3SDQyLjgwMDhDNDMuNjkxNC0zNC4yOTI5NyA0NC40MTQ0LTM1LjAxNTYzIDQ0LjQxNDQtMzUuOTA2MjVWLTQ3LjE0MDYzQzQ0LjQxNDQtNDguMDMxMjUgNDMuNjkxNC00OC43NTM5MSA0Mi44MDA4LTQ4Ljc1MzkxWicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTMuMzc1LTMyLjY5OTIyQzYuMjQyMi0xNi40NDUzIDE5LjE5OTItMTUuODk4NCAyNi4zNDc3LTMwLjM3NScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTI3LjA4MTk4Ni0zMi4wMTk1NTFDMjYuOTM3NDU3LTMxLjgzOTg2NCAyNi4yNDk5NTYtMzEuMDc4MTQ2IDI1LjY4MzU1Mi0zMC42NjQwODNMMjYuOTg4MjM2LTMwLjA3NDI0MUMyNi45MjU3NC0zMC43NzM0NTggMjcuMDQyOTI2LTMxLjc5Mjk5NSAyNy4wODE5ODYtMzIuMDE5NTUxWicvPgo8cGF0aCBkPSdNMjcuMDgxOTg2LTMyLjAxOTU1MUMyNi45Mzc0NTctMzEuODM5ODY0IDI2LjI0OTk1Ni0zMS4wNzgxNDYgMjUuNjgzNTUyLTMwLjY2NDA4M0wyNi45ODgyMzYtMzAuMDc0MjQxQzI2LjkyNTc0LTMwLjc3MzQ1OCAyNy4wNDI5MjYtMzEuNzkyOTk1IDI3LjA4MTk4Ni0zMi4wMTk1NTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ3Mycgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J003MS42MTM0LTQ4Ljc1MzkxSDQ3LjI3MzRDNDYuMzg2NC00OC43NTM5MSA0NS42NjQ0LTQ4LjAzMTI1IDQ1LjY2NDQtNDcuMTQwNjNWLTM1LjkwNjI1QzQ1LjY2NDQtMzUuMDE1NjMgNDYuMzg2NC0zNC4yOTI5NyA0Ny4yNzM0LTM0LjI5Mjk3SDcxLjYxMzRDNzIuNTA0NC0zNC4yOTI5NyA3My4yMjY0LTM1LjAxNTYzIDczLjIyNjQtMzUuOTA2MjVWLTQ3LjE0MDYzQzczLjIyNjQtNDguMDMxMjUgNzIuNTA0NC00OC43NTM5MSA3MS42MTM0LTQ4Ljc1MzkxWicgZmlsbD0nIzgwODBmZicvPgo8cGF0aCBkPSdNNzEuNjEzNC00OC43NTM5MUg0Ny4yNzM0QzQ2LjM4NjQtNDguNzUzOTEgNDUuNjY0NC00OC4wMzEyNSA0NS42NjQ0LTQ3LjE0MDYzVi0zNS45MDYyNUM0NS42NjQ0LTM1LjAxNTYzIDQ2LjM4NjQtMzQuMjkyOTcgNDcuMjczNC0zNC4yOTI5N0g3MS42MTM0QzcyLjUwNDQtMzQuMjkyOTcgNzMuMjI2NC0zNS4wMTU2MyA3My4yMjY0LTM1LjkwNjI1Vi00Ny4xNDA2M0M3My4yMjY0LTQ4LjAzMTI1IDcyLjUwNDQtNDguNzUzOTEgNzEuNjEzNC00OC43NTM5MVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00zMi4xODc1LTMyLjY5OTIyQzM1LjA1NDctMTYuNDQ1MyA0OC4wMTE0LTE1Ljg5ODQgNTUuMTYwNC0zMC4zNzUnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J001NS44OTQ1MTQtMzIuMDE5NTUxQzU1Ljc0OTk4Mi0zMS44Mzk4NjYgNTUuMDU4NTc1LTMxLjA3ODE0NCA1NC40OTYwNzQtMzAuNjY0MDgzTDU1LjgwMDc2NC0zMC4wNzQyMzlDNTUuNzM4MjY0LTMwLjc3MzQ1OCA1NS44NTE1NDMtMzEuNzkyOTk1IDU1Ljg5NDUxNC0zMi4wMTk1NTFaJy8+CjxwYXRoIGQ9J001NS44OTQ1MTQtMzIuMDE5NTUxQzU1Ljc0OTk4Mi0zMS44Mzk4NjYgNTUuMDU4NTc1LTMxLjA3ODE0NCA1NC40OTYwNzQtMzAuNjY0MDgzTDU1LjgwMDc2NC0zMC4wNzQyMzlDNTUuNzM4MjY0LTMwLjc3MzQ1OCA1NS44NTE1NDMtMzEuNzkyOTk1IDU1Ljg5NDUxNC0zMi4wMTk1NTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ3Mycgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00xMDAuNDI1NC00OC43NTM5MUg3Ni4wODY0Qzc1LjE5NTQtNDguNzUzOTEgNzQuNDc2NC00OC4wMzEyNSA3NC40NzY0LTQ3LjE0MDYzVi0zNS45MDYyNUM3NC40NzY0LTM1LjAxNTYzIDc1LjE5NTQtMzQuMjkyOTcgNzYuMDg2NC0zNC4yOTI5N0gxMDAuNDI1NEMxMDEuMzE2NC0zNC4yOTI5NyAxMDIuMDM5NC0zNS4wMTU2MyAxMDIuMDM5NC0zNS45MDYyNVYtNDcuMTQwNjNDMTAyLjAzOTQtNDguMDMxMjUgMTAxLjMxNjQtNDguNzUzOTEgMTAwLjQyNTQtNDguNzUzOTFaJyBmaWxsPScjZmY4MDgwJy8+CjxwYXRoIGQ9J00xMDAuNDI1NC00OC43NTM5MUg3Ni4wODY0Qzc1LjE5NTQtNDguNzUzOTEgNzQuNDc2NC00OC4wMzEyNSA3NC40NzY0LTQ3LjE0MDYzVi0zNS45MDYyNUM3NC40NzY0LTM1LjAxNTYzIDc1LjE5NTQtMzQuMjkyOTcgNzYuMDg2NC0zNC4yOTI5N0gxMDAuNDI1NEMxMDEuMzE2NC0zNC4yOTI5NyAxMDIuMDM5NC0zNS4wMTU2MyAxMDIuMDM5NC0zNS45MDYyNVYtNDcuMTQwNjNDMTAyLjAzOTQtNDguMDMxMjUgMTAxLjMxNjQtNDguNzUzOTEgMTAwLjQyNTQtNDguNzUzOTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNNjEuMDAwNC0zMi42OTkyMkM2My44Njc0LTE2LjQ0NTMgNzYuODI0NC0xNS44OTg0IDgzLjk3MjQtMzAuMzc1JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNODQuNzA3MDE0LTMyLjAxOTU1M0M4NC41NjI0ODUtMzEuODM5ODY2IDgzLjg3MTA4Ni0zMS4wNzgxNDQgODMuMzA4NTgxLTMwLjY2NDA4Mkw4NC42MTMyNzItMzAuMDc0MjRDODQuNTUwNzY3LTMwLjc3MzQ1OCA4NC42NjQwNTctMzEuNzkyOTkxIDg0LjcwNzAxNC0zMi4wMTk1NTNaJy8+CjxwYXRoIGQ9J004NC43MDcwMTQtMzIuMDE5NTUzQzg0LjU2MjQ4NS0zMS44Mzk4NjYgODMuODcxMDg2LTMxLjA3ODE0NCA4My4zMDg1ODEtMzAuNjY0MDgyTDg0LjYxMzI3Mi0zMC4wNzQyNEM4NC41NTA3NjctMzAuNzczNDU4IDg0LjY2NDA1Ny0zMS43OTI5OTEgODQuNzA3MDE0LTMyLjAxOTU1M1onIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDczJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTEyOS4yMzg0LTQ4Ljc1MzkxSDEwNC44OTg0QzEwNC4wMDc0LTQ4Ljc1MzkxIDEwMy4yODU0LTQ4LjAzMTI1IDEwMy4yODU0LTQ3LjE0MDYzVi0zNS45MDYyNUMxMDMuMjg1NC0zNS4wMTU2MyAxMDQuMDA3NC0zNC4yOTI5NyAxMDQuODk4NC0zNC4yOTI5N0gxMjkuMjM4NEMxMzAuMTI5NC0zNC4yOTI5NyAxMzAuODQ3NC0zNS4wMTU2MyAxMzAuODQ3NC0zNS45MDYyNVYtNDcuMTQwNjNDMTMwLjg0NzQtNDguMDMxMjUgMTMwLjEyOTQtNDguNzUzOTEgMTI5LjIzODQtNDguNzUzOTFaJyBmaWxsPScjYjNmZmIzJy8+CjxwYXRoIGQ9J00xMjkuMjM4NC00OC43NTM5MUgxMDQuODk4NEMxMDQuMDA3NC00OC43NTM5MSAxMDMuMjg1NC00OC4wMzEyNSAxMDMuMjg1NC00Ny4xNDA2M1YtMzUuOTA2MjVDMTAzLjI4NTQtMzUuMDE1NjMgMTA0LjAwNzQtMzQuMjkyOTcgMTA0Ljg5ODQtMzQuMjkyOTdIMTI5LjIzODRDMTMwLjEyOTQtMzQuMjkyOTcgMTMwLjg0NzQtMzUuMDE1NjMgMTMwLjg0NzQtMzUuOTA2MjVWLTQ3LjE0MDYzQzEzMC44NDc0LTQ4LjAzMTI1IDEzMC4xMjk0LTQ4Ljc1MzkxIDEyOS4yMzg0LTQ4Ljc1MzkxWicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTg5LjgxMjQtMzIuNjk5MjJDOTIuNjc5NC0xNi40NDUzIDEwNS42MzY0LTE1Ljg5ODQgMTEyLjc4MTQtMzAuMzc1JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMTEzLjUxNTUxMi0zMi4wMTk1NjFDMTEzLjM3NDg4Mi0zMS44Mzk4NyAxMTIuNjgzNDgyLTMxLjA3ODE0OCAxMTIuMTE3MDY5LTMwLjY2NDA4OEwxMTMuNDIxNzYtMzAuMDc0MjQ2QzExMy4zNjMxNjMtMzAuNzczNDYyIDExMy40NzY0NTMtMzEuNzkyOTk1IDExMy41MTU1MTItMzIuMDE5NTYxWicvPgo8cGF0aCBkPSdNMTEzLjUxNTUxMi0zMi4wMTk1NjFDMTEzLjM3NDg4Mi0zMS44Mzk4NyAxMTIuNjgzNDgyLTMxLjA3ODE0OCAxMTIuMTE3MDY5LTMwLjY2NDA4OEwxMTMuNDIxNzYtMzAuMDc0MjQ2QzExMy4zNjMxNjMtMzAuNzczNDYyIDExMy40NzY0NTMtMzEuNzkyOTk1IDExMy41MTU1MTItMzIuMDE5NTYxWicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0NzMnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMTU4LjA1MDQtNDguNzUzOTFIMTMzLjcxMTRDMTMyLjgyMDQtNDguNzUzOTEgMTMyLjA5NzQtNDguMDMxMjUgMTMyLjA5NzQtNDcuMTQwNjNWLTM1LjkwNjI1QzEzMi4wOTc0LTM1LjAxNTYzIDEzMi44MjA0LTM0LjI5Mjk3IDEzMy43MTE0LTM0LjI5Mjk3SDE1OC4wNTA0QzE1OC45NDE0LTM0LjI5Mjk3IDE1OS42NjA0LTM1LjAxNTYzIDE1OS42NjA0LTM1LjkwNjI1Vi00Ny4xNDA2M0MxNTkuNjYwNC00OC4wMzEyNSAxNTguOTQxNC00OC43NTM5MSAxNTguMDUwNC00OC43NTM5MVonIGZpbGw9JyNhNjgwZDknLz4KPHBhdGggZD0nTTE1OC4wNTA0LTQ4Ljc1MzkxSDEzMy43MTE0QzEzMi44MjA0LTQ4Ljc1MzkxIDEzMi4wOTc0LTQ4LjAzMTI1IDEzMi4wOTc0LTQ3LjE0MDYzVi0zNS45MDYyNUMxMzIuMDk3NC0zNS4wMTU2MyAxMzIuODIwNC0zNC4yOTI5NyAxMzMuNzExNC0zNC4yOTI5N0gxNTguMDUwNEMxNTguOTQxNC0zNC4yOTI5NyAxNTkuNjYwNC0zNS4wMTU2MyAxNTkuNjYwNC0zNS45MDYyNVYtNDcuMTQwNjNDMTU5LjY2MDQtNDguMDMxMjUgMTU4Ljk0MTQtNDguNzUzOTEgMTU4LjA1MDQtNDguNzUzOTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMTE4LjYyNTQtMzIuNjk5MjJDMTIxLjQ4ODQtMTYuNDQ1MyAxMzQuNDQ1NC0xNS44OTg0IDE0MS41OTM0LTMwLjM3NScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTE0Mi4zMjgyMy0zMi4wMTk1NTZDMTQyLjE4NzYxMy0zMS44Mzk4NTggMTQxLjQ5NjIwOC0zMS4wNzgxNDIgMTQwLjkyOTc5NS0zMC42NjQwODNMMTQyLjIzNDQ5Mi0zMC4wNzQyMzdDMTQyLjE3MTk4MS0zMC43NzM0NTggMTQyLjI4OTE3Ny0zMS43OTI5ODYgMTQyLjMyODIzLTMyLjAxOTU1NlonLz4KPHBhdGggZD0nTTE0Mi4zMjgyMy0zMi4wMTk1NTZDMTQyLjE4NzYxMy0zMS44Mzk4NTggMTQxLjQ5NjIwOC0zMS4wNzgxNDIgMTQwLjkyOTc5NS0zMC42NjQwODNMMTQyLjIzNDQ5Mi0zMC4wNzQyMzdDMTQyLjE3MTk4MS0zMC43NzM0NTggMTQyLjI4OTE3Ny0zMS43OTI5ODYgMTQyLjMyODIzLTMyLjAxOTU1NlonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDczJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTE4Ni44NTk0LTQ4Ljc1MzkxSDE2Mi41MjM0QzE2MS42MzI0LTQ4Ljc1MzkxIDE2MC45MTA0LTQ4LjAzMTI1IDE2MC45MTA0LTQ3LjE0MDYzVi0zNS45MDYyNUMxNjAuOTEwNC0zNS4wMTU2MyAxNjEuNjMyNC0zNC4yOTI5NyAxNjIuNTIzNC0zNC4yOTI5N0gxODYuODU5NEMxODcuNzUwNC0zNC4yOTI5NyAxODguNDcyNC0zNS4wMTU2MyAxODguNDcyNC0zNS45MDYyNVYtNDcuMTQwNjNDMTg4LjQ3MjQtNDguMDMxMjUgMTg3Ljc1MDQtNDguNzUzOTEgMTg2Ljg1OTQtNDguNzUzOTFaJyBmaWxsPScjY2NmJy8+CjxwYXRoIGQ9J00xODYuODU5NC00OC43NTM5MUgxNjIuNTIzNEMxNjEuNjMyNC00OC43NTM5MSAxNjAuOTEwNC00OC4wMzEyNSAxNjAuOTEwNC00Ny4xNDA2M1YtMzUuOTA2MjVDMTYwLjkxMDQtMzUuMDE1NjMgMTYxLjYzMjQtMzQuMjkyOTcgMTYyLjUyMzQtMzQuMjkyOTdIMTg2Ljg1OTRDMTg3Ljc1MDQtMzQuMjkyOTcgMTg4LjQ3MjQtMzUuMDE1NjMgMTg4LjQ3MjQtMzUuOTA2MjVWLTQ3LjE0MDYzQzE4OC40NzI0LTQ4LjAzMTI1IDE4Ny43NTA0LTQ4Ljc1MzkxIDE4Ni44NTk0LTQ4Ljc1MzkxWicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTE0Ny40Mzc0LTMyLjY5OTIyQzE1MC4zMDA0LTE2LjQ0NTMgMTYzLjI1NzQtMTUuODk4NCAxNzAuNDA2NC0zMC4zNzUnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00xNzEuMTQwOTM3LTMyLjAxOTU2NkMxNzEuMDAwMzA2LTMxLjgzOTg3NCAxNzAuMzA4ODk5LTMxLjA3ODE1MiAxNjkuNzQyNTAyLTMwLjY2NDA5TDE3MS4wNDcxODQtMzAuMDc0MjQ3QzE3MC45ODQ2ODgtMzAuNzczNDY2IDE3MS4xMDE4NzEtMzEuNzkzMDAyIDE3MS4xNDA5MzctMzIuMDE5NTY2WicvPgo8cGF0aCBkPSdNMTcxLjE0MDkzNy0zMi4wMTk1NjZDMTcxLjAwMDMwNi0zMS44Mzk4NzQgMTcwLjMwODg5OS0zMS4wNzgxNTIgMTY5Ljc0MjUwMi0zMC42NjQwOUwxNzEuMDQ3MTg0LTMwLjA3NDI0N0MxNzAuOTg0Njg4LTMwLjc3MzQ2NiAxNzEuMTAxODcxLTMxLjc5MzAwMiAxNzEuMTQwOTM3LTMyLjAxOTU2NlonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDczJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTIwMy45Njg0LTM1Ljg1NTQ3SDIxNS4zMDg0Vi00Ny4xOTE0MUgyMDMuOTY4NFonIGZpbGw9JyNmZjgwMDAnLz4KPHBhdGggZD0nTTIwMy45Njg0LTQ4LjE2MDE2SDIxNS4zMDg0Vi01OS40OTYxSDIwMy45Njg0Wicgc3Ryb2tlPScjZmY4MDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTIwMy45Njg0LTYwLjQ2MDlIMjE1LjMwODRWLTcxLjgwMDhIMjAzLjk2ODRaJyBzdHJva2U9JyNmZjgwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8ZyBmaWxsPScjZmY4MDAwJz4KPHBhdGggZD0nTTIwMy45Njg0LTIzLjU1MDhIMjE1LjMwODRWLTM0Ljg5MDYzSDIwMy45Njg0WicvPgo8cGF0aCBkPSdNMjAzLjk2ODQtMTEuMjQ2MUgyMTUuMzA4NFYtMjIuNTg1OUgyMDMuOTY4NFonLz4KPHBhdGggZD0nTTIwMy45Njg0IDEuMDU4NkgyMTUuMzA4NFYtMTAuMjgxM0gyMDMuOTY4NFonLz4KPC9nPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NS44MDI2MjcnIHk9Jy00MS41MjM5MTInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1My41NDI2IDUzLjczMDMpJz5TdGFjPHRzcGFuIHg9Jy0zNy4yNjA5MzcnPms8L3RzcGFuPgo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU1LjgwMjYyNycgeT0nLTQxLjUyMzkxMicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEyLjg3NyAzNi4zNzIzMSknPkNvbjx0c3BhbiB4PSctMzguMzY4MjkyJz50cm9sPC90c3Bhbj4KPHRzcGFuIHg9Jy0xOS41MjIxOTcnPu+sgm88L3RzcGFuPgo8dHNwYW4geD0nLTkuMjgyODg1Jz53PC90c3Bhbj4KPC90ZXh0Pgo8L2c+Cjwvc3ZnPg==" /></p>
<p>But the program does not have to execute the instructions in order. Oh no, it would be rather boring and inexpressive… In this programming paradigm, there is a special command called <code>goto</code> which allows one to jump to any labeled part of the program. In fact, this is the only command responsible for the program’s control flow.</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzUxNi45MTM2cHQnIGhlaWdodD0nMTc3Ljg0MzhwdCcgdmlld0JveD0nLTE0NC4wMDAxIC0xNDEuMjEwOTIgNTE2LjkxMzYgMTc3Ljg0MzgnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnJtLWxtdHQxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVTRBQTBBQUFBQUJzUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZitVOVRMeklBQUFGTUFBQUFRZ0FBQUZaV2VsN2xZMjFoY0FBQUFaQUFBQUJQQUFBQlVnQ1BDYTlqZG5RZ0FBQUI0QUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUhrQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWV3QUFBSGJBQUFDRUpOTi9PcG9aV0ZrQUFBRHlBQUFBRElBQUFBMkdLSkQrV2hvWldFQUFBUDhBQUFBSGdBQUFDUUU4d0V0YUcxMGVBQUFCQndBQUFBVUFBQUFGQVpnQUZkc2IyTmhBQUFFTUFBQUFBNEFBQUFPQWRJQkdtMWhlSEFBQUFSQUFBQUFIZ0FBQUNBQVRnQ0ZibUZ0WlFBQUJHQUFBQUM2QUFBQk1qcTYzMHB3YjNOMEFBQUZIQUFBQUJvQUFBQXVBS29BVlhqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5QTBRQmNhd2lEQUFCNDJtTmdaT0psbk1EQXlzREExTW0wbTRHQm9SdENNOTVuTUdSa0Fvb3lzSEl5d0FBakF4SUlTSE5OQVZMcERDVk12LzRMTTBReHpXSjRDbE1EQUx5NUN3c0FBSGphWTJCZ1lHYUFZQmtHUmdZUThBSHlHTUY4RmdZRElNMEJoRXhBT3AwaG42SGsvMzhFNi8rYy8xUC9UNFRxQWdOR05nWTRseEdraDRrQkZUQXlVQXN3UTJrV0VNSEtNSGdBQUkzcERFQUFBQ0VDZVFBQUFBSC8vd0FDZU5vdGtMRnYwMEFVeHQ4N0orZFVqZTA0c1ZQU0VqYyt0M2JjQkVkS2JJY29vYVZZcmlvVzBoU0pWbFZEcFVxWkVMQVdKSVJVaHM1c2RPN0Ftb2dCZFlPaC8wQlh4TW9FRXhNaWxEUGw2YjY3VDcrbmQvZmVBUUVUQUYxeUNnS0k0STBSR3IySm1JTHZ6VEZOZitsTkJNSXRqSVVFcHhNOEVTbis3azB3NFMzVlZKMldhcG1ZK1haeFFVNm5JNVBzQUZBb1h5M2dGTThoZ0JEdVFRUUQyT2F2K0xiRlJDNnFhM1AvVld5R2dXODdkZzJad3h3UEE4ZHZGMXNKZE1LMmdZa1ROV294Ty9ERFZyT29GelNhK1BZcVR4bEV4K25TY3JkUkQrS0RpalozLytUekNiUEN2UTA5bzJmVEZLbnR4d2Z6SlROMVkxWXBmZWc0MWR1Sm5vemVqdHg4cGVNMU54bSswVTNMZUx3ZXVtWEhYYnoxNE83Mnc3WEtXcUZNWkpxblZGSkt3NmhlazRWOFR0ZWVyWFI3MVVSLzNyRWdZUFg1YkVwUWJBTlMwTG42aFpmNEVUSXdBd1hRQUpaOG0vMGJyZTFjZHh2eXh2SHk2UDBSWDNIL2VYL3I2ZGJMOCtQai9lSHJyMko4ZUJoSHU3c1I4Q0JRNG5kOUlpdmdRUU5nMmZmUVlqTHFtc3hQajl6aE13ZWMxVERaZWFMTXNhNTE4Zm9iZWFHYVUzS0NXY2t0TUVrNHF5cFM5b3prS2lwNTVGWjMraStHcjdLU0xNbXpONjBacFZ5UWZ4aXlRZ2FTekVNYUxCby9vL1dOVllDLzhoTmxmZ0I0Mm1OZ1pHQmdBT0puUHNuejR2bHR2akp3TXo4SGlqRGMzdGF3QVU1TC9wZG0vTXMwQzhqbFlHQUNpUUlBYytZTkl3QUFlTnBqWUdSZ1lKcjFYNW9oaW9tWEFRZ1kvekl3TXFBQ0ZnQlNCUU1rQUFBQ0RRQWhBQUFBQUFJTkFBQUNEUUFkQURrQUdRQUFBQ29BS2dBcUFLQUF4Z0VJQUFCNDJtTmdaR0JnWUdNSUFXSVFZQUppUmdhUW1BT0RIa2dBQUF4L0FOUUFBSGphWlkxTkNzSXdFRVpmMVJaRmNTSG9PaXQzS1VtV1BVQlhybnNCcVVYb0Q2UTloY2Z3QUI3Q2t6bHRneUFtRFBObTVwdjVnRFUzSXNhM0lHRWZlTW1aYStDWUxjL0FDUnZlTW8xV0c5SHZKdVhJU3k0Y0E4ZWNlQVJPT1BDaXBtR1FiekZRTjhOZ0plZDB0TkljczZlaVJPRklSYUxJSkx3czZaL1Z1ZStFOVZScllUTUZlZGNPZWVlclVyblVxRXo1UnM4K3dzNXFhN1F6VG5TRjJIaDY3cE81a2pPaklVWHArM3ZYS3B0SzhXL005eHdmQWdRcS93QUFlTnBqWUdKQUJvd002SUFOTE1yRTRNVVF4QkFPQUFQTEFRQUFBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OnJtLWxtdHQxMDtmb250LXNpemU6OS45NjI2NHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJyB0cmFuc2Zvcm09J3NjYWxlKDIgMiknPgo8cGF0aCBkPSdNLTQ1Ljg1MTYtMTQuNzM0MzdILTcwLjE4NzVDLTcxLjA3ODEtMTQuNzM0MzctNzEuODAwOC0xNC4wMTE3Mi03MS44MDA4LTEzLjEyMTA5Vi0xLjg4NjcyQy03MS44MDA4LS45OTYwOS03MS4wNzgxLS4yNzczNC03MC4xODc1LS4yNzczNEgtNDUuODUxNkMtNDQuOTYwOS0uMjc3MzQtNDQuMjM4My0uOTk2MDktNDQuMjM4My0xLjg4NjcyVi0xMy4xMjEwOUMtNDQuMjM4My0xNC4wMTE3Mi00NC45NjA5LTE0LjczNDM3LTQ1Ljg1MTYtMTQuNzM0MzdaJyBmaWxsPScjYTY4MGQ5Jy8+CjxwYXRoIGQ9J00tNDUuODUxNi0xNC43MzQzN0gtNzAuMTg3NUMtNzEuMDc4MS0xNC43MzQzNy03MS44MDA4LTE0LjAxMTcyLTcxLjgwMDgtMTMuMTIxMDlWLTEuODg2NzJDLTcxLjgwMDgtLjk5NjA5LTcxLjA3ODEtLjI3NzM0LTcwLjE4NzUtLjI3NzM0SC00NS44NTE2Qy00NC45NjA5LS4yNzczNC00NC4yMzgzLS45OTYwOS00NC4yMzgzLTEuODg2NzJWLTEzLjEyMTA5Qy00NC4yMzgzLTE0LjAxMTcyLTQ0Ljk2MDktMTQuNzM0MzctNDUuODUxNi0xNC43MzQzN1onIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMTcuMDM5MS0xNC43MzQzN0gtNDEuMzc4OUMtNDIuMjY1Ni0xNC43MzQzNy00Mi45ODgzLTE0LjAxMTcyLTQyLjk4ODMtMTMuMTIxMDlWLTEuODg2NzJDLTQyLjk4ODMtLjk5NjA5LTQyLjI2NTYtLjI3NzM0LTQxLjM3ODktLjI3NzM0SC0xNy4wMzkxQy0xNi4xNDg0LS4yNzczNC0xNS40MjU4LS45OTYwOS0xNS40MjU4LTEuODg2NzJWLTEzLjEyMTA5Qy0xNS40MjU4LTE0LjAxMTcyLTE2LjE0ODQtMTQuNzM0MzctMTcuMDM5MS0xNC43MzQzN1onIGZpbGw9JyNmZjgwODAnLz4KPHBhdGggZD0nTS0xNy4wMzkxLTE0LjczNDM3SC00MS4zNzg5Qy00Mi4yNjU2LTE0LjczNDM3LTQyLjk4ODMtMTQuMDExNzItNDIuOTg4My0xMy4xMjEwOVYtMS44ODY3MkMtNDIuOTg4My0uOTk2MDktNDIuMjY1Ni0uMjc3MzQtNDEuMzc4OS0uMjc3MzRILTE3LjAzOTFDLTE2LjE0ODQtLjI3NzM0LTE1LjQyNTgtLjk5NjA5LTE1LjQyNTgtMS44ODY3MlYtMTMuMTIxMDlDLTE1LjQyNTgtMTQuMDExNzItMTYuMTQ4NC0xNC43MzQzNy0xNy4wMzkxLTE0LjczNDM3Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTExLjc3MzQtMTQuNzM0MzdILTEyLjU2NjRDLTEzLjQ1Ny0xNC43MzQzNy0xNC4xNzU4LTE0LjAxMTcyLTE0LjE3NTgtMTMuMTIxMDlWLTEuODg2NzJDLTE0LjE3NTgtLjk5NjA5LTEzLjQ1Ny0uMjc3MzQtMTIuNTY2NC0uMjc3MzRIMTEuNzczNEMxMi42NjQxLS4yNzczNCAxMy4zODY3LS45OTYwOSAxMy4zODY3LTEuODg2NzJWLTEzLjEyMTA5QzEzLjM4NjctMTQuMDExNzIgMTIuNjY0MS0xNC43MzQzNyAxMS43NzM0LTE0LjczNDM3WicgZmlsbD0nI2IzZmZiMycvPgo8cGF0aCBkPSdNMTEuNzczNC0xNC43MzQzN0gtMTIuNTY2NEMtMTMuNDU3LTE0LjczNDM3LTE0LjE3NTgtMTQuMDExNzItMTQuMTc1OC0xMy4xMjEwOVYtMS44ODY3MkMtMTQuMTc1OC0uOTk2MDktMTMuNDU3LS4yNzczNC0xMi41NjY0LS4yNzczNEgxMS43NzM0QzEyLjY2NDEtLjI3NzM0IDEzLjM4NjctLjk5NjA5IDEzLjM4NjctMS44ODY3MlYtMTMuMTIxMDlDMTMuMzg2Ny0xNC4wMTE3MiAxMi42NjQxLTE0LjczNDM3IDExLjc3MzQtMTQuNzM0MzdaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01OC4wMTk0ODcnIHk9Jy03LjUwNTQwOScgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuMTYyNyAxLjY5NTA0KSc+Z290bzwvdGV4dD4KPHBhdGggZD0nTTQwLjU4NTktMTQuNzM0MzdIMTYuMjQ2MUMxNS4zNTU1LTE0LjczNDM3IDE0LjYzMjgtMTQuMDExNzIgMTQuNjMyOC0xMy4xMjEwOVYtMS44ODY3MkMxNC42MzI4LS45OTYwOSAxNS4zNTU1LS4yNzczNCAxNi4yNDYxLS4yNzczNEg0MC41ODU5QzQxLjQ3NjYtLjI3NzM0IDQyLjE5OTUtLjk5NjA5IDQyLjE5OTUtMS44ODY3MlYtMTMuMTIxMDlDNDIuMTk5NS0xNC4wMTE3MiA0MS40NzY2LTE0LjczNDM3IDQwLjU4NTktMTQuNzM0MzdaJyBmaWxsPScjODA4MGZmJy8+CjxwYXRoIGQ9J000MC41ODU5LTE0LjczNDM3SDE2LjI0NjFDMTUuMzU1NS0xNC43MzQzNyAxNC42MzI4LTE0LjAxMTcyIDE0LjYzMjgtMTMuMTIxMDlWLTEuODg2NzJDMTQuNjMyOC0uOTk2MDkgMTUuMzU1NS0uMjc3MzQgMTYuMjQ2MS0uMjc3MzRINDAuNTg1OUM0MS40NzY2LS4yNzczNCA0Mi4xOTk1LS45OTYwOSA0Mi4xOTk1LTEuODg2NzJWLTEzLjEyMTA5QzQyLjE5OTUtMTQuMDExNzIgNDEuNDc2Ni0xNC43MzQzNyA0MC41ODU5LTE0LjczNDM3Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTY5LjM5ODUtMTQuNzM0MzdINDUuMDU4NUM0NC4xNjc1LTE0LjczNDM3IDQzLjQ0NTUtMTQuMDExNzIgNDMuNDQ1NS0xMy4xMjEwOVYtMS44ODY3MkM0My40NDU1LS45OTYwOSA0NC4xNjc1LS4yNzczNCA0NS4wNTg1LS4yNzczNEg2OS4zOTg1QzcwLjI4OTUtLjI3NzM0IDcxLjAwNzUtLjk5NjA5IDcxLjAwNzUtMS44ODY3MlYtMTMuMTIxMDlDNzEuMDA3NS0xNC4wMTE3MiA3MC4yODk1LTE0LjczNDM3IDY5LjM5ODUtMTQuNzM0MzdaJyBmaWxsPScjODA4MGZmJy8+CjxwYXRoIGQ9J002OS4zOTg1LTE0LjczNDM3SDQ1LjA1ODVDNDQuMTY3NS0xNC43MzQzNyA0My40NDU1LTE0LjAxMTcyIDQzLjQ0NTUtMTMuMTIxMDlWLTEuODg2NzJDNDMuNDQ1NS0uOTk2MDkgNDQuMTY3NS0uMjc3MzQgNDUuMDU4NS0uMjc3MzRINjkuMzk4NUM3MC4yODk1LS4yNzczNCA3MS4wMDc1LS45OTYwOSA3MS4wMDc1LTEuODg2NzJWLTEzLjEyMTA5QzcxLjAwNzUtMTQuMDExNzIgNzAuMjg5NS0xNC43MzQzNyA2OS4zOTg1LTE0LjczNDM3Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTk4LjIwNzUtMTQuNzM0MzdINzMuODcxNUM3Mi45ODA1LTE0LjczNDM3IDcyLjI1NzUtMTQuMDExNzIgNzIuMjU3NS0xMy4xMjEwOVYtMS44ODY3MkM3Mi4yNTc1LS45OTYwOSA3Mi45ODA1LS4yNzczNCA3My44NzE1LS4yNzczNEg5OC4yMDc1Qzk5LjA5NzUtLjI3NzM0IDk5LjgyMDUtLjk5NjA5IDk5LjgyMDUtMS44ODY3MlYtMTMuMTIxMDlDOTkuODIwNS0xNC4wMTE3MiA5OS4wOTc1LTE0LjczNDM3IDk4LjIwNzUtMTQuNzM0MzdaJyBmaWxsPScjZmY4MDgwJy8+CjxwYXRoIGQ9J005OC4yMDc1LTE0LjczNDM3SDczLjg3MTVDNzIuOTgwNS0xNC43MzQzNyA3Mi4yNTc1LTE0LjAxMTcyIDcyLjI1NzUtMTMuMTIxMDlWLTEuODg2NzJDNzIuMjU3NS0uOTk2MDkgNzIuOTgwNS0uMjc3MzQgNzMuODcxNS0uMjc3MzRIOTguMjA3NUM5OS4wOTc1LS4yNzczNCA5OS44MjA1LS45OTYwOSA5OS44MjA1LTEuODg2NzJWLTEzLjEyMTA5Qzk5LjgyMDUtMTQuMDExNzIgOTkuMDk3NS0xNC43MzQzNyA5OC4yMDc1LTE0LjczNDM3Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTEyNy4wMTk1LTE0LjczNDM3SDEwMi42ODM1QzEwMS43OTI1LTE0LjczNDM3IDEwMS4wNzA1LTE0LjAxMTcyIDEwMS4wNzA1LTEzLjEyMTA5Vi0xLjg4NjcyQzEwMS4wNzA1LS45OTYwOSAxMDEuNzkyNS0uMjc3MzQgMTAyLjY4MzUtLjI3NzM0SDEyNy4wMTk1QzEyNy45MTA1LS4yNzczNCAxMjguNjMyNS0uOTk2MDkgMTI4LjYzMjUtMS44ODY3MlYtMTMuMTIxMDlDMTI4LjYzMjUtMTQuMDExNzIgMTI3LjkxMDUtMTQuNzM0MzcgMTI3LjAxOTUtMTQuNzM0MzdaJyBmaWxsPScjYjNmZmIzJy8+CjxwYXRoIGQ9J00xMjcuMDE5NS0xNC43MzQzN0gxMDIuNjgzNUMxMDEuNzkyNS0xNC43MzQzNyAxMDEuMDcwNS0xNC4wMTE3MiAxMDEuMDcwNS0xMy4xMjEwOVYtMS44ODY3MkMxMDEuMDcwNS0uOTk2MDkgMTAxLjc5MjUtLjI3NzM0IDEwMi42ODM1LS4yNzczNEgxMjcuMDE5NUMxMjcuOTEwNS0uMjc3MzQgMTI4LjYzMjUtLjk5NjA5IDEyOC42MzI1LTEuODg2NzJWLTEzLjEyMTA5QzEyOC42MzI1LTE0LjAxMTcyIDEyNy45MTA1LTE0LjczNDM3IDEyNy4wMTk1LTE0LjczNDM3Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTguMDE5NDg3JyB5PSctNy41MDU0MDknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2Mi40MDk1IDEuNjk1MDQpJz5nb3RvPC90ZXh0Pgo8cGF0aCBkPSdNMTU1LjgzMjUtMTQuNzM0MzdIMTMxLjQ5MjVDMTMwLjYwMTUtMTQuNzM0MzcgMTI5Ljg4MjUtMTQuMDExNzIgMTI5Ljg4MjUtMTMuMTIxMDlWLTEuODg2NzJDMTI5Ljg4MjUtLjk5NjA5IDEzMC42MDE1LS4yNzczNCAxMzEuNDkyNS0uMjc3MzRIMTU1LjgzMjVDMTU2LjcyMjUtLjI3NzM0IDE1Ny40NDU1LS45OTYwOSAxNTcuNDQ1NS0xLjg4NjcyVi0xMy4xMjEwOUMxNTcuNDQ1NS0xNC4wMTE3MiAxNTYuNzIyNS0xNC43MzQzNyAxNTUuODMyNS0xNC43MzQzN1onIGZpbGw9JyNhNjgwZDknLz4KPHBhdGggZD0nTTE1NS44MzI1LTE0LjczNDM3SDEzMS40OTI1QzEzMC42MDE1LTE0LjczNDM3IDEyOS44ODI1LTE0LjAxMTcyIDEyOS44ODI1LTEzLjEyMTA5Vi0xLjg4NjcyQzEyOS44ODI1LS45OTYwOSAxMzAuNjAxNS0uMjc3MzQgMTMxLjQ5MjUtLjI3NzM0SDE1NS44MzI1QzE1Ni43MjI1LS4yNzczNCAxNTcuNDQ1NS0uOTk2MDkgMTU3LjQ0NTUtMS44ODY3MlYtMTMuMTIxMDlDMTU3LjQ0NTUtMTQuMDExNzIgMTU2LjcyMjUtMTQuNzM0MzcgMTU1LjgzMjUtMTQuNzM0MzdaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMTg0LjY0NDUtMTQuNzM0MzdIMTYwLjMwNDVDMTU5LjQxNDUtMTQuNzM0MzcgMTU4LjY5NTUtMTQuMDExNzIgMTU4LjY5NTUtMTMuMTIxMDlWLTEuODg2NzJDMTU4LjY5NTUtLjk5NjA5IDE1OS40MTQ1LS4yNzczNCAxNjAuMzA0NS0uMjc3MzRIMTg0LjY0NDVDMTg1LjUzNTUtLjI3NzM0IDE4Ni4yNTc1LS45OTYwOSAxODYuMjU3NS0xLjg4NjcyVi0xMy4xMjEwOUMxODYuMjU3NS0xNC4wMTE3MiAxODUuNTM1NS0xNC43MzQzNyAxODQuNjQ0NS0xNC43MzQzN1onIGZpbGw9JyNjY2YnLz4KPHBhdGggZD0nTTE4NC42NDQ1LTE0LjczNDM3SDE2MC4zMDQ1QzE1OS40MTQ1LTE0LjczNDM3IDE1OC42OTU1LTE0LjAxMTcyIDE1OC42OTU1LTEzLjEyMTA5Vi0xLjg4NjcyQzE1OC42OTU1LS45OTYwOSAxNTkuNDE0NS0uMjc3MzQgMTYwLjMwNDUtLjI3NzM0SDE4NC42NDQ1QzE4NS41MzU1LS4yNzczNCAxODYuMjU3NS0uOTk2MDkgMTg2LjI1NzUtMS44ODY3MlYtMTMuMTIxMDlDMTg2LjI1NzUtMTQuMDExNzIgMTg1LjUzNTUtMTQuNzM0MzcgMTg0LjY0NDUtMTQuNzM0MzdaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTU2LjQ2NDg0IDEuMzIwMzFDLTUzLjU5NzY2IDE3LjU3NDE5LTQwLjY0MDYgMTguMTE3MTktMzMuNDkyMiAzLjY0NDQ5JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTMyLjc1Nzc2OCAxLjk5NjA5MUMtMzIuOTAyMjk5IDIuMTc1Nzc4LTMzLjU5MzcwOCAyLjk0MTQwNi0zNC4xNTYyMDcgMy4zNTU0NjlMLTMyLjg1MTUxOSAzLjk0NTMxM0MtMzIuOTE0MDE5IDMuMjQ2MDk0LTMyLjgwMDc0IDIuMjIyNjU4LTMyLjc1Nzc2OCAxLjk5NjA5MVonLz4KPHBhdGggZD0nTS0zMi43NTc3NjggMS45OTYwOTFDLTMyLjkwMjI5OSAyLjE3NTc3OC0zMy41OTM3MDggMi45NDE0MDYtMzQuMTU2MjA3IDMuMzU1NDY5TC0zMi44NTE1MTkgMy45NDUzMTNDLTMyLjkxNDAxOSAzLjI0NjA5NC0zMi44MDA3NCAyLjIyMjY1OC0zMi43NTc3NjggMS45OTYwOTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ3Mycgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMjcuNjUyMyAxLjMyMDMxQy0yNC43ODUyIDE3LjU3NDE5LTExLjgyODEgMTguMTE3MTktNC42Nzk3IDMuNjQ0NDknIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMy45NDUzMTIgMS45OTYwOTVDLTQuMDg5ODQ0IDIuMTc1Nzg0LTQuNzgxMjQ5IDIuOTQxNDA2LTUuMzQzNzQ5IDMuMzU1NDY5TC00LjAzOTA2MSAzLjk0NTMxM0MtNC4xMDE1NjEgMy4yNDYwOTQtMy45ODgyNzkgMi4yMjI2NTItMy45NDUzMTIgMS45OTYwOTVaJy8+CjxwYXRoIGQ9J00tMy45NDUzMTIgMS45OTYwOTVDLTQuMDg5ODQ0IDIuMTc1Nzg0LTQuNzgxMjQ5IDIuOTQxNDA2LTUuMzQzNzQ5IDMuMzU1NDY5TC00LjAzOTA2MSAzLjk0NTMxM0MtNC4xMDE1NjEgMy4yNDYwOTQtMy45ODgyNzkgMi4yMjI2NTItMy45NDUzMTIgMS45OTYwOTVaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ3Nicgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMy41ODU5LTE2LjI2NTYyQy0xNC42NzU4LTQ2LjczODMxIDg0Ljg3NTUtNDkuNDkyMjEgODcuNTQyNS0xOC45NzY2MScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTg3LjUzNTE2MS0xNy4xNjQxMTdDODcuNTg5ODUtMTcuMzg2NzcyIDg3LjkwMjM0OC0xOC4zNjcyMzggODguMjQyMTg5LTE4Ljk4MDUyMUw4Ni44MDg1OTItMTguOTcyNzA3Qzg3LjE1NjI1Ny0xOC4zNjMzMyA4Ny40NzY1NjYtMTcuMzg2NzcyIDg3LjUzNTE2MS0xNy4xNjQxMTdaJy8+CjxwYXRoIGQ9J004Ny41MzUxNjEtMTcuMTY0MTE3Qzg3LjU4OTg1LTE3LjM4Njc3MiA4Ny45MDIzNDgtMTguMzY3MjM4IDg4LjI0MjE4OS0xOC45ODA1MjFMODYuODA4NTkyLTE4Ljk3MjcwN0M4Ny4xNTYyNTctMTguMzYzMzMgODcuNDc2NTY2LTE3LjM4Njc3MiA4Ny41MzUxNjEtMTcuMTY0MTE3Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0ODMnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNODcuNTkzNSAxLjMyMDMxQzkwLjQ2MDUgMTcuNTc0MTkgMTAzLjQxNzUgMTguMTE3MTkgMTEwLjU2NjUgMy42NDQ0OScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTExMS4zMDA1NjQgMS45OTYwOUMxMTEuMTU2MDMxIDIuMTc1Nzg2IDExMC40Njg1MyAyLjk0MTQwOCAxMDkuOTAyMTI1IDMuMzU1NDY4TDExMS4yMDY4MjEgMy45NDUzMTdDMTExLjE0NDMwOSAzLjI0NjA5NSAxMTEuMjU3NjAyIDIuMjIyNjYyIDExMS4zMDA1NjQgMS45OTYwOVonLz4KPHBhdGggZD0nTTExMS4zMDA1NjQgMS45OTYwOUMxMTEuMTU2MDMxIDIuMTc1Nzg2IDExMC40Njg1MyAyLjk0MTQwOCAxMDkuOTAyMTI1IDMuMzU1NDY4TDExMS4yMDY4MjEgMy45NDUzMTdDMTExLjE0NDMwOSAzLjI0NjA5NSAxMTEuMjU3NjAyIDIuMjIyNjYyIDExMS4zMDA1NjQgMS45OTYwOVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDczJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTExNi40MDY1LTE2LjMyODEyQzEyNS45NDE1LTcwLjQwNjIxLTQzLjA0NjktNjkuMjg5MTEtMzMuMDExNy0xOC44MzU5MScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTS0zMi41NjI1MDUtMTcuMDc4MTA1Qy0zMi41NjI1MDMtMTcuMzA0NjY1LTMyLjQ5MjE5NC0xOC4zMzIwMTMtMzIuMzA4NjAxLTE5LjAxMTdMLTMzLjY5OTIyNi0xOC42NjQwNDNDLTMzLjIxNDg1MS0xOC4xNTIzMjUtMzIuNjcxODgxLTE3LjI3NzMyNi0zMi41NjI1MDUtMTcuMDc4MTA1WicvPgo8cGF0aCBkPSdNLTMyLjU2MjUwNS0xNy4wNzgxMDVDLTMyLjU2MjUwMy0xNy4zMDQ2NjUtMzIuNDkyMTk0LTE4LjMzMjAxMy0zMi4zMDg2MDEtMTkuMDExN0wtMzMuNjk5MjI2LTE4LjY2NDA0M0MtMzMuMjE0ODUxLTE4LjE1MjMyNS0zMi42NzE4ODEtMTcuMjc3MzI2LTMyLjU2MjUwNS0xNy4wNzgxMDVaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ5Nicgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjwvZz4KPC9zdmc+" /></p>
<p>The <code>goto</code> is a pretty powerful construction, but it also has its caveats. So much for its use to be <a href="https://dl.acm.org/doi/10.1145/362929.362947">considered harmful</a>. Although any kind of program flow can be constructed using only <code>goto</code>, it may become too confuse. The <code>goto</code> statement makes it too easy to write spaghetti code, which is practically impossible to debug.</p>
<p>After prehistory, we arrive into the societal period of imperative programming. In here, the programming languages become <em>structured</em>. Data is no long viewed as simply a stack of memory but classified into types. There are some primitive types as well as structures to combine them into more complex types. In a language like C, for example, there are <code>struct</code> types, <code>union</code> types, and array types.</p>
<p>The changes also arrived to the control flow and an effort was made to tame the once wild <code>goto</code>. The programmers from that time analysed its most common use cases and created new statements fulfill each of these. You are probably acquainted to them as <code>for</code> loops, <code>while</code> loops, <code>switch/case</code> statements, function and subroutine declarations and <code>if/else</code> statements; just to name a few.</p>
<p>Both in regards to data and control flow, the movement we encounter in here consists of substituting general purpose structures that concretely represent the instructions we give to the processor by specific structures having more abstract roles in the code. In terms of computational expressiveness, nothing changes. What the processor sees is the same in both unstructured and structured programming. The benefit lies in the programmer’s expressiveness. With more specific statements, it becomes easier to write larger, more complex programs as well as properly debug them. As an example, we may notice that it is possible to guarantee that a <code>for</code> loop always terminates if it is iterating over a block of code that is known to terminate. No strange thing can happen. On the other side, the general character of the <code>goto</code> allows us to simulate the behavior of a <code>for</code> but there is no guarantee that a program with a <code>goto</code> statement must terminate.</p>
<p>Until now, we were looking at a programming paradigm called <em>imperative programming</em>, but the world of programming languages is not so uniform. Other paradigms exist. And the one that mostly fits what we will see today is called <em>functional programming</em>.</p>
<p>While the imperative paradigm views the code as a sequence of commands the programmer gives the computer to execute (hence the name, <em>imperative</em>), the functional paradigm views the code as a composition of functions in the mathematical sense. A function takes a value as input, does some processing to it, calling other functions for it, and returns another value as output.</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzU4Ny4zMTgxOTlwdCcgaGVpZ2h0PSc0Ni4xNDg2cHQnIHZpZXdCb3g9Jy0xMzcuMzU5Mjc5IC0xNDQuMDAwMSA1ODcuMzE4MTk5IDQ2LjE0ODYnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5Omxtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTzhBQTBBQUFBQUJRUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZiswOVRMeklBQUFGTUFBQUFRd0FBQUZaVXFsd1pZMjFoY0FBQUFaQUFBQUJCQUFBQlFnQVBCR1ZqZG5RZ0FBQUIxQUFBQUFRQUFBQUVBQ0VCbldkaGMzQUFBQUhZQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWVBQUFBQjVBQUFBZk9CY2x2Tm9aV0ZrQUFBQ1hBQUFBREFBQUFBMkY5VkVCR2hvWldFQUFBS01BQUFBSGdBQUFDUURRZ0ViYUcxMGVBQUFBcXdBQUFBUUFBQUFFQU5DQUhkc2IyTmhBQUFDdkFBQUFBb0FBQUFLQUdnQVZHMWhlSEFBQUFMSUFBQUFId0FBQUNBQVNBQTZibUZ0WlFBQUF1Z0FBQUM4QUFBQkl3TGtmdEJ3YjNOMEFBQURwQUFBQUJZQUFBQXFBTW9BQTNqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5RTBRQmNkUWlGQUFCNDJtTmdaQlJqbk1EQXlzREExTW0wbTRHQm9SdENNOTVuTUdSa0Fvb3lzSEl5d0FBVEF4SUlTSE5OQVZMYkdiWXo3dnQ3blNHS2NSOVltQkZFQUFETHd3dHFBSGphWTJCZ1lHYUFZQmtHUmdZUXNBSHlHTUY4RmdZRklNMENoQ0QrOXYvL0llUi9INmhLQmtZMkJoaVRnWkVKU0RBeG9BSkdocUVQbVBGTEF3QUhvd2QwQUFBQUFDRUJuUUFBQUFILy93QUNlTnBqWUdKUVpHQmcxR1RjeDhETXdNNmd0NUdSUWQ5bUV6c0x3MXVqald5c2QydzJNVE1CbVF3Ym1VSENyQ0RoVGV4c2pIOXNOakdDeEkwRkZRWFZqUVdWRlJrNW5oODd4cmp2bjVNaVl3MERBeE5ER01OUmhnT00ra0FUT1JnWXpFelVsTmhFeEl6TUQ4anJ5QVBSRXpCcHlnQUF2a2tidEFBQUFIamFZMkJrWUdBQTRuTWh2UGZqK1cyK01uQXpQd2VLTU56ZTFyQVJUaXNDbFdneTdnTnlPUmlZUUtJQVV3NExQWGphWTJCa1lHRGN4OERBRU1Vb0JpUVpHRFVaR0JsUUFRc0FKbHNCWVFBQUFSWUFJUUFBQUFBQkZnQUFBUllBVmdBQUFDb0FLZ0FxQUQ0QUFIamFZMkJrWUdCZ1llQmtZR0lBQVJESnlBQVNjMkRRQXdrQUFBU2FBSU1BZU5wTmpVMEt3akFRaFQvL0ZVVmNpY3VBNjVZa1N3L1FBN2h3cll0WUNyV0Z0RjI0OXhnZXdCTjRQcWN4aUJPRytXYnllQStZYzJWQVgwTm1iQ0tQMkhPT1BHSEpNL0pVM2x0K0IrT0Y2TmRCMmZPSWpGM2tDVnNla2Flc2VISEVrZE5SY3NIRDBlVmRlUkhJcUtsb3cvU2ljQ2dzS1ZybVFicmtSc01kODd0WTRTVHNpYkFPVFZaWGJWYjczQ21iYW5WUTVhMjVteDZzU1l4T3JMWWlPb203RjdjaVpDcng2SE00T2Q4VWRhVk1Lc3QvSGw4WFB1OGdLQlI0Mm1OZ1lrQUdqQXpvZ0FVc3lzUndHQUFCaVFET0FBQT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpsbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdRQUEwQUFBQUFCMEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGYrMDlUTHpJQUFBRk1BQUFBUWdBQUFGWldXVjdrWTIxaGNBQUFBWkFBQUFCSEFBQUJRZ01UQ1JOamRuUWdBQUFCMkFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIY0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlUUFBQUk1QUFBQ3FPTmRRUHRvWldGa0FBQUVJQUFBQURFQUFBQTJHTU5FTzJob1pXRUFBQVJVQUFBQUlBQUFBQ1FGUmdFOGFHMTBlQUFBQkhRQUFBQVlBQUFBR0FqQUFKeHNiMk5oQUFBRWpBQUFBQTRBQUFBT0FnNEJSRzFoZUhBQUFBU2NBQUFBSHdBQUFDQUFUQUI1Ym1GdFpRQUFCTHdBQUFDOEFBQUJJL3kwZUxSd2IzTjBBQUFGZUFBQUFCZ0FBQUF1QUowQVRIamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUUwUUJjZFFpRkFBQjQybU5nWkdKaW5NREF5c0RBMU1XMGg0R0JvUWRDTXo1Z01HUmtBb295c0RJendBQWpBeElJU0hOTkFWSnBEQmxNNy82ek1VUXhIV1E0QzFNREFMZmRDdWtBQUhqYVkyQmdZR2FBWUJrR1JnWVFzQUh5R01GOEZnWUZJTTBDaENCK3h2Ly9RREx0Ly8vL2M2RXFHUmpaR0dCTUJrWW1JTUhFZ0FvWUdhZ0VtRmxZR1FZbkFBQzNCQWN1QUFBaEFua0FBQUFCLy84QUFuamFQWkU3YjlOUUdJYS83L2h5WXNkMkdqdE9RaE1uc1IwblZaSTJxUzl4YUZJSEJmVWlvQ3hJQVhWaFEwZ01pSUd0RTJLdm1KQTZNUEVIa29FQklRRlQvd1BpQjdBd3NsSEtjVXJ4WkQydmovVzg1d1VDTmdCMnlCbHdRR0ZyZ2RDZkxDa1BQLzJGS0h5ZkxEbkNYbUhCcFZoSThaS0srSHV5eEpRSGVUdmZEdkt1amRLUDgzTnlkdkhFSm84QUNFU1hBZGtnWDJFZkR0amZ3NWJyaUZTa3JxT2hXU2lPa2RNNDEya25HSzBTaGdKL0dDY2tOZ0kvaFYxTU1CN0d3OEF2clE2d05DSWJrZU1lRnFUeW5pSm5sTFhaWFNsclZnekxxTjBvNWt3bnRMMGRYYXVxT0ptenVQSkFrTVU4WGF2WERHc1ZrNU9HRjh6c0U1U2tEUC9uNVdCN1d0V0ptMTh6N0VyRG0zalZ4Mk1KZDFHU3M5YklPdFljblhOV0diQ0hoOXhsZ04vd0kzU2dDMU80QlNBWVlXcVpkdHJDYS8rNHhBcUsxNjMrbHpLdWFDc0tXVUVNL0JyclEvSHBjNEtXc3M1cHZ2WHc3ZEZvR3FHOTNuSTN0K3Rtd1dpNXljSDhoV29OYUsvVGR1ck5ncmxic3pheTNHMzhSS2pJVll4eTFWMDhPNXp2NE92eGVra1c2em5OckZmcXRYbUlyejQzV3MxUjB6djEybjYzU1RrRjBpM2l5MS9FSVI5Z2o2MEIza3BiWTlwUkdBOVg5MCtOTUIyR1hpa3pRY3I5czU4U05rS2NiaEg0VFB1S0ppUWlqa0o1WGd1OHNyNDdpZWZKZlZVZWpESkdWaTJWZU80TmI4aUt5UnRGUldBZmRZcUR3VEJSKzI0anRuS25zcUQ2ZCt4SzcvM0l2M21FU1pZWGtPZ1pYaERGd3NVWExaTlRjOWw3eDcyU1dWWVMzZDJmdmZOMHQ3ODU3b2tBZndGUVFHZ3ZBQUFBZU5wallHUmdZQURpN1VYTHRPUDViYjR5Y0RPL0FJb3czTjdXc0JGTzgvODNadEpnT2dqa2NqQXdnVVFCWWs0TVRnQUFBSGphWTJCa1lHQTYrTitZSVlySmdZSGgveUVtRFFhZ0NBcGdBd0IwakFTRkFXd0FJUUFBQUFBQlRRQUFBZW9BTlFIZEFBOENRQUEzQUFBQUtnQXFBQ29Ba0FEd0FWUUFBSGphWTJCa1lHQmdZL0JnWUdFQUFTWWdabVFBaVRrdzZJRUVBQXNsQU1ZQWVOcE5qVTBLd2pBUWhUK3R2eWppU2x3R1hMY2tXZllBUFlDTHJuVVJTNkUvRVBVR0hzTURlQUxQNTZRR01jTXczMlFlN3dFTExvd0liOHljYmVTRUE2ZklVMVk4STgrazNuSWRUWmFpM3d6S3dBa0YrOGhUZGp3aXoxano0b2lqNGs3REdROUhWOTJiczBCQlQ4ZHRtRjRVRG9VbFE4dk1wUnRhcVJyeis3SEM2YkNud25wb2lyNjdGYjJ2bkxLWlZybHEyclkyQWF4SmpVNnR0aUlxeGQxekZiZVFxY1FqNUZBNmY2MzdUcGxNbHY4OHZpNThBTnhBSjd4NDJtTmdZc0FQMklDWWtZR0p3WlBCaThFYkFBT0RBT289KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6cm0tbG1yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVhnQUEwQUFBQUFCNndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGYrMDlUTHpJQUFBRk1BQUFBUWdBQUFGWldlbDdNWTIxaGNBQUFBWkFBQUFCWUFBQUJVZ1NRRWIxamRuUWdBQUFCNkFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIc0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFmUUFBQUpvQUFBQzZHQ0JudVJvWldGa0FBQUVYQUFBQURFQUFBQTJHTFpFSG1ob1pXRUFBQVNRQUFBQUhnQUFBQ1FGRFFGMGFHMTBlQUFBQkxBQUFBQWtBQUFBSkEzTEFNMXNiMk5oQUFBRTFBQUFBQlFBQUFBVUFwSURkbTFoZUhBQUFBVG9BQUFBSHdBQUFDQUFUd0JnYm1GdFpRQUFCUWdBQUFDM0FBQUJLUjlNTTVGd2IzTjBBQUFGd0FBQUFCNEFBQUEwQVFFQS9uamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUUwUUJjZFFpRkFBQjQybU5nWkx6Qk9JR0JsWUdCcVpOcE53TURRemVFWnJ6UFlNaklCQlJsWUdWbWdBRkdCaVFRa09hYUFxUXlHVXFacGYrYk1FUXh6V0k0QkZNREFPODRDdklBQUhqYVkyQmdZR2FBWUJrR1JnWVE4QUh5R01GOEZnWURJTTBCaEV4QU9wT2hnS0gwLzM4d0s0K2g1UC8vLzdQK1Qvcy9HYW9MREJqWkdPQmNScEFlSmdaVXdNaEFQUUJ5TXdNTEs5QktCbllPaGtFREFLQk1ERnNBSVFKNUFBQUFBZi8vQUFKNDJtV1N6VThUUVJqRzM1a3RYY3FHajZYZDdXN1Q3aWZkUlNoTDJOM3BpclFZS0FlVkptS1E4Q1dJTVdKSWpNS0JHeGVoSno4Q2hzUURmNEZYZWlJZTFCTi9nbmd3OFdoTTlLU0VpeFpuRnpRbUh0N0p6RFBKKzh6dmZRWXc2QURvQXQ0REJsaHc5aEgwbCtwc0RMNjUrL0dtajZVNmcra1c5cGxRYmdybE9odEhQMHQxRk9vZXIvTzJ4NXM2YXY1OGVJajNmaTNyZUFZZ0Z2YUVFL3dDZU9nRUJWUUFqeGdXNFZuQkZRVStGVGVGd0UwenZtVWFjU0VsZW02Um5Bd0l6d1prbVR6RXk0RXFTa3BVYlFwNnhLbWQrY1ozclZWbEdIeEwwUFJVV0xRN0JvMHVhZlFhQ3RBSG9CUER3V1hrV3padHlwSi9qTkxVbVY0VVBWZk1vVE1GcHlWQlNpUkVaZnhlLzNNL0k1TzFWU0pQK3IxcXVGTlJVeXYzOXNwRk9iK3l3cW5KZk9OSFpLNjJhZ2RYcDB2ZWwrZ1VNbVpQajlFUmVnY3R3RUdPVWtJK0FqcmpzVk5zR3pJTjJ5SitNSXc4TnkwSzZHaHpmdUZ4YlhaK2ExTGtoL1BqdGl3bEwydlg3TXo3cFNkUDMyeHVMVGJQRll6dVN1SE9Ra0UzUm5xWHpqeUdjWUl5aHYzN3dEbjMrSjhQS3loME5hbGkyQTRxbzlCVEZIQmlZMnFpdEVQb1lGZlhpQnl2dVBPMXllbkJrZTZXbURobUI5Yy9MTlpHUnptVjF4dUZQNUN2RWttdmRudG12ZHpCdFgreWV0WnZSck5PVXRZcXZnOVoraExJRTFNSWpRanZFWk9ZYlpnVlBENmw0UEFGcUNwYnVjcjJ0b3lFc2pPVmM3bzZCOXlOd1lBTVBVQ2lldUJNakdDeDhiVjNTRXJjS0VZWm5oNUhHWnJRRldWNC9rZWlvR2lnZjA4SzQ3bUJFT0MwbjluMU01V2lZblhFZGkrbGNJZFNLa3ozN05DWTBOMHdyUHJvYkx1V2xWQ1ZVNld4bDVwZXpJcHpjeHhGK0EzVGlZc0FlTnBqWUdSZ1lBRGl6TGlvMi9IOE5sOFp1Sm1mQTBVWWJtOXIyQWluaGYvYk1Za3p6UUp5T1JpWVFLSUFYNElNSmdBQUFIamFZMkJrWUdDYTlkK09JWXBKaHdFSW1NUVpHQmxRQVNjQVNBb0NoZ0FBQVdzQUlRQUFBQUFCVFFBQUFSWUFJUUlzQUNBQjlBQWNBaXdBSEFHRkFCTUNMQUFnQUFBQUtnQXFBQ29BWEFDY0FNNEJFZ0UrQVhSNDJtTmdaR0JnNEdUUVoyQmhBQUVtSUdaa0FJazVNT2lCQkFBSkJRQ3dBSGphWFkwN0RzSXdESVkvSGtXOEJzVEFuSVV4VlpLeEIrakFBVHF5bGFwU0gxTGFJM0FNRHNBWk9CMXVDQkxDa3VYUDltLy93Sm9iTTZhWWs3Q1B2T0RNTlhMQ2prZmtsZWhmc3AwdE42TGZCdVhFQ3k0Y0l5ZWN1RWRlY2VCSlE0dkhZcUJwdlpXUzA5TXhodXFwS0ZFNFVsRW9Na2t2Ri9ybjdqTjF3anIwV3RpRUpPKzdNZTk5VlNxWEdwVXAzK3BnSXVpc3RrWTc0MFJXaUlkbm9BN09TcjVNYmhTbEgrcStVemFWNXQrVjd5L2UrdlVvRGdCNDJtTmdZc0FQT0lHWWtZR0p3WWNoa0NHSUlaZ2huQ0VDQUF6RkFnQUFBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5Omxtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpsbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6cm0tbG1yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMScgdHJhbnNmb3JtPSdzY2FsZSgyIDIpJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTcuMDU2NDM5JyB5PSctNjAuNDYyMTQnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMS42MjMyIDIuMTY4MyknPmlucHV0PC90ZXh0Pgo8cGF0aCBkPSdNOS4zMDg2LTYwLjQ2MDkzN0M5LjMwODYtNjYuNzIyNjYgNC4yMzQ0LTcxLjgwMDgtMi4wMjczLTcxLjgwMDhDLTguMjg5MS03MS44MDA4LTEzLjM2NzItNjYuNzIyNjYtMTMuMzY3Mi02MC40NjA5MzdDLTEzLjM2NzItNTQuMTk5MjItOC4yODkxLTQ5LjEyNS0yLjAyNzMtNDkuMTI1QzQuMjM0NC00OS4xMjUgOS4zMDg2LTU0LjE5OTIyIDkuMzA4Ni02MC40NjA5MzdaJyBmaWxsPScjY2NmNWQ2Jy8+CjxwYXRoIGQ9J005LjMwODYtNjAuNDYwOTM3QzkuMzA4Ni02Ni43MjI2NiA0LjIzNDQtNzEuODAwOC0yLjAyNzMtNzEuODAwOEMtOC4yODkxLTcxLjgwMDgtMTMuMzY3Mi02Ni43MjI2Ni0xMy4zNjcyLTYwLjQ2MDkzN0MtMTMuMzY3Mi01NC4xOTkyMi04LjI4OTEtNDkuMTI1LTIuMDI3My00OS4xMjVDNC4yMzQ0LTQ5LjEyNSA5LjMwODYtNTQuMTk5MjIgOS4zMDg2LTYwLjQ2MDkzN1onIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU3LjA1NjQzOScgeT0nLTYwLjQ2MjE0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi4wNTI4MSAyLjQ5MDcpJz5mPC90ZXh0Pgo8cGF0aCBkPSdNLTQxLjkxNDEtNjAuNDYwOTM3SC0xOC4yMzA1JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjc5NzAxJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTS0xMy41NjY0NC02MC40NjA5MzdDLTE0Ljk0OTI1LTYwLjcyMjY1NS0xNy4xOTE0NC02MS41LTE4Ljc0NjEyNS02Mi40MDYyNVYtNTguNTE5NTNDLTE3LjE5MTQ0LTU5LjQyNTc4LTE0Ljk0OTI1LTYwLjIwMzEyNC0xMy41NjY0NC02MC40NjA5MzcnLz4KPHBhdGggZD0nTTYwLjczNDYtNjAuNDYwOTM3QzYwLjczNDYtNjYuNzIyNjYgNTUuNjU2Ni03MS44MDA4IDQ5LjM5NDYtNzEuODAwOFMzOC4wNTQ3LTY2LjcyMjY2IDM4LjA1NDctNjAuNDYwOTM3QzM4LjA1NDctNTQuMTk5MjIgNDMuMTMyNi00OS4xMjUgNDkuMzk0Ni00OS4xMjVTNjAuNzM0Ni01NC4xOTkyMiA2MC43MzQ2LTYwLjQ2MDkzN1onIGZpbGw9JyNmY2MnLz4KPHBhdGggZD0nTTYwLjczNDYtNjAuNDYwOTM3QzYwLjczNDYtNjYuNzIyNjYgNTUuNjU2Ni03MS44MDA4IDQ5LjM5NDYtNzEuODAwOFMzOC4wNTQ3LTY2LjcyMjY2IDM4LjA1NDctNjAuNDYwOTM3QzM4LjA1NDctNTQuMTk5MjIgNDMuMTMyNi00OS4xMjUgNDkuMzk0Ni00OS4xMjVTNjAuNzM0Ni01NC4xOTkyMiA2MC43MzQ2LTYwLjQ2MDkzN1onIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU3LjA1NjQzOScgeT0nLTYwLjQ2MjE0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDMuODk2IDEuMTc2MiknPmc8L3RleHQ+CjxwYXRoIGQ9J005LjUwNzgtNjAuNDYwOTM3SDMzLjE5NTMnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuNzk3MDEnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMzcuODU1NS02MC40NjA5MzdDMzYuNDc2NTktNjAuNzIyNjU1IDM0LjIzMDUtNjEuNSAzMi42NzU4MTQtNjIuNDA2MjVWLTU4LjUxOTUzQzM0LjIzMDUtNTkuNDI1NzggMzYuNDc2NTktNjAuMjAzMTI0IDM3Ljg1NTUtNjAuNDYwOTM3Jy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU3LjA1NjQzOScgeT0nLTYwLjQ2MjE0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTIuMDYxOSAyLjIxMzkpJz7Ctzx0c3BhbiB4PSctNTIuNjI4NjMxJz7CtzwvdHNwYW4+Cjx0c3BhbiB4PSctNDguMjAwODIzJz7CtzwvdHNwYW4+CjwvdGV4dD4KPHBhdGggZD0nTTYwLjkzMzYtNjAuNDYwOTM3SDg0LjYxNzYnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuNzk3MDEnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNODkuMjc3MzQtNjAuNDYwOTM3Qzg3Ljg5ODQzLTYwLjcyMjY1NSA4NS42NTIzNC02MS41IDg0LjA5NzY0OS02Mi40MDYyNVYtNTguNTE5NTNDODUuNjUyMzQtNTkuNDI1NzggODcuODk4NDMtNjAuMjAzMTI0IDg5LjI3NzM0LTYwLjQ2MDkzNycvPgo8cGF0aCBkPSdNMTYzLjU3ODYtNjAuNDYwOTM3QzE2My41Nzg2LTY2LjcyMjY2IDE1OC41MDM2LTcxLjgwMDggMTUyLjIzODYtNzEuODAwOEMxNDUuOTc2Ni03MS44MDA4IDE0MC45MDI2LTY2LjcyMjY2IDE0MC45MDI2LTYwLjQ2MDkzN0MxNDAuOTAyNi01NC4xOTkyMiAxNDUuOTc2Ni00OS4xMjUgMTUyLjIzODYtNDkuMTI1QzE1OC41MDM2LTQ5LjEyNSAxNjMuNTc4Ni01NC4xOTkyMiAxNjMuNTc4Ni02MC40NjA5MzdaJyBmaWxsPScjYzliM2U4Jy8+CjxwYXRoIGQ9J00xNjMuNTc4Ni02MC40NjA5MzdDMTYzLjU3ODYtNjYuNzIyNjYgMTU4LjUwMzYtNzEuODAwOCAxNTIuMjM4Ni03MS44MDA4QzE0NS45NzY2LTcxLjgwMDggMTQwLjkwMjYtNjYuNzIyNjYgMTQwLjkwMjYtNjAuNDYwOTM3QzE0MC45MDI2LTU0LjE5OTIyIDE0NS45NzY2LTQ5LjEyNSAxNTIuMjM4Ni00OS4xMjVDMTU4LjUwMzYtNDkuMTI1IDE2My41Nzg2LTU0LjE5OTIyIDE2My41Nzg2LTYwLjQ2MDkzN1onIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU3LjA1NjQzOScgeT0nLTYwLjQ2MjE0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMDYuNDI2NCAzLjQ1OTMpJz5oPC90ZXh0Pgo8cGF0aCBkPSdNMTEyLjM1NTYtNjAuNDYwOTM3SDEzNi4wMzg2JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjc5NzAxJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTE0MC43MDI2OC02MC40NjA5MzdDMTM5LjMxOTg3LTYwLjcyMjY1NSAxMzcuMDczNzctNjEuNSAxMzUuNTE5MDg3LTYyLjQwNjI1Vi01OC41MTk1M0MxMzcuMDczNzctNTkuNDI1NzggMTM5LjMxOTg3LTYwLjIwMzEyNCAxNDAuNzAyNjgtNjAuNDYwOTM3Jy8+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjA1NjQzOScgeT0nLTYwLjQ2MjE0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNTIuNzAxNCAyLjE2ODMpJz5vdXRwdXQ8L3RleHQ+CjxwYXRoIGQ9J00xNjMuNzc3Ni02MC40NjA5MzdIMTg3LjQ2MDYnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuNzk3MDEnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMTkyLjEyNDcyLTYwLjQ2MDkzN0MxOTAuNzQxOTEtNjAuNzIyNjU1IDE4OC40OTk3Mi02MS41IDE4Ni45NDUwMzItNjIuNDA2MjVWLTU4LjUxOTUzQzE4OC40OTk3Mi01OS40MjU3OCAxOTAuNzQxOTEtNjAuMjAzMTI0IDE5Mi4xMjQ3Mi02MC40NjA5MzcnLz4KPC9nPgo8L3N2Zz4=" /></p>
<p>If every program consists only of applying a finite amount of previously defined functions, the language’s expressiveness seems rather limited. To overcome this, we need some form of control flow, which is achieved via recursion.</p>
<p>A <em>recursive function</em> is a function that, in order to process its input into the output, may call itself in an intermediate step. Probably the most famous recursive function is the factorial, defined as <span class="math display"> \operatorname{\mathrm{fat}}(n) = \begin{cases}
        1,&amp; n = 0 \\
        n \cdot \operatorname{\mathrm{fat}}(n-1),&amp; \text{otherwise}.
    \end{cases}
</span></p>
<p>The expressiveness gained from recursion is essentially the same as the one gained from <code>goto</code> in imperative languages. That is, the control flow given by function composition together with recursion allows one to do anything imaginable with the programming language. However, all this expressiveness comes with its caveats. It is too easy to write a functional spaghetti code if recursion is used indiscriminately. Because of all its power, recursive code lacks in safety. It would even be fair to say that, like <code>goto</code>, it is too unstructured.</p>
<p>The idea of structured control flow really caught on in the imperative world. One hardly sees a wild <code>goto</code> in the middle of a modern piece of code. In fact, many languages don’t even allow it. In the functional world, on the other side, the trendy for taming recursion never really caught on. Despite many functional languages organizing their data using types, control is still done using crude recursion.</p>
<p>Recursion schemes are ways to organize and structure different kinds of recursive functions. Instead of writing a recursive function in terms of itself, we define higher order functions that receive an ordinary function as argument, do some recursive magic on it, and return a recursive analogue of that function as output. It is similar to how a <code>while</code> loop takes a boolean statement and a block of code, and turns them into a repeating block of code. If it seems too confusing, just keep on. What I mean in here will become clearer after we <a href="#sec:cata">construct catamorphisms</a>.</p>
<p>Before we end this motivation and proceed to the actual construction of recursion schemes, there is an intuition that I believe useful to have in mind. In imperative programming, there is a close relationship between how we structure data and how we structure the control flow. Working with arrays almost asks the programmer to design programs with <code>for</code> loops. Similarly, it is natural to deal with <code>union</code> types using <code>switch</code> statements (also called <code>case</code> or <code>cond</code> in some languages). Recursion schemes will arise as an analogous to this idea in the functional programming setting. So far so good for motivation, let’s dive into some math.</p>
<h2 id="sec:ADT">Algebraic Data Types</h2>
<p>The simplest form to write a type is by enumerating its elements such as <span class="math display">\mathtt{Bool}\coloneqq \mathop{\mathrm{true}}\mid \mathop{\mathrm{false}}.</span> This way, we define the type of boolean values. That is, a type with exactly two terms called <span class="math inline">\mathop{\mathrm{true}}</span> and <span class="math inline">\mathop{\mathrm{false}}</span>. In general any finite type can be written just by enumerating its elements. As another example, there is the type of musical notes <span class="math display"> \mathtt{Notes} \coloneqq
    \mathtt{do} \mid
    \mathtt{re} \mid
    \mathtt{mi} \mid
    \mathtt{fa} \mid
    \mathtt{sol}\mid
    \mathtt{la} \mid
    \mathtt{si}.</span> Nevertheless, in practice we also want to deal with types that are more complex than simply finite collections. The solution to this is assuming that the programming language comes with some built-in types such as integers, characters, and floating-point numbers, together with structures that allow us to compose these types.</p>
<p>One common compound type consists of a structure capable of storing data of more than one type at the same time. As an example, let’s say we are in a spacial war against many alien species. Your job is to catalogue how many battleships each army has. One way to store this data is with a type containing a string for the species which the army belongs together with a natural number for how many battleships they have. We will write this type as <span class="math display">\mathtt{Army} \coloneqq \operatorname{\mathrm{ships}}\; \mathtt{String} \times \mathbb{N}.</span> Here, <span class="math inline">\operatorname{\mathrm{ships}} \colon \mathtt{String} \times \mathbb{N}\to \mathtt{Army}</span> is called a <em>constructor</em> for the type <span class="math inline">\mathtt{Army}</span>. Constructors are (possibly multivariate) functions that receive terms as arguments and return a term of a compound type.</p>
<p>After you finish your catalogue, orders arrive for you to develop a new laser cannon to be used in the war. This weapon should scan the sky to find the enemy armies’ positions (modeled in a type <span class="math inline">\mathtt{Pos}</span> and shoot them. But beware! There are also allied bases around, encapsulated in the type <span class="math inline">\mathtt{Base}</span>. Since friendly fire is really far from the ideal, our target type should have two different constructors, one for allies and another for enemies: <span class="math display">\mathtt{Target} \coloneqq \operatorname{\mathrm{ally}}\; \mathtt{Position} \times \mathtt{Base}
                  \mid \operatorname{\mathrm{enemy}}\; \mathtt{Position} \times \mathtt{Army}.</span> In here we extended our notation for enumerating types to also accept constructors. Different constructors always produce different terms of the compound type, thus, we may view the functions <span class="math inline">\operatorname{\mathrm{ally}} \colon \mathtt{Position} \times \mathtt{Base} \to \mathtt{Target}</span> and <span class="math inline">\operatorname{\mathrm{enemy}} \colon \mathtt{Position} \times \mathtt{Army} \to \mathtt{Target}</span> as tags representing from which type our <span class="math inline">\mathtt{Target}</span> was constructed. This works as if we are storing a element of type <span class="math inline">\mathtt{Army}</span> together with a tag <span class="math inline">\operatorname{\mathrm{enemy}}</span> on the type <span class="math inline">\mathtt{Target}</span>. So the definition of target is saying that its terms are of the form <span class="math inline">\operatorname{\mathrm{ally}}(p, x)</span> or <span class="math inline">\operatorname{\mathrm{enemy}}(p,x)</span>, just like we previously enumerated the terms of finite types.</p>
<p>This point of view allows us to define functions on compound types by enumerating what it does on the different constructors, a method called <em>pattern matching</em>. For example, the function <span class="math inline">\operatorname{\mathrm{not}} \colon \mathtt{Bool}\to \mathtt{Bool}</span> is defined as <span class="math display"> \begin{aligned}
    &amp;\operatorname{\mathrm{not}} \mathop{\mathrm{true}}&amp;=&amp;\; \mathop{\mathrm{false}}&amp; \\
    &amp;\operatorname{\mathrm{not}} \mathop{\mathrm{false}}&amp;=&amp;\;\mathop{\mathrm{true}}.&amp;
\end{aligned}</span> While our ally-aware cannon shooting function may be defined as something like <span class="math display"> \begin{aligned}
    &amp;\operatorname{\mathrm{shoot}}(\operatorname{\mathrm{enemy}}(p, y)) &amp;=&amp;\; \mathtt{laser\_blast}(p) \\
    &amp;\operatorname{\mathrm{shoot}}(\operatorname{\mathrm{ally}}(p, x)) &amp;=&amp;\; \mathtt{wave\_your\_hand}(p).
\end{aligned}</span> Taking advantage of the type system via pattern matching is a nice way to make it obvious that our code does what it should. In this case, the types don’t allow us to obliterate our friends.</p>
<p>Although these compound types are nice to organize our data, the true power of types comes from taking advantage of two other constructions: <em>function types</em> and <em>fixed point types</em>. The function type between two types <span class="math inline">A</span> and <span class="math inline">B</span>, represents all the functions receiving an input of type <span class="math inline">A</span> and returning an argument of type <span class="math inline">B</span>. To mimic the usual notation for type signatures, this function type is denoted as <span class="math inline">A \to B</span>. A type system with function types allows us to define higher-order functions. For example, given a function <span class="math inline">\phi \colon A \to B</span>, the composition operator <span class="math inline">K_\phi</span> defined as <span class="math display"> K_\phi f = f \circ \phi</span> has type signature <span class="math inline">K_\phi \colon (B \to C) \to (A \to C)</span>. It takes a function and turns it into another one. This was a simple example but be sure that many more will soon come. Higher-order functions are at the heart of recursion schemes.</p>
<p>Now we arrive at the last kind of compound type we are going to discuss today: fixed point types. These are the star of today’s show, so pay attention. We may define a compound data type that is parameterized by some variable (a function between types, if you prefer) such as <span class="math display">\mathop{\mathrm{\mathtt{maybe}}}A \coloneqq \operatorname{\mathrm{nothing}} \mid \operatorname{\mathrm{just}} A.</span> Given a type <span class="math inline">A</span>, a term of type <span class="math inline">\mathop{\mathrm{\mathtt{maybe}}}A</span> is either <span class="math inline">\operatorname{\mathrm{nothing}}</span> or the constructor <span class="math inline">\operatorname{\mathrm{just}}</span> applied to a term of type <span class="math inline">A</span>. Thus, <span class="math inline">\mathop{\mathrm{\mathtt{maybe}}}</span> receives a type and augments it with a special point<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>Given a type operator <span class="math inline">F</span>, a fixed point of <span class="math inline">F</span> is a type <span class="math inline">X</span> satisfying <span class="math display">X \simeq FX.</span> In here, we use the isomorphism sign <span class="math inline">\simeq</span> instead of equality because there is some boilerplate involved regarding tags. Although this is a simple construction, the concept is extremely powerful, being directly connected to recursion.</p>
<p>As an example let’s explore the fixed point of <span class="math inline">\mathop{\mathrm{\mathtt{maybe}}}</span>. It is a type <span class="math inline">N</span> satisfying <span class="math display">N \simeq \mathop{\mathrm{\mathtt{maybe}}}N = \operatorname{\mathrm{nothing}} \mid \operatorname{\mathrm{just}} N.</span> This means that any term of <span class="math inline">N</span> is either <span class="math inline">\operatorname{\mathrm{nothing}}</span> or <span class="math inline">\operatorname{\mathrm{just}}</span> a term of <span class="math inline">N</span>. Since we know <span class="math inline">\operatorname{\mathrm{nothing}}</span>, we can construct a new term <span class="math inline">\operatorname{\mathrm{just}}(\operatorname{\mathrm{nothing}})</span>, then <span class="math inline">\operatorname{\mathrm{just}}(\operatorname{\mathrm{just}}(\operatorname{\mathrm{nothing}}))</span>, and proceed successively in this way. Thus for any natural number <span class="math inline">n</span>, applying <span class="math inline">\operatorname{\mathrm{just}}</span> to <span class="math inline">\operatorname{\mathrm{nothing}}</span> <span class="math inline">n</span> times defines a unique term of <span class="math inline">N</span>. Moreover, the definition of <span class="math inline">N</span> says that all of its terms are of this form, meaning that <span class="math inline">N</span> is isomorphic to the natural numbers<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>If you find this last result strange, remember that the natural numbers are inductively defined as being either zero or the successor of another natural number. Using our notation for types, this is equivalent to saying <span class="math display">\mathbb{N}= \operatorname{\mathrm{zero}} \mid \operatorname{\mathrm{succ}} \mathbb{N}.</span> If we alter the tag names, this tells us that <span class="math inline">\mathbb{N}</span> is a fixed point of <span class="math inline">\mathop{\mathrm{\mathtt{maybe}}}</span> as expected.</p>
<h3 id="sec:lists">An example with lists</h3>
<p>The natural numbers are surely the most famous example of an inductive type. Nevertheless, almost no one thing of them like that while programming. Treating <span class="math inline">3</span> as <span class="math inline">\operatorname{\mathrm{succ}}(\operatorname{\mathrm{succ}}(\operatorname{\mathrm{succ}}(\operatorname{\mathrm{zero}})))</span> would be cumbersome, to say the least. Any language comes with a (possibly signed) integer type already bundled with the usual arithmetic operations defined for it. Thus, let’s discuss a little bit about another inductive type that is also pretty famous but has more of a inductive data structure flavour to it: the <em>linked list</em>.</p>
<p>Let <span class="math inline">A</span> be your favorite type. Intuitively, a list over <span class="math inline">A</span> is a finite-length sequence of elements of <span class="math inline">A</span>. The simplest case possible is an empty list. To represent a non-empty list, we notice that any non-empty list with <span class="math inline">n</span> elements may be “factorized” into its first element and another list with the remaining <span class="math inline">n-1</span> elements.</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzM3NS4xMzk4cHQnIGhlaWdodD0nMjYuNjI1MTJwdCcgdmlld0JveD0nLTE0NC4wMDAxIC0xNDQuMDAwMDYgMzc1LjEzOTggMjYuNjI1MTInPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnJtLWxtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFYNEFBMEFBQUFBQjRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJvQUFBQWNpeVBmL1U5VEx6SUFBQUZNQUFBQVFnQUFBRlpWbFY2N1kyMWhjQUFBQVpBQUFBQlRBQUFCVWdCVkRrZGpkblFnQUFBQjVBQUFBQVFBQUFBRUFDRUNlV2RoYzNBQUFBSG9BQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBZkFBQUFLTkFBQUN5Sjdic0ZKb1pXRmtBQUFFZ0FBQUFESUFBQUEyR0pKRTFtaG9aV0VBQUFTMEFBQUFIZ0FBQUNRRTVRSGphRzEwZUFBQUJOUUFBQUFZQUFBQUdBWnRBS1JzYjJOaEFBQUU3QUFBQUJJQUFBQVNBdUFCK20xaGVIQUFBQVVBQUFBQUh3QUFBQ0FBVUFCdmJtRnRaUUFBQlNBQUFBQzNBQUFCS1I5TU01RndiM04wQUFBRjJBQUFBQjRBQUFBeUFGRUFNWGphWTJCZ1lHUUFnc3ZiN3MwQTBiZTNOV3lDMFFCY2Z3aUhBQUI0Mm1OZ1pQekNPSUdCbFlHQnFaTnBOd01EUXplRVpyelBZTWpJQkJSbFlPVmtnQUZHQmlRUWtPYWFBcVFNR0N5WXBmK2JNRVF4TFdFUWc2a0JBT3FzQ2Z3QUFIamEzWXRiRGtBd0VFWFBhSlZGV0VSOUNJdXdkeElMdXFZbEVyRURaekwzOFhHQndQVURSbUgxWnJWSHNudnYxN2lQVEN5U3AreHBsblJvMTNhdktwWjRxcFZOd3h2alE0Z3VMYW5qSDV6U3hBdWpBQUFoQW5rQUFBQUIvLzhBQW5qYUxaSE5TeFJ4SE1hL3Y1bDFabmRtZDNWMjU4V1hmWEYzM0oxMTFGWG5kYlZ4WHhUWEphTm1YUVhUVkNTS2lEQ0pJa3NobEtCRGg2S0l3SU1YTzNSMS80QkFJa0dRdW5ib0trSFFxVnVrOVJ2b05qeno0L2srbitjQkFsSUFxSmZZQlJKb3lCOGdHSFNhdEE5K2FnZFV5emVuU1JMNEV3NUlUMjd4NUNaTm9UOU9FM202enFVNFJlZmtGUEovUHpvaWRzOXVwb2g1QUI4b2YzK2dFK3daZ1NqMGdvb3ZHRXFla05NMEpmQlNBdW1hYlprS1Q0ZVJuTTRxV2RPd2k2U3VpWklvb0pPY01HbDFQall5QS9IRmdRMHIwMkNaaVZ4bUlzajY2V1F1RnBLcklRYVYzOHoxVytHSDd1dTlocDIvNzc0S3ZpaFhuRUxGZWJ0anFRWFJiMVFLejRHQXEvanFQczRnZ2dTUU12RWxrek95TWlVTG1zM3hWQjhTTEUxQys5M2xPTVVWTjY0WWlWSzNmQzRuSXdsaU9PSXZKenZQZmljaVNaSUV3RjRhNWpuRVhnNk1BV1N3UzVvMlJWMHJrcWJoUWNucFFaUVdPRjcwd0hRTmMvQ2VtRld3WUhtdncwandmbG9tT2x4enA0MCtWUzczcDlzWXNxVmNxNWFDakkraHFhSDZTQ3pTbnBzdzZ5R0tsYnE2SkNiSzMzRG5kNDRYdHZXUG9XZ3NJZmxZTWg0ajI4Ky90cktCYWxtZFhWRXI0M2tpbm90VG5jTGt2ZTFsbkxPQWM1NFM3NkFMWXBoZVR1ZVJJdE82WlZzWEVPMWwwTWFRWVZzbGhJT2MvaG9kWWNpT1ZFY3JReTkrV1M4NTE5aG8zN01BOFRUQUJqL1BCS2k5bFUrenRxMHZYTHpyZkFoS1FJR0t2WTl4QnhLMGd3dzlvSUh1ZGFGa0ZjdjBHTDFwUlluNkQwcnl0RGNzYmtNVW9yeFhCbDVaU3BBQ09oNk91by91MUtadjk3UEZsMXVOdWMycDYxdGEzUzdVaGVWU1plbkJaaHNYQzcrZnRBU3R1RFRlV0syT0RRZlYydnFsMVRVWExjMk11cW1oZ2RFcDgveUpWV3NVYjFVdXM2RjRqNEFuK2dkQVFwQVFBQUFBZU5wallHUmdZQUJpZGdhbmlmSDhObDhadUptZkEwVVlibTlyMkFTbkZmKy9ZbnpLdEFUSTVXQmdBb2tDQUVMWURKY0FBSGphWTJCa1lHQmE4djhWUXhUakZ3WWdZSHpLd01pQUNsZ0FmMXNFeXdBQUFmUUFJUUFBQUFBQjlBQUFBZlFBSndCWkFESUFPQUFxQUFBQUtnQXFBQ29BYkFDU0FPWUJGQUZrQUFCNDJtTmdaR0JnNEdDd1kyQmpBQUVtSUdaa0FJazVNT2lCQkFBS2p3REFBSGphWFkwN0RzSXdESVkvSGtXOEJzVEFuSVV4VlpLeEIrakFBVHF5bGFwU0gxTGFJM0FNRHNBWk9CMXVDQkxDa3VYUDltLy93Sm9iTTZhWWs3Q1B2T0RNTlhMQ2prZmtsZWhmc3AwdE42TGZCdVhFQ3k0Y0l5ZWN1RWRlY2VCSlE0dkhZcUJwdlpXUzA5TXhodXFwS0ZFNFVsRW9Na2t2Ri9ybjdqTjF3anIwV3RpRUpPKzdNZTk5VlNxWEdwVXAzK3BnSXVpc3RrWTc0MFJXaUlkbm9BN09TcjVNYmhTbEgrcStVemFWNXQrVjd5L2UrdlVvRGdCNDJtTmdZa0FHakF6b2dBTXN5c1FnekNEQ0lNRWd4U0FOQUFONkFJTUFBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OnJtLWxtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnIHRyYW5zZm9ybT0nc2NhbGUoMiAyKSc+CjxwYXRoIGQ9J00tNzEuODAwOC01OC44ODY3MkgtNDMuODY3MlYtNzEuODAwNzhILTcxLjgwMDhaTS01NC45OTYwOS03MS44MDA3OFYtNTguODg2NzInIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU3LjgzNDQwNicgeT0nLTY1LjM0MzM3MicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEwLjY0NTkgMy4xMzY5KSc+MTA8L3RleHQ+CjxwYXRoIGQ9J00tMTUuMTIxMS01OC44ODY3MkgxNy43OTNWLTcxLjgwMDc4SC0xNS4xMjExWk02LjY2MDItNzEuODAwNzhWLTU4Ljg4NjcyJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Ny44MzQ0MDYnIHk9Jy02NS4zNDMzNzInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjAzMjQgMy4xMzY5KSc+MTUwPC90ZXh0Pgo8cGF0aCBkPSdNNDYuNTM4Ni01OC44ODY3Mkg3NC40Njg2Vi03MS44MDA3OEg0Ni41Mzg2Wk02My4zMzk2LTcxLjgwMDc4Vi01OC44ODY3Micgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTcuODM0NDA2JyB5PSctNjUuMzQzMzcyJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDcuNjkyMSAzLjEzNjkpJz44NzwvdGV4dD4KPGcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnPgo8cGF0aCBkPSdNMTAzLjIxNDYtNTkuMzY3MTlIMTE1LjE3MTZWLTcxLjMyMDMxSDEwMy4yMTQ2WicvPgo8cGF0aCBkPSdNMTE1LjM3MDYtNzEuNTE5NTNMMTAzLjAxNTYtNTkuMTY3OTcnLz4KPHBhdGggZD0nTS00OC4wMTk1My02NS4zNDM3NTFILTE3LjMxMjUnLz4KPC9nPgo8cGF0aCBkPSdNLTUxLjI3NzM2LTY1LjM0Mzc1MUMtNTEuMjc3MzYtNjQuNDQ1MzEzLTUwLjU1MDgtNjMuNzE0ODQtNDkuNjQ4NDYtNjMuNzE0ODRDLTQ4Ljc1MDAxOS02My43MTQ4NC00OC4wMTk1NTEtNjQuNDQ1MzEzLTQ4LjAxOTU1MS02NS4zNDM3NTFDLTQ4LjAxOTU1MS02Ni4yNDIxODgtNDguNzUwMDE5LTY2Ljk3MjY2LTQ5LjY0ODQ2LTY2Ljk3MjY2Qy01MC41NTA4LTY2Ljk3MjY2LTUxLjI3NzM2LTY2LjI0MjE4OC01MS4yNzczNi02NS4zNDM3NTFaJy8+CjxwYXRoIGQ9J00tNTEuMjc3MzYtNjUuMzQzNzUxQy01MS4yNzczNi02NC40NDUzMTMtNTAuNTUwOC02My43MTQ4NC00OS42NDg0Ni02My43MTQ4NEMtNDguNzUwMDE5LTYzLjcxNDg0LTQ4LjAxOTU1MS02NC40NDUzMTMtNDguMDE5NTUxLTY1LjM0Mzc1MUMtNDguMDE5NTUxLTY2LjI0MjE4OC00OC43NTAwMTktNjYuOTcyNjYtNDkuNjQ4NDYtNjYuOTcyNjZDLTUwLjU1MDgtNjYuOTcyNjYtNTEuMjc3MzYtNjYuMjQyMTg4LTUxLjI3NzM2LTY1LjM0Mzc1MVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMTUuMzIwMjgtNjUuMzQzNzUxTC0xOC41MTE2OS02Ni45Mzc1TC0xNy4zMTI0NjktNjUuMzQzNzUxTC0xOC41MTE2OS02My43NScvPgo8cGF0aCBkPSdNMTMuNjQwNi02NS4zNDM3NTFINDQuMzQzNicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTEwLjM4MjgzLTY1LjM0Mzc1MUMxMC4zODI4My02NC40NDUzMTMgMTEuMTA5MzktNjMuNzE0ODQgMTIuMDExNzQtNjMuNzE0ODRDMTIuOTEwMTc0LTYzLjcxNDg0IDEzLjY0MDY0Mi02NC40NDUzMTMgMTMuNjQwNjQyLTY1LjM0Mzc1MUMxMy42NDA2NDItNjYuMjQyMTg4IDEyLjkxMDE3NC02Ni45NzI2NiAxMi4wMTE3NC02Ni45NzI2NkMxMS4xMDkzOS02Ni45NzI2NiAxMC4zODI4My02Ni4yNDIxODggMTAuMzgyODMtNjUuMzQzNzUxWicvPgo8cGF0aCBkPSdNMTAuMzgyODMtNjUuMzQzNzUxQzEwLjM4MjgzLTY0LjQ0NTMxMyAxMS4xMDkzOS02My43MTQ4NCAxMi4wMTE3NC02My43MTQ4NEMxMi45MTAxNzQtNjMuNzE0ODQgMTMuNjQwNjQyLTY0LjQ0NTMxMyAxMy42NDA2NDItNjUuMzQzNzUxQzEzLjY0MDY0Mi02Ni4yNDIxODggMTIuOTEwMTc0LTY2Ljk3MjY2IDEyLjAxMTc0LTY2Ljk3MjY2QzExLjEwOTM5LTY2Ljk3MjY2IDEwLjM4MjgzLTY2LjI0MjE4OCAxMC4zODI4My02NS4zNDM3NTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNNDYuMzM5ODMtNjUuMzQzNzUxTDQzLjE0ODQzLTY2LjkzNzVMNDQuMzQzNzQxLTY1LjM0Mzc1MUw0My4xNDg0My02My43NScvPgo8cGF0aCBkPSdNNzAuMzE2Ni02NS4zNDM3NTFIMTAxLjAyMzYnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J002Ny4wNTg2NC02NS4zNDM3NTFDNjcuMDU4NjQtNjQuNDQ1MzEzIDY3Ljc4OTExLTYzLjcxNDg0IDY4LjY4NzU1LTYzLjcxNDg0QzY5LjU4OTg5LTYzLjcxNDg0IDcwLjMxNjQ1Mi02NC40NDUzMTMgNzAuMzE2NDUyLTY1LjM0Mzc1MUM3MC4zMTY0NTItNjYuMjQyMTg4IDY5LjU4OTg5LTY2Ljk3MjY2IDY4LjY4NzU1LTY2Ljk3MjY2QzY3Ljc4OTExLTY2Ljk3MjY2IDY3LjA1ODY0LTY2LjI0MjE4OCA2Ny4wNTg2NC02NS4zNDM3NTFaJy8+CjxwYXRoIGQ9J002Ny4wNTg2NC02NS4zNDM3NTFDNjcuMDU4NjQtNjQuNDQ1MzEzIDY3Ljc4OTExLTYzLjcxNDg0IDY4LjY4NzU1LTYzLjcxNDg0QzY5LjU4OTg5LTYzLjcxNDg0IDcwLjMxNjQ1Mi02NC40NDUzMTMgNzAuMzE2NDUyLTY1LjM0Mzc1MUM3MC4zMTY0NTItNjYuMjQyMTg4IDY5LjU4OTg5LTY2Ljk3MjY2IDY4LjY4NzU1LTY2Ljk3MjY2QzY3Ljc4OTExLTY2Ljk3MjY2IDY3LjA1ODY0LTY2LjI0MjE4OCA2Ny4wNTg2NC02NS4zNDM3NTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMTAzLjAxNTg0LTY1LjM0Mzc1MUw5OS44MjgzNC02Ni45Mzc1TDEwMS4wMjM2NDktNjUuMzQzNzUxTDk5LjgyODM0LTYzLjc1Jy8+CjwvZz4KPC9zdmc+" /></p>
<p>Thus, by defining a type operator <span class="math inline">P</span> as <span class="math display">P X \coloneqq \operatorname{\mathrm{nil}}\mid \operatorname{\mathrm{cons}}\, A \times X,</span> the previous discussion shows that the type of lists over <span class="math inline">A</span>, hereby denoted <span class="math inline">L(A)</span>, is a fixed point of <span class="math inline">P</span>, <span class="math display">L(A) \simeq \operatorname{\mathrm{nil}}\mid \operatorname{\mathrm{cons}}\, A \times L(A).</span> Here, the constructor <span class="math inline">\operatorname{\mathrm{nil}}</span> takes the role of the empty list while the constructor <span class="math inline">\operatorname{\mathrm{cons}}</span> represents a pair containing an element of <span class="math inline">A</span> and another list.</p>
<p>This inductive definition of lists allows us to recursively define operations over it. For example, let’s construct a function that sums all the elements in a list of integers. Its signature is <span class="math inline">\operatorname{\mathrm{sum}} \colon L(\mathbb{Z}) \to \mathbb{Z}</span>. If the list is empty, the sum returns zero. Otherwise, it takes the first element and adds it to the sum of what remains, <span class="math display"> \begin{aligned}
\operatorname{\mathrm{sum}}(\operatorname{\mathrm{nil}}) &amp;= 0, \\
\operatorname{\mathrm{sum}}(\operatorname{\mathrm{cons}}(x, l)) &amp;= x + \operatorname{\mathrm{sum}}(l).
\end{aligned}</span> This last definition conceals an extremely useful pattern. It is the programming analogue of a proof by induction over the list. The empty list is the base case, which we set to zero. On a list of length <span class="math inline">n&gt;0</span>, we assume that we’ve already solved the computation for the sublist of length <span class="math inline">n-1</span> and them add it to the remaining element. Just like an inductive proof, see?</p>
<p>As it stands, you would be right to guess that constructing functions in this way is so pervasive in programming as proofs by induction are in mathematics. A simple variation of <span class="math inline">\operatorname{\mathrm{sum}}</span> would be a function that multiplies a list of real numbers, <span class="math inline">\operatorname{\mathrm{prod}} \colon L(\mathbb{R}) \to \mathbb{R}</span>. To construct it, all we need to do is take the definition of <span class="math inline">\operatorname{\mathrm{sum}}</span>, replace <span class="math inline">0</span> by <span class="math inline">1</span>, replace addition by multiplication, and it is all done! <span class="math display"> \begin{aligned}
\operatorname{\mathrm{prod}}(\operatorname{\mathrm{nil}}) &amp;= 1, \\
\operatorname{\mathrm{prod}}(\operatorname{\mathrm{cons}}(x, l)) &amp;= x \cdot \operatorname{\mathrm{prod}}(l).
\end{aligned}</span> As expected, this pattern appears every time we want to somehow combine the elements of a list into a single value. It is so common that people have abstracted it on a function called <span class="math inline">\operatorname{\mathrm{reduce}}</span><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Its type signature is <span class="math display">\operatorname{\mathrm{reduce}} \colon B \times (A \times B \to B) \to (L(A) \to B).</span> Pretty scary, right? Let’s break it down to see how it is just good ol’ induction. When reducing a list of type <span class="math inline">L(A)</span> into a value of type <span class="math inline">B</span>, there are two situations we may encounter. In the base case the list is empty, and we must specify a value of type <span class="math inline">B</span> to be returned. In the other steps, we consider that we already know the solution for the sublist of length <span class="math inline">n-1</span>, which yields a value of type <span class="math inline">B</span>, and then need a rule to combine this value of the remaining term of type <span class="math inline">A</span> into another term of type <span class="math inline">B</span>. Thus, <span class="math inline">\operatorname{\mathrm{reduce}}</span> is an instance of what we call a <em>higher-order function</em>. It is a machine that takes an initial value and a binary function and outputs another function, now defined on lists. We call it higher-order because it doesn’t work with ordinary data, no, it transforms simple functions into recursive ones! Considering what it does, its definition is actually rather simple. The result <span class="math inline">h = \operatorname{\mathrm{reduce}}(v,g)</span> is the function that does <span class="math display"> \begin{aligned}
h(\operatorname{\mathrm{nil}}) &amp;= v, \\
h(\operatorname{\mathrm{cons}}(x,l)) &amp;= g(x,h(l)).
\end{aligned}</span> Take a moment to absorb this definition, there really is a lot encapsulated on this. First substitute <span class="math inline">v</span> by <span class="math inline">0</span> and <span class="math inline">g</span> by <span class="math inline">+</span> to see that it becomes <span class="math inline">\operatorname{\mathrm{sum}}</span>. Then, substitute <span class="math inline">v</span> by <span class="math inline">1</span> and <span class="math inline">g</span> by <span class="math inline">\cdot</span> to see that it becomes <span class="math inline">\operatorname{\mathrm{prod}}</span>. Finally, congratulate yourself because you just understood your first recursion scheme!</p>
<p>If the way <span class="math inline">\operatorname{\mathrm{reduce}}</span> was introduced made you think that it is only used to collapse a list into a primitive type, you should know that it is much more ubiquitous than that. Two of the most used list-manipulating functions in functional programming are <span class="math inline">\operatorname{\mathrm{map}}</span> and <span class="math inline">\operatorname{\mathrm{filter}}</span>. And, guess what, both are implementable in terms of <span class="math inline">\operatorname{\mathrm{reduce}}</span>. The first, <span class="math inline">\operatorname{\mathrm{map}}</span>, takes a function <span class="math inline">f \colon A \to B</span> and turns it into another function that applies <span class="math inline">f</span> elementwisely to a list. Its type signature for <span class="math inline">\operatorname{\mathrm{map}}</span> is therefore <span class="math display"> \operatorname{\mathrm{map}} \colon (A \to B) \to (L(A) \to L(B)).</span> On the empty list, <span class="math inline">\operatorname{\mathrm{map}}(f)</span> does nothing since it has no elements. On a <span class="math inline">\operatorname{\mathrm{cons}}</span> node, it should apply <span class="math inline">f</span> to the element stored on it and then proceed to apply <span class="math inline">f</span> to the list’s tail. Thus, the definition of <span class="math inline">\operatorname{\mathrm{map}}</span> in terms of <span class="math inline">\operatorname{\mathrm{reduce}}</span> is <span class="math display"> \begin{aligned}
g(x, l) &amp;= \operatorname{\mathrm{cons}}(f(x), l), \\
\operatorname{\mathrm{map}}(f) &amp;= \operatorname{\mathrm{reduce}}(\operatorname{\mathrm{nil}}, g).
\end{aligned} </span> If it is hard to wrap your head around this last definition, try doing it step by step with a simple function such as <span class="math inline">x^2</span> and a small list such as <span class="math inline">(1,2,3,4)</span>. I promise you it will be enlightening.</p>
<p>The <span class="math inline">\operatorname{\mathrm{filter}}</span> function takes a predicate, represented as <span class="math inline">p \colon A \to \mathtt{Bool}</span>, and outputs a function that filters a list. That is removes all elements of the list for which <span class="math inline">p</span> is false. Its type signature is thus <span class="math display"> \operatorname{\mathrm{filter}} \colon (A \to \mathtt{Bool}) \to (L(A) \to L(A)).</span> Since the empty list has no elements, there is nothing to do in this case. In a <span class="math inline">\operatorname{\mathrm{cons}}(x,l)</span>, we should return it exactly if <span class="math inline">p(x)</span> is true and return just <span class="math inline">l</span> otherwise. We can assembly this in terms of <span class="math inline">\operatorname{\mathrm{reduce}}</span> as <span class="math display"> \begin{aligned}
h(x, l) &amp;= \begin{cases}
    \operatorname{\mathrm{cons}}(x,l),&amp; \text{if } p(x) = \mathop{\mathrm{true}}\\
    l,&amp; \text{if } p(x) = \mathop{\mathrm{false}}
\end{cases}\\
\operatorname{\mathrm{reduce}}(f) &amp;= \operatorname{\mathrm{reduce}}(\operatorname{\mathrm{nil}}, h).
\end{aligned}</span></p>
<p>I hope you liked these examples because the next step in our journey is generalizing <span class="math inline">\operatorname{\mathrm{reduce}}</span> to any inductive data type! To achieve this, we must pass through the land of category theory.</p>
<h2 id="sec:categories">A walk through the land of categories</h2>
<p>While the previous sections dealt more with programming, this one leans more to the mathematical side. But be assured that the fruits of all this abstraction will pay well.</p>
<p>A nice thing about types and functions between them is that they form a <em>category</em>.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> In fact, with all the structure we defined, they have the much more powerful structure of a <a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">Cartesian closed category</a>. But we aren’t going to use this last part today. If you happen to not know what a category is, I’m afraid I can’t properly introduce them in here.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> But I will go through the basics for the sake of completeness.</p>
<p>A category <span class="math inline">\mathcal{C}</span> may be imagined as a special kind of graph. There is a collection of vertices, called its <em>objects</em> and between each pair of vertices there is a collection of <em>directed edges</em>, called <em>arrows</em> or <em>morphisms</em>. The <span class="math inline">A</span> and <span class="math inline">B</span> are objects, the notation for an arrow <span class="math inline">r</span> from <span class="math inline">A</span> to <span class="math inline">B</span> is the same as for functions, <span class="math inline">r \colon A \to B</span>. Soon we will see why. What differentiates a category from a simple directed graph is that we have a notion of <em>composition</em> between the arrows. That is, if <span class="math inline">f \colon A \to B</span> and <span class="math inline">g \colon B \to C</span>, there always exists another arrow <span class="math inline">g \circ f \colon A \to C</span>. You may think of arrows as representing paths and <span class="math inline">g \circ f</span> as the arrow path going through <span class="math inline">f</span> and then through <span class="math inline">g</span>.</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzQzMi45NzU5NnB0JyBoZWlnaHQ9JzM4Ni45MzgycHQnIHZpZXdCb3g9Jy0xNDQuMDAwMDYgLTE0NC4wMDAwNzggNDMyLjk3NTk2IDM4Ni45MzgyJz4KPGcgaWQ9J3BhZ2UxJyB0cmFuc2Zvcm09J3NjYWxlKDIgMiknPgo8cGF0aCBkPSdNLTY4LjMxMjUgLjgwODU5NEMtNjguMzEyNS0uMTUyMzQ0LTY5LjA5Mzc1My0uOTMzNTg5LTcwLjA1ODU5Ny0uOTMzNTg5Qy03MS4wMTk1MzQtLjkzMzU4OS03MS44MDA3OC0uMTUyMzQ0LTcxLjgwMDc4IC44MDg1OTRDLTcxLjgwMDc4IDEuNzczNDM3LTcxLjAxOTUzNCAyLjU1MDc4MS03MC4wNTg1OTcgMi41NTA3ODFDLTY5LjA5Mzc1MyAyLjU1MDc4MS02OC4zMTI1IDEuNzczNDM3LTY4LjMxMjUgLjgwODU5NFonIGZpbGw9JyNiM2ZmYjMnLz4KPHBhdGggZD0nTS02OC4zMTI1IC44MDg1OTRDLTY4LjMxMjUtLjE1MjM0NC02OS4wOTM3NTMtLjkzMzU4OS03MC4wNTg1OTctLjkzMzU4OUMtNzEuMDE5NTM0LS45MzM1ODktNzEuODAwNzgtLjE1MjM0NC03MS44MDA3OCAuODA4NTk0Qy03MS44MDA3OCAxLjc3MzQzNy03MS4wMTk1MzQgMi41NTA3ODEtNzAuMDU4NTk3IDIuNTUwNzgxQy02OS4wOTM3NTMgMi41NTA3ODEtNjguMzEyNSAxLjc3MzQzNy02OC4zMTI1IC44MDg1OTRaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMi41NTQ3IDcxLjY3NTgxMUMyLjU1NDcgNzAuNzE0ODExIDEuNzczNCA2OS45MzM2MTEgLjgwODYgNjkuOTMzNjExQy0uMTUyMyA2OS45MzM2MTEtLjkzMzYgNzAuNzE0ODExLS45MzM2IDcxLjY3NTgxMUMtLjkzMzYgNzIuNjQwNjExLS4xNTIzIDczLjQxODAxMSAuODA4NiA3My40MTgwMTFDMS43NzM0IDczLjQxODAxMSAyLjU1NDcgNzIuNjQwNjExIDIuNTU0NyA3MS42NzU4MTFaJyBmaWxsPScjZmZiZjgwJy8+CjxwYXRoIGQ9J00yLjU1NDcgNzEuNjc1ODExQzIuNTU0NyA3MC43MTQ4MTEgMS43NzM0IDY5LjkzMzYxMSAuODA4NiA2OS45MzM2MTFDLS4xNTIzIDY5LjkzMzYxMS0uOTMzNiA3MC43MTQ4MTEtLjkzMzYgNzEuNjc1ODExQy0uOTMzNiA3Mi42NDA2MTEtLjE1MjMgNzMuNDE4MDExIC44MDg2IDczLjQxODAxMUMxLjc3MzQgNzMuNDE4MDExIDIuNTU0NyA3Mi42NDA2MTEgMi41NTQ3IDcxLjY3NTgxMVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00zNy45ODg3LTcwLjA1ODU4OUMzNy45ODg3LTcxLjAxOTQ4OSAzNy4yMDY3LTcxLjgwMDc4OSAzNi4yNDE3LTcxLjgwMDc4OUMzNS4yODE3LTcxLjgwMDc4OSAzNC40OTk3LTcxLjAxOTQ4OSAzNC40OTk3LTcwLjA1ODU4OUMzNC40OTk3LTY5LjA5Mzc4OSAzNS4yODE3LTY4LjMxNjM4OSAzNi4yNDE3LTY4LjMxNjM4OUMzNy4yMDY3LTY4LjMxNjM4OSAzNy45ODg3LTY5LjA5Mzc4OSAzNy45ODg3LTcwLjA1ODU4OVonIGZpbGw9JyMwMGIzMDAnLz4KPHBhdGggZD0nTTM3Ljk4ODctNzAuMDU4NTg5QzM3Ljk4ODctNzEuMDE5NDg5IDM3LjIwNjctNzEuODAwNzg5IDM2LjI0MTctNzEuODAwNzg5QzM1LjI4MTctNzEuODAwNzg5IDM0LjQ5OTctNzEuMDE5NDg5IDM0LjQ5OTctNzAuMDU4NTg5QzM0LjQ5OTctNjkuMDkzNzg5IDM1LjI4MTctNjguMzE2Mzg5IDM2LjI0MTctNjguMzE2Mzg5QzM3LjIwNjctNjguMzE2Mzg5IDM3Ljk4ODctNjkuMDkzNzg5IDM3Ljk4ODctNzAuMDU4NTg5Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTEwOC44NTU3LTQxLjcxMDg4OUMxMDguODU1Ny00Mi42NzU3ODkgMTA4LjA3NDctNDMuNDU2OTg5IDEwNy4xMDk3LTQzLjQ1Njk4OUMxMDYuMTQ4Ny00My40NTY5ODkgMTA1LjM2NjctNDIuNjc1Nzg5IDEwNS4zNjY3LTQxLjcxMDg4OUMxMDUuMzY2Ny00MC43NDk5ODkgMTA2LjE0ODctMzkuOTY4Nzg5IDEwNy4xMDk3LTM5Ljk2ODc4OUMxMDguMDc0Ny0zOS45Njg3ODkgMTA4Ljg1NTctNDAuNzQ5OTg5IDEwOC44NTU3LTQxLjcxMDg4OVonIGZpbGw9JyNhNjgwZDknLz4KPHBhdGggZD0nTTEwOC44NTU3LTQxLjcxMDg4OUMxMDguODU1Ny00Mi42NzU3ODkgMTA4LjA3NDctNDMuNDU2OTg5IDEwNy4xMDk3LTQzLjQ1Njk4OUMxMDYuMTQ4Ny00My40NTY5ODkgMTA1LjM2NjctNDIuNjc1Nzg5IDEwNS4zNjY3LTQxLjcxMDg4OUMxMDUuMzY2Ny00MC43NDk5ODkgMTA2LjE0ODctMzkuOTY4Nzg5IDEwNy4xMDk3LTM5Ljk2ODc4OUMxMDguMDc0Ny0zOS45Njg3ODkgMTA4Ljg1NTctNDAuNzQ5OTg5IDEwOC44NTU3LTQxLjcxMDg4OVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J005NC42Nzk3IDM2LjI0MjIxMUM5NC42Nzk3IDM1LjI4MTIxMSA5My44OTg3IDM0LjUwMDAxMSA5Mi45Mzc3IDM0LjUwMDAxMUM5MS45NzI3IDM0LjUwMDAxMSA5MS4xOTU3IDM1LjI4MTIxMSA5MS4xOTU3IDM2LjI0MjIxMUM5MS4xOTU3IDM3LjIwNzAxMSA5MS45NzI3IDM3Ljk4NDQxMSA5Mi45Mzc3IDM3Ljk4NDQxMUM5My44OTg3IDM3Ljk4NDQxMSA5NC42Nzk3IDM3LjIwNzAxMSA5NC42Nzk3IDM2LjI0MjIxMVonIGZpbGw9JyNkMjRkNzknLz4KPHBhdGggZD0nTTk0LjY3OTcgMzYuMjQyMjExQzk0LjY3OTcgMzUuMjgxMjExIDkzLjg5ODcgMzQuNTAwMDExIDkyLjkzNzcgMzQuNTAwMDExQzkxLjk3MjcgMzQuNTAwMDExIDkxLjE5NTcgMzUuMjgxMjExIDkxLjE5NTcgMzYuMjQyMjExQzkxLjE5NTcgMzcuMjA3MDExIDkxLjk3MjcgMzcuOTg0NDExIDkyLjkzNzcgMzcuOTg0NDExQzkzLjg5ODcgMzcuOTg0NDExIDk0LjY3OTcgMzcuMjA3MDExIDk0LjY3OTcgMzYuMjQyMjExWicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTE0NC4yODg3LTU1Ljg4NjY4OUMxNDQuMjg4Ny01Ni44NDc2ODkgMTQzLjUwNzctNTcuNjI4ODg5IDE0Mi41NDI3LTU3LjYyODg4OUMxNDEuNTgxNy01Ny42Mjg4ODkgMTQwLjgwMDctNTYuODQ3Njg5IDE0MC44MDA3LTU1Ljg4NjY4OUMxNDAuODAwNy01NC45MjE4ODkgMTQxLjU4MTctNTQuMTQwNTg5IDE0Mi41NDI3LTU0LjE0MDU4OUMxNDMuNTA3Ny01NC4xNDA1ODkgMTQ0LjI4ODctNTQuOTIxODg5IDE0NC4yODg3LTU1Ljg4NjY4OVonIGZpbGw9JyNlNmU2MDAnLz4KPHBhdGggZD0nTTE0NC4yODg3LTU1Ljg4NjY4OUMxNDQuMjg4Ny01Ni44NDc2ODkgMTQzLjUwNzctNTcuNjI4ODg5IDE0Mi41NDI3LTU3LjYyODg4OUMxNDEuNTgxNy01Ny42Mjg4ODkgMTQwLjgwMDctNTYuODQ3Njg5IDE0MC44MDA3LTU1Ljg4NjY4OUMxNDAuODAwNy01NC45MjE4ODkgMTQxLjU4MTctNTQuMTQwNTg5IDE0Mi41NDI3LTU0LjE0MDU4OUMxNDMuNTA3Ny01NC4xNDA1ODkgMTQ0LjI4ODctNTQuOTIxODg5IDE0NC4yODg3LTU1Ljg4NjY4OVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tNjcuODIwMzIgMy4wNDI5NzFMLTMuMzI0MiA2Ny41NDMwMTEnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMS44MTI1IDY5LjA1NDY4TC0zLjE1MjM0OCA2Ni4wOTM3NDNMLTMuMjUzOTA5IDY3LjYxMzI3MUwtNC43NzM0MzkgNjcuNzE0ODMzWicvPgo8cGF0aCBkPSdNLTEuODEyNSA2OS4wNTQ2OEwtMy4xNTIzNDggNjYuMDkzNzQzTC0zLjI1MzkwOSA2Ny42MTMyNzFMLTQuNzczNDM5IDY3LjcxNDgzM1onIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDk2JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTMuNzc3MyA3MC41NTQ3MTFMODcuNDk1NyAzOC4zNTU1MTEnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J004OS40OTIxOTEgMzcuNTg5ODEzTDg2LjI0MjE5IDM3LjYwOTM1TDg3LjU4OTg0NSAzOC4zMjAyODFMODcuMDY2NDEgMzkuNzQ5OTY2WicvPgo8cGF0aCBkPSdNODkuNDkyMTkxIDM3LjU4OTgxM0w4Ni4yNDIxOSAzNy42MDkzNUw4Ny41ODk4NDUgMzguMzIwMjgxTDg3LjA2NjQxIDM5Ljc0OTk2NlonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDknIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMzQuMDcwNy02Ny44MDA3ODlDLTIuODMyLTI5LjYzMjc4OS0xNC40NTcgMTQuMDg1OTExLS43MzgzIDY2LjA3MDMxMScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTS0uMTg3NDk4IDY4LjEwNTUyTC4xMjUwMDYgNjQuODcxMTQ0TC0uNzE4NzQ3IDY2LjEzNjc2OUwtMi4wODk4NDMgNjUuNDY4ODAzWicvPgo8cGF0aCBkPSdNLS4xODc0OTggNjguMTA1NTJMLjEyNTAwNiA2NC44NzExNDRMLS43MTg3NDcgNjYuMTM2NzY5TC0yLjA4OTg0MyA2NS40Njg4MDNaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4Nicgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00xMDcuMTMyNy0zOC41NTg1ODlDMTA2Ljk4ODctMTEuNzEwODg5IDEwNC4xNTY3IDUuMTUyMzQxIDk0Ljk4ODcgMzAuNzQ2MTExJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNOTQuMjYxNjc4IDMyLjc0OTk5Mkw5Ni4zNzQ5NjQgMzAuMjgxMjRMOTQuOTU2OTk0IDMwLjgzMjAxOUw5NC4yMTg3MDcgMjkuNDk5OTg4WicvPgo8cGF0aCBkPSdNOTQuMjYxNjc4IDMyLjc0OTk5Mkw5Ni4zNzQ5NjQgMzAuMjgxMjRMOTQuOTU2OTk0IDMwLjgzMjAxOUw5NC4yMTg3MDcgMjkuNDk5OTg4Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OTQnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMTA0LjQ2MDctNDMuMzg2Njg5QzgyLjYzMjctNTYuOTIxODg5IDY3LjQyNTctNjMuMjUzODg5IDQxLjk5OTctNjguODUxNTg5JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMzkuOTE3OTQ3LTY5LjMwNDY2NEw0Mi42NDg0MTktNjcuNTM5MDM3TDQxLjkxMDEzNS02OC44NzEwN0w0My4xMzI3OTMtNjkuNzgxMjIxWicvPgo8cGF0aCBkPSdNMzkuOTE3OTQ3LTY5LjMwNDY2NEw0Mi42NDg0MTktNjcuNTM5MDM3TDQxLjkxMDEzNS02OC44NzEwN0w0My4xMzI3OTMtNjkuNzgxMjIxWicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0ODQnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNOTYuMDg1NyAzNS43MDMxMTFDMTI0LjA3NDcgMzAuNzY1NjExIDk2LjA1NDcgNjUuNjQwNjExIDkzLjIwMjcgNDIuMTYwMTExJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNOTMuMDM5MDgxIDM5Ljk4MDQ1NUw5Mi4xMzI4MjUgNDMuMDk3NjM3TDkzLjE5OTI0MiA0Mi4wMTE2OThMOTQuNDE3OTg1IDQyLjkyMTg1NFonLz4KPHBhdGggZD0nTTkzLjAzOTA4MSAzOS45ODA0NTVMOTIuMTMyODI1IDQzLjA5NzYzN0w5My4xOTkyNDIgNDIuMDExNjk4TDk0LjQxNzk4NSA0Mi45MjE4NTRaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ3OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00xMDkuOTMzNy00MC4yMjY1ODlDMTE5LjgzNTctMzQuOTE3OTg5IDEzNC4zOTg3LTM5LjcwNjk4OSAxNDAuMzkwNy01MC40NjQ4ODknIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00xNDEuMzEyMTc4LTUyLjM5ODQ0OEwxMzguOTU2NzE1LTUwLjE1NjI2NEwxNDAuNDI1NDYzLTUwLjU2MjUxMUwxNDEuMDIzMTItNDkuMTYwMTY2WicvPgo8cGF0aCBkPSdNMTQxLjMxMjE3OC01Mi4zOTg0NDhMMTM4Ljk1NjcxNS01MC4xNTYyNjRMMTQwLjQyNTQ2My01MC41NjI1MTFMMTQxLjAyMzEyLTQ5LjE2MDE2NlonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDczJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTEwOC42NDQ3LTQ0LjUwNzc4OUMxMTMuODY2Ny01NC4yNDk5ODkgMTI1LjE0MDctNTkuNjM2Njg5IDEzNi45Mzc3LTU3LjQ2NDg4OScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTEzOS4wMjM3NzUtNTYuOTgwNTEyTDEzNi4zMTI4NDctNTguNzc3Mzg0TDEzNy4wMzU0OS01Ny40MzM2MzVMMTM1LjgwMTExOS01Ni41MzkxMDVaJy8+CjxwYXRoIGQ9J00xMzkuMDIzNzc1LTU2Ljk4MDUxMkwxMzYuMzEyODQ3LTU4Ljc3NzM4NEwxMzcuMDM1NDktNTcuNDMzNjM1TDEzNS44MDExMTktNTYuNTM5MTA1Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0ODMnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTY4LjQ1MzEzIDMuNTM1MTYxQy4wMjczIDExOS45NTI4MTEgLjgwMDggMTIxLjI2OTgxMSA4OC42NzU3IDQwLjIxNDgxMScgc3Ryb2tlPScjMDA4MDgwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTkwLjIzNDM4NSAzOC43NzczMTVMODcuMjE4NzYzIDM5Ljk5NjA2Mkw4OC43MzQzODcgNDAuMTYwMTI5TDg4Ljc3NzM1OCA0MS42ODM1NjZaJyBmaWxsPScjMDA4MDgwJy8+CjxwYXRoIGQ9J005MC4yMzQzODUgMzguNzc3MzE1TDg3LjIxODc2MyAzOS45OTYwNjJMODguNzM0Mzg3IDQwLjE2MDEyOUw4OC43NzczNTggNDEuNjgzNTY2Wicgc3Ryb2tlPScjMDA4MDgwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0ODInIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMTA0LjEyMDctNDAuODA0Njg5QzQ5Ljc1NzctMjQuMzM5ODg5IDE2LjM1NTUgMTAuMzA0NjkxIDIuMTk1MyA2Ni4wMDAwMTEnIHN0cm9rZT0nIzAwODA4MCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00xLjY4MzU5OCA2OC4wNjI0OEwzLjUzMTI1NiA2NS4zODY3TDIuMTc1Nzg2IDY2LjA4MjAxMUwxLjMwNDY5MiA2NC44MzU5MjJaJyBmaWxsPScjMDA4MDgwJy8+CjxwYXRoIGQ9J00xLjY4MzU5OCA2OC4wNjI0OEwzLjUzMTI1NiA2NS4zODY3TDIuMTc1Nzg2IDY2LjA4MjAxMUwxLjMwNDY5MiA2NC44MzU5MjJaJyBzdHJva2U9JyMwMDgwODAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4OScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjwvZz4KPC9zdmc+" /></p>
<p>To call <span class="math inline">\mathcal{C}</span> a category, composition must also satisfy two laws. First, it must be associative. That is, for any composable triple of arrows, <span class="math display"> h \circ (g \circ f) = (h \circ g) \circ f.</span> Second, for each object <span class="math inline">X</span>, a special arrow <span class="math inline">\operatorname{\mathrm{id}}_X \colon X \to X</span> must exist, called the <em>identity</em> for <span class="math inline">X</span>, with the special property that for any <span class="math inline">f \colon A \to B</span>, <span class="math display">f \circ \operatorname{\mathrm{id}}_A = \operatorname{\mathrm{id}}_B \circ f = f. </span></p>
<p>Now, back to types. Probably the most striking feature of functional programming is that it is stateless. That is, we don’t think of functions as a series of procedures mutating some registers, we think of them as mathematical functions and as such, we must have that <span class="math inline">f(x)</span> returns the exact same value no matter when we execute it. For us, the main consequence of this is that function composition becomes associative. Thus, there is a category <span class="math inline">\mathtt{Types}</span> whose objects are types and arrows are functions between types. Composition is the usual for functions and the identities are the identity functions <span class="math inline">\operatorname{\mathrm{id}}_A(x) = x</span>.</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzQ2Ny4yOTQyNThwdCcgaGVpZ2h0PSczOTMuMDA5MTMxcHQnIHZpZXdCb3g9Jy0xMzcuMzU5Mjc0IC0xMzcuMzYwNzUxIDQ2Ny4yOTQyNTggMzkzLjAwOTEzMSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6bG1taTk7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRrQUEwQUFBQUFCbEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGYvMDlUTHpJQUFBRk1BQUFBUWdBQUFGWldXVjdQWTIxaGNBQUFBWkFBQUFCR0FBQUJRZ01UQkJKamRuUWdBQUFCMkFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIY0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlUUFBQUdSQUFBQnlNZjljUnRvWldGa0FBQURlQUFBQURFQUFBQTJHTTlFUDJob1pXRUFBQU9zQUFBQUlBQUFBQ1FGVHdEdWFHMTBlQUFBQTh3QUFBQVVBQUFBRkFhV0FHbHNiMk5oQUFBRDRBQUFBQXdBQUFBTUFMWUJPRzFoZUhBQUFBUHNBQUFBSHdBQUFDQUFTd0IyYm1GdFpRQUFCQXdBQUFDL0FBQUJIY0U0a3Bod2IzTjBBQUFFekFBQUFCWUFBQUFzQUZFQVRIamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUcwUUJjaVFpSkFBQjQybU5nWkh6SE9JR0JsWUdCcVl0cER3TURRdytFWm56QVlNaklCQlJsWUdWbWdBRkdCaVFRa09hYUFxVFNHTktaM3Yxblk0aGlPc2h3RnFZR0FBUUpDOU1BQUhqYVkyQmdZR2FBWUJrR1JnWVFzQUh5R01GOEZnWUZJTTBDaENCKyt2Ly9RREx0Ly8vL2M2RXFHUmpaR0dCTUJrWW1JTUhFZ0FvWUdhZ0VtRmtZQmlrQUFMTDFCeWdBQUFBaEFua0FBQUFCLy84QUFuamFYWSsvVHR0UUZJZlB1WFo4RTJSdWZPMXJKMHF3dzdYQktVUXFFQ2UyQUdNa2dsQUdKQllpb1RBZ2hJVFV0VldIaW9XdHoxQ212a0l5d3NURTBrZm8zaTY4QVg5cUI2a0Raemc2K3I2am8vTURBaElBVjhrTktFRGg0d1JoTFoxU0ZSNjdFNjMwTzUwcUpCOWhvaFM0Vk9BcDFmQXBuV0xCSXk1NU8rS0J4TXJmaHdkeTgzd3B5UWtBZ2ZnMUlodmtIZ2F3bjEvdmhZR3ZVWVkwOEJrS1p4c1ZwZ1orTzhQK3pOakNpYm9aU2F5ODU3c2RqSk1NbzI2TjRjekVmYklSTDh2TXFKcDhxTTlWNW8zOVVVbGpyTVlXdVBBY3c1R3h2NVMyYTNRdzF1ZktPaCs1RmMzakRXRzJDa2V1RnNQVmxqZTh3TEtwdnV6VzZ4M0haRXJMTmszWlhBeDdvOE0ybmhmcTUxS3p3VlRYS1Rqa3BZTDVHdUVmdklWbENHRVR0Z0JLMWx1US96OG5HdFhlNTRnVGk4NXcyTys5NWZEUXB2ajFzem5QR2txUW52NDRTamQzM0hMbll0MnQybzRoZ29POThSZFdYMVA1VnVKTGFkdVpkRC9veWdCLzZWeUlkUExwWUp4OHM4N0ttbGMxUkd2QmJ4N0hlSDFuaWIwa2xOOVh3dDVLVUtrQy9BTVlxVW9iQUFBQWVOcGpZR1JnWUFEaW5IbEtvdkg4Tmw4WnVKbGZBRVVZYm05cjJBeW5oZjRiTXhreUhRUnlPUmlZUUtJQVF6SUxwUUFBQUhqYVkyQmtZR0E2K04rWUlZcnhNd1BELzBOTWhneEFFUlRBQ2dDR2x3VS9BV3dBSVFBQUFBQUJUUUFBQWZNQU5nSHFBQklBQUFBcUFDb0FLZ0NNQU9SNDJtTmdaR0JnWUdWd1pXQmhBQUVtSUdaa0FJazVNT2lCQkFBS3Z3RENBSGphUlkxTmlnSXhFSVUveDM4SFpGYUR5K0MrbTNSMnVwWStnQXVYQXk1aTA5QS9FUFVBSHNNRGVBQnY2RXNUbUlTcStvcDZ2QWNzdURBaXZpL20vQ1FlcytVdjhaUnZub2xuMnQ2NmppWkw2ZGVETXZLWUE1dkVVMzU1Sko2eDRzVVJUOFdkaGpNQmpyNjZOMmRCU1UvSGJaaEJDby9Ca1dNMTk2cUdWcjltbDNaSFFhYXk2azQ5Rm1YZjNjbytWTjY0M0pxOWFkcTIzbW02SWl0czVxeVQ1aVRyd0ZWV01kRElJb1p3OHVGYTk1MHBjaTMvWVF3V2ZBRDhieWNHQUhqYVkyQml3QTlZZ1ppUmdZbkJrOEVMQUFIdkFKNEFBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6cm0tbG1yOTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBaEVBQTBBQUFBQUN5QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZi8wOVRMeklBQUFGTUFBQUFRZ0FBQUZaV2IxOURZMjFoY0FBQUFaQUFBQUIzQUFBQmNpYUNHc2hqZG5RZ0FBQUNDQUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUlNQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWhRQUFBUjZBQUFHR0VEV3BpQm9aV0ZrQUFBR2tBQUFBREVBQUFBMkdlRkVQMmhvWldFQUFBYkVBQUFBSGdBQUFDUUdpd0p2YUcxMGVBQUFCdVFBQUFBOEFBQUFQQnA4QWZkc2IyTmhBQUFISUFBQUFDQUFBQUFnQ2JvTE9HMWhlSEFBQUFkQUFBQUFId0FBQUNBQVZRQjhibUZ0WlFBQUIyQUFBQUMyQUFBQklJWHNJbmx3YjNOMEFBQUlHQUFBQUNvQUFBQkFBYUFCbm5qYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5RzBRQmNpUWlKQUFCNDJtTmdaUHpOT0lHQmxZR0JxWk5wTndNRFF6ZUVacnpQWU1qSUJCUmxZR1ZtZ0FGR0JpUVFrT2FhQXFRMEdNcVlwZjRiTTBReHZXUDRDVk1EQVBxNkMxNEFBSGphWTJCZ1lHYUFZQmtHUmdZUXlBSHlHTUY4Rm9ZQUlDMEFoQ0I1VFlaRWhsU0dUSVlDaGlLR3N2Ly9nU0lhUUpFVW9FZ3VST1QvN2Y5TC9pLzZQLy8vblArei84K0Ftb1lDR05rWTRNS01URUNDQ1YwQmdzbk13a0FlWUdWZ1lHTUgwaHhBek1uRnpjUEFDMlR3TVF3V0FBQVJaaFo3QUFBaEFua0FBQUFCLy84QUFuamFmWlJOVEJ0SEdJYS9tYlc5bURVRzI3ditXWVBYdTJ2V1ptMzh1MnRUZzQwTktKZzBGb0VBZ3FiR0lTbHRwS3BxRlJXMWgxUlJSWUtTSGlwU1JZMFVxZXFoNm8rS2xDZ2NjdWdwNmlHSDNpUDFrR09rbkJvcGFuTnFBcDFaSUUxcFdzbTdtaDFaNy9lODcvZk5BQVlaQUEzZ0c4QUFDK25iQ0RJajI2d05mc3ZmZHRnZmpHd3ptQ3poTmtPMzdYUjdtM1dnWnlQYmlPNFhQTEluWHZDb011cDRkTzhldnZIOGJSa3ZBbUJZM1dYUlBINE1BUWdDMkkyNDV1a3BGVTFEVmR5SWRRaDhJSUlMZVJQTk8zL1ljcmhZb3hGcTFNSk5vOFAxMk1iZFFLT28vSTNEd1NXWGNwczN2Nzh5ZENyRkFWRE5NdEhVaWFZSVlZQitJNTdHcWtLbEdLR0hhaGJ5VlVScUlIMVB5aG5PbFpVRDlUKy9zM1FjenVENEJ6Kyt0ZlB6MTA3RzByOEZZQU41OXlsNmd1NUNCckpRaG1HaWJhb0NyMVNRa1VaeFRWV0l0ajlQNExVTUtoYnkvajdrb09VaXFKQXYwVmNWbVhIZW9TcWFhUlJMQW5yUzIyQUVvVGhUWHdvblJMK0xpMDBrNitjYnkwTkh0Slp1MHlXUEdydloxUHVMNzd5N05GU3ExRzZwU3BMUERtZjhvc2o3Z2d4VzZ4WFpycVJuTk1OM1FoNTBwZnVOZWpVYkc1cTFuYUVaMkVEWmZZcDc4UjN3azJRSFFBZVFUVkxZd3dxVWE1K1ZjQW1sT004U3BqaUJLaEhvUUFUMUlkeGJFSzhWeE56MDh1VlAzNWdwWGIvZW5acWFHT2lOSnFmR2RTY2orZnB4bXlQdis4TVgyNjFMdFJyM3NTRFV4dEtMSjNPanc2NU85eTlXL1Q2UzFSYkpLZ0lTSkFnQjZZT3FzRzdHS2lWYktSMUFWTEVaVjZzTVNTeUF0dHdjNDlJeklqYzVvS0ErcjdOMWN1bVRqWlkrcWZFVHZ6UFJsTnlkSFVjZmRYRnF4bU92NUZjZDNYUG5OcFpYTnBSMG9uT2plRlRpWmhkcDdSZ2hlSTZ2Z2hkOFpBSjZBUW92dkFzZTBnR0JHc1dHcGpoSXYwclBzOEptTmhReXhwUGwzSkNVbHVqUEhVSHZjNUszZitjUHVVdGlHRHhoYlJmSmJLa0FUQjM5QkZOdzFNbzBqVWo3TmRwOWxocGlWZk9mWlVobDhvZTljZmkvUGFZdWlYeG5RRHAySnU5Ykt6Vzk2R3BCREJtVFNYWGFDQzBZQ1Rsa0hFa3B4dy9XZEYvQzd1NjdqYUlZYTdmTGlkTzBJVHRQTFZxcFM3N3orb2xpNmRFcnZxenpRVHhnbFhpZ2Mzekl3My9pLzAyS1ZVTGF3U3ZOMWR6TGtQTm1nekx1Y3gweGd3TXJLNGVnanM2OXQwK3hOeDhQeVh4dzRDSWQ2cVB6OFdJZ2l1YWhvZlFMNk9GR3EzMkpQZ3VoeExHbUZnN0ZtOVB4NFAzVFZ6NWJhYTJ2dDV6dDFGZ3R0Ykk4TURhV09rbG5JTEpieFVIaVVZSW9wSW5UUFgzMlZmYm9GVk0wVmQ2cVdFRlZjbFQ5QWc1ZVdKb3JYek5DMUI4TjNoc3lwRGV2TEN4VzZucFhjREpXUHY3cjhzWFJVVTdxa1hkU0J3Ni85ZkxDK3FuNXRRb3ZQRWhvSDg2U3JDUGt6bHdqSERva3ljcjRkOFlCVTdVeUpnZEFjT045LzJoTmx4Zmk2SE1hNzdSMmdUZUN0dTVRTG9wWnArajFoTkg1VVAvWnN5K0g2NDE4NmRGZVMwVVJZcjBjSHd3S1ZwOTVjZ2M0MFMwckEwQm1sbFhpZ2wvZ3V4RkRnaTJZMUM4QkNmaklJZkFWUzlqWkhOVFQ5clBuN0tYNllDMldrRHEvWUtNZGw4VTYycVFsbUlUVC9ReDVPcDBpL2VMRW5hOThQdFNvNHI4QXFDTWVGUUFBZU5wallHUmdZQURpekFqakgvSDhObDhadUptZkEwVVlibTlyMkF5blJmNnpNenN5dlFOeU9SaVlRS0lBWDU4TVl3QUFBSGphWTJCa1lHQjY5NStkSVlvNWdnRUltQjBaR0JsUUFUOEFVNWtEQVFBQUFXc0FJUUFBQUFBQlRRQUFBWkFBWlFHUUFEb0NBZ0FoQWpzQUlnSEpBQjBCSGdBa0ExZ0FJd0k3QUNNQ0FnQWRBanNBSGdHU0FCNENIZ0FVQUFBQUtnQXFBQ29BVkFDQUFOWUJGZ0ZVQVlJQjVBSW1BbFlDbWdMWUF3eDQybU5nWkdCZzRHZndabUJoQUFFbUlHWmtBSWs1TU9pQkJBQU1Zd0RTQUhqYVZZMU5Dc0l3RUVaZnRhMVZRWGV1czNDYmttUm5EMUE4UWNFRFZDbjBCMkxYSHNNRGVBUlA2TFFHd2NCazNzeDhNeCtRY1NWaWVndGlOb0dYSExrRVR0anlESnl5NGkzVEtGNkxQcHVWRXk4NXN3K2NjT0FST0dYSGk1WU96d25henN0Zk10QXp6dGx6bzBiaHlER1NDd2t2Y3YxYit2WWNWbnBXTkZyWXpFRTU5R001K0Z1dFhHNVVvWHluSndjaFo3VTEyaGtucWtvTVBIZWEyVmJKa2NtS3F2YjNadWlWemFYNHR5UWM0Z085b3lieEFBQjQybU5nWXNBUCtJR1lrWUdKZ1p1Qmg4R0Z3WjNCZzhHSElZQWhrQ0dJSVpnaGxDRVNBQ0lxQXo4QUFBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpsbXN5OTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU1FBQTBBQUFBQUJlZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZi8wOVRMeklBQUFGTUFBQUFSd0FBQUZaNHFZSllZMjFoY0FBQUFaUUFBQUJNQUFBQlVpSTNLblJqZG5RZ0FBQUI0QUFBQUFRQUFBQUVBQ0VCbm1kaGMzQUFBQUhrQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWV3QUFBRWlBQUFCT0tyN2IyWm9aV0ZrQUFBREVBQUFBREVBQUFBMkdocEFUbWhvWldFQUFBTkVBQUFBSUFBQUFDUUZpLytNYUcxMGVBQUFBMlFBQUFBWUFBQUFHQWt2QVB0c2IyTmhBQUFEZkFBQUFBNEFBQUFPQVFRQXhtMWhlSEFBQUFPTUFBQUFId0FBQUNBQVRBQlFibUZ0WlFBQUE2d0FBQUM5QUFBQkhjZE91SzV3YjNOMEFBQUViQUFBQUNNQUFBQTVXNS9sM1hqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5RzBRQmNpUWlKQUFCNDJtTmdaRkpubk1EQXlzREExTW0wbTRHQm9SdENNOTVuTUdSa0Fvb3lzREl6d0FDUXIrQUE0d1NrdWFZQXFlMnF6eGozLzczQkVNVjRpSGtma004SWtnTUE2K0VNOFFCNDJtTmdZR0JtZ0dBWkJrWUdFUEFCOGhqQmZCWUdBeUROQVlSTVFIcTdrcFRxcy8vL0Vhei9QbmRmM1pLSDZnSURSallHT0pjUnBJZUpBUlV3TWd3RndJSlhsaG0vWmdCYjJ3enZBQ0VCbmdBQUFBSC8vd0FDZU5vMWpVMUxBbUVVaGMvMW5YbmZjVDRTYVdhb1JlSW9PWVJSTkY4U0NHbXQzQWlhaTRoWnRuV243bHozRC9vYjRXeGFDbUVpdEczWk5scjFCMktRWm9UZ2NzODlENGR6VVlBRDBBa3R3U0J3dGlDY3R4TWg0Y2RiY1Btem5iQkNkbUxCY2l6bk9CR2MwblpDT2ZmTFR0bjF5M1dIbE8vMW1wYmJya056b0lBN3ZHRkZGMW1qQWtSQm84Wk4yMnV0cXFmVmJMNTJPOHB6dmZTYWpkSEVFU3JBY2RDbzE3Z2dsa21KdUdYNjNoWHRWOGozb2haRklSc2JTbEhoMi80TEw4ckZoejFEVXNOM21hdWF3dWxEV0txdTZPa1RQWlpFVCtPNmNMZDlUUllhZXpaa1NMaUVUeHQ2aFFZZEJ6ajgvMldaZGxZZXVpYXYxeHBoRVBtZWJkRm1OaGhOcHNQUnBCbDNPM0hjdWJuL3pmenRjRG9iVUhmbjR3NytBQ1QxUDAwQUFIamFZMkJrWUdBQTRnaitqalh4L0RaZkdiaVpud05GR0c1dmE5Z01weFgvT0RIbk1oNENjamtZbUVDaUFGWUNERllBQUFCNDJtTmdaR0JnUFBUSGlTR0tPWUtCNGY5cjVsd0dvQWdLWUFNQWdPWUZHUUZyQUNFQUFBQUFBVTBBQUFFZEFGZ0RXQUJKQWdJQU9RQUFBQ29BS2dBcUFENEFjZ0NjQUFCNDJtTmdaR0JnWUdPUVoyQmhBQUVtSUdaa0FJazVNT2lCQkFBSEpBQ2RBSGphUlkwN0NzSkFGRVdQeHI4Z1ZtSTUyQ2RNcGt0cXlRSXNMQVdMTVFUeWdVbFNXTG9NRitBQzNLRXZZY0NCKzk2NXpPVStZTVdEQ2NPYnNtVHZPZURFemZPY0xXL1BDM0ZmK1ozTTFwTGZqY21CQTg0Y1BjODU4UEs4WU1PSEM1YWNucEk3RGk0Mjc4dTdRRVpEVFRkdUp3bUx3aENoWmFlaWtvcVdKNG4zaHBoUXBHVWFtWVBJbXJyTEdwZGJaU0t0VWxWVzdUT1JiZUl3MXFIUlJqSlhxWFpTVll3SGxWUU1SN2hhMXhaTnJlSkl6UDhZWXdVL0Rpb25YZ0FBQUhqYVkyQml3QS9ZZ0ppUmdZbmhNTU5TUmlhdS9JTFV2S1RTbkp6VUVnQXVjUVc3QUE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnJtLWxtdHQxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBY2dBQTBBQUFBQUNXQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZi8wOVRMeklBQUFGTUFBQUFRZ0FBQUZaV1ZGN3FZMjFoY0FBQUFaQUFBQUJ3QUFBQmFnbXZEQnRqZG5RZ0FBQUNBQUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUlFQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWd3QUFBT0hBQUFFZUtvWEFRTm9aV0ZrQUFBRmxBQUFBRE1BQUFBMkdJOUVBR2hvWldFQUFBWElBQUFBSGdBQUFDUUUrUUV1YUcxMGVBQUFCZWdBQUFBZUFBQUFIZ2FtQUxkc2IyTmhBQUFHQ0FBQUFCZ0FBQUFZQk1nR09HMWhlSEFBQUFZZ0FBQUFId0FBQUNBQVV3Q0JibUZ0WlFBQUJrQUFBQUM2QUFBQk1qcTYzMHB3YjNOMEFBQUcvQUFBQUNRQUFBQTRBUmtCTzNqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5RzBRQmNpUWlKQUFCNDJtTmdaT0psbk1EQXlzREExTW0wbTRHQm9SdENNOTVuTUdSa0Fvb3lzSEl5d0FBakF4SUlTSE5OQVZKT0RKVk12LzRMTTBReHpXSjRBbE1EQUxvR0N1b0FBSGphWTJCZ1lHYUFZQmtHUmdZUVNBSHlHTUY4RmdZUElNM0h3TUhBeE1ERzRNU1F4SkRLa011UXoxRDUvejlRM0lraEVjalBnZkQvSC95LytQL0MvN1Avei9vL0VXb09FbUJrWTRBTE1qSUJDU1owQlF4RUFHYjgwaXlzREVCWGdnRTdCd01uWEp5TFlWQUFBTU01RTlBQUlRSjVBQUFBQWYvL0FBSjQybjJUejIvYlpCakhuL2ROYW1ja3R1UFlpWlBXZFdvN2plMWxUVlQvaU5Va0RWdlhkS1JvWFNZNjFOSTFRNHFnQndSQ1FrT3F4bzl0bFpEZ01NRjFrN2h3QUU2b1JhQ0pQMkJJY0psVUllMHdjZWhsMndFSm9XcUhhVXQ1WDRjRDQ0RGtIOC96K05YejQvTjlEQmgwQU9UZ214QURGcXE3Q0dxdFBUWU9mN2k3ek5qOTFsNE1FeE4yWXpROFJzTjdMSU9ldHZZUWpYdWlMbHFlYU9vbzhlRE9IWHp6MlpzNlhnTmdRQ0U1RC9BQThsQUFBMHlvd0FtQWFiOXN0VkhnbHl2SXlNcE5KSnJSeTYwSE1abXBvTUJ6YzluY1A1YUNEcGFhczgzK3lvSHRURXc0OXVOei9kZE9udHI2Y003TkxyUSsvbXl1OFhYd0tpOTJxNjFMV25Hb0ZMV3RrMmpLV3Z4bDNqaGNYVGg0SHdEaTRCNDl3U3k2RGROUUJnOThXdDgwTEZLZWxzMTViajMwNjJHZEZ1VlJGQWpKVGZxelpCNnhqR21VQS9JOWkxbmJ5ZzRHWDR4TGdvb1lnYysxRmovOWFtTjVyYUZjeUlqQ3Q3Rk1waFRNTkQ1NHE2Z2w3czMzdTdsOHRzREVFZkk4ZkhhcDNpdFBZVjdZRXRKS1FxeG8wMjVzbGZTVk9ucUNIaEkyRTZDQ0E4Y2pMcWJCL291THJDSFNYa0I3REV5WnRqS1AvS2hUOVBDOVhyY3VGTHFPUFlQRnRKSjBGMTY1MHJrUUJxM2xXbmoyM3NWcnN6L214YUkyakhFOG44MTdWL3VkaXhzejNST0wvUVdJbUlTazlsM0NSSVZKS0JFeUVSTW1tdGJTM1RhTzZEQVVCckV0dlUzNnlDbm9yc256WStNcnpVc3BkUHlGSk1lOHNibiswU2V2VjVjdCtjendjYkxuMTVhWXQ5VUUzMXB1SXpiTmJXenYzTjVSSFRONUkrdzJsbWhkREEyeUQvdGtab1ZzQktsWlJSVWtQcjhIbnU0R2FGL2dVdGVGd3BlT2ZmMmFZNk91cmZFQ1JzK2lrWWpJR3MxMTlKUTg0dWdIV0lGem8xeG00RmN4SVVncFZuR1VsQUFVRFNvcldhOWdkSVR5bTBUL0g4VHh0SlNMODNheFBhMEVOUXZ4WEdyS0lhR2NsSGJXcURHclN4bE9TRHN2UCs5b0FvLy9TbXVoN3ZzbG5zZlVIZjVLbE5lbzlmMkwzVkwxRVJiNC8zcEVqem1peHo3Ukl3SEhRQUlab09TWERZWnNveHRhTWhPdElGVjlmL3ViYlhKMWV1LzJ6cjl6L3NwUE96dWIvYXUvczUzQm9ITjZmZjMwaVBINGtZb08wWGZRZ25sQ08ySWNrV2lTYldiTmNvMW9HWXlpbzNFbGhRalAxa2VTUno5QU94Wks1QkE2SkRKY3RzbERmU21UUUZqYUxGRG5jb29UN09LTmVJR2I5TWJ5a3B5dmxWU3ZxTEx4VzVxTlBpZENVYkYrOHczVy81TmFkTVRoTFc2MUVNYU9jVkkrTCt1ems0YVhTYUtmcVl4L0E4a1EwU29BZU5wallHUmdZQURpK1EwMkJ2SDhObDhadUptZkEwVVlibTlyMkF5ai8vLzVMOFBFempRTHlPVmdZQUtKQWdCc1JBMXZBSGphWTJCa1lHQ2E5VitHSVlxSjkvOGZJSnVkQVNpQ0FsZ0Fib0FFS3dBQUFnMEFJUUFBQUFBQ0RRQUFBZzBBRndBeUFBd0FOd0E2Ly93QU9RQWFBQUFBQUFBcUFDb0FLZ0JzQUxnQTlnRXlBVmdCdmdIa0FqeDQybU5nWkdCZzRHWUlZR0JqQUFFbUlHWmtBSWs1TU9pQkJBQU1vZ0RWQUhqYVpZMU5Dc0l3RUVaZjFSWkZjU0hvT2l0M0tVbVdQVUJYcm5zQnFVWG9ENlE5aGNmd0FCN0Nremx0Z3lBbURQTm01cHY1Z0RVM0lzYTNJR0VmZU1tWmErQ1lMYy9BQ1J2ZU1vMVdHOUh2SnVYSVN5NGNBOGVjZUFST09QQ2lwbUdRYnpGUU44TmdKZWQwdE5JY3M2ZWlST0ZJUmFMSUpMd3M2Wi9WdWUrRTlWUnJZVE1GZWRjT2VlZXJVcm5VcUV6NVJzOCt3czVxYTdRelRuU0YySGg2N3BPNWtqT2pJVVhwKzN2WEtwdEs4Vy9NOXh3ZkFnUXEvd0FBZU5wallHSkFCb3dNNklBYkxNckVvTXJnd3VESzRNSGd6eERBRU1RUUF3QVNLZ0pWKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6bG1zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRQUFBMEFBQUFBQlVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJvQUFBQWNpeVBmLzA5VEx6SUFBQUZNQUFBQVJnQUFBRloxcm9BSFkyMWhjQUFBQVpRQUFBQStBQUFCUWdBUEpUMWpkblFnQUFBQjFBQUFBQVFBQUFBRUFDRUJuV2RoYzNBQUFBSFlBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBZUFBQUFDd0FBQUFzTm5tZDJKb1pXRmtBQUFDa0FBQUFESUFBQUEyR2x4RVBtaG9aV0VBQUFMRUFBQUFIZ0FBQUNRR0NnUGlhRzEwZUFBQUF1UUFBQUFRQUFBQUVBdTRBRmhzYjJOaEFBQUM5QUFBQUFvQUFBQUtBSUlBVkcxaGVIQUFBQU1BQUFBQUh3QUFBQ0FBU0FCT2JtRnRaUUFBQXlBQUFBQzhBQUFCSXdMa2Z0QndiM04wQUFBRDNBQUFBQ0VBQUFBMVdlVGhRM2phWTJCZ1lHUUFnc3ZiN3MwQTBiZTNOV3lHMFFCY2lRaUpBQUI0Mm1OZ1pIN0JPSUdCbFlHQnFaTnBOd01EUXplRVpyelBZTWpJQkJSbFlPVmtRQVlLTUVaQW1tc0tBNFBpSk1WSmpQditYbWVJWXZ6UHdBMFVaZ1RKQVFBWHJneWdBQUI0Mm1OZ1lHQm1nR0FaQmtZR0VMQUI4aGpCZkJZR0JTRE5Bb1JBdnVLay8vOGg1TDFDcUVvR1JqWUdHSk9Ca1FsSU1ER2dBa2FHWVE4QUF2c0hiUUFBQUNFQm5RQUFBQUgvL3dBQ0FBSUFJUUFBQVNrQnZnQURBQWNBTHJFQkFDODhzZ2NFQU8weXNRWUYzRHl5QXdJQTdUSUFzUU1BTHp5eUJRUUE3VEt5QndZQi9EeXlBUUlBN1RJekVTRVJKek1SSXlFQkNPZkd4Z0crL2tJaEFYd0FBQUlBTi8vMUE2OEIvd0FiQUJ3QUFDUTBKeTRCSnlZckFTSVZGaGNoSWhReklRWUhGRHNCTWpjK0FUOEJBNjhJVVc0T0Fna1NDeGwyL1FzVkZRTDFkaGtMRWdrQ0RtNVJDUElRQWgyQlZBa05qMVVvVlk4TkNWU0JIUXA0Mm1OZ1pHQmdBT0xUemo5dnhmUGJmR1hnWm40T0ZHRzR2YTFoTTV4Vy9QK1ZlVDNqZnlDWGc0RUpKQW9BbjV3TzBRQUFlTnBqWUdSZ1lQei8veXRERlBNTEJpQmdYcy9BeUlBS1dBQ0dyUVR5QUFBRDZBQWhBQUFBQUFQb0FBQUQ2QUEzQUFBQUtnQXFBQ29BV0FBQWVOcGpZR1JnWUdCaGtHVmdZZ0FCRU1uSUFCSnpZTkFEQ1FBQUJvNEFsd0I0MmsyTlRRckNNQkNGUC84VlJWeUp5NERybGlSTEQ5QUR1SEN0aTFnS3RZVzBYYmozR0I3QUUzZytwekdJRTRiNVp2SjRENWh6WlVCZlEyWnNJby9ZYzQ0OFlja3o4bFRlVzM0SDQ0WG8xMEhaODRpTVhlUUpXeDZScDZ4NGNjU1IwMUZ5d2NQUjVWMTVFY2lvcVdqRDlLSndLQ3dwV3VaQnV1Ukd3eDN6dTFqaEpPeUpzQTVOVmxkdFZ2dmNLWnRxZFZEbHJibWJIcXhKakU2c3RpSTZpYnNYdHlKa0t2SG9jemc1M3hSMXBVd3F5MzhlWHhjKzd5QW9GSGphWTJCaVFBYU1ET2lBQlN6S3hNakVsVmhVbEY5ZWxKbWVVUUlBR1ZnRVlRQUFBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6bXNibTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZQUFBMEFBQUFBQjhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJvQUFBQWNpeVBmLzA5VEx6SUFBQUZNQUFBQVFRQUFBRlpWUTE4K1kyMWhjQUFBQVpBQUFBQlBBQUFCVWd4ckJIeGpkblFnQUFBQjRBQUFBQVFBQUFBRUFDRUNlV2RoYzNBQUFBSGtBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBZXdBQUFLaEFBQURHUE5ReE1Sb1pXRmtBQUFFa0FBQUFESUFBQUEyR1Z0RTVHaG9aV0VBQUFURUFBQUFIZ0FBQUNRRnlBTEdhRzEwZUFBQUJPUUFBQUFZQUFBQUdBcjJBR1pzYjJOaEFBQUUvQUFBQUE0QUFBQU9Ba1lCZW0xaGVIQUFBQVVNQUFBQUh3QUFBQ0FBVWdDWmJtRnRaUUFBQlN3QUFBQzhBQUFCSS9MU2JxcHdiM04wQUFBRjZBQUFBQmdBQUFBdUFIY0FOM2phWTJCZ1lHUUFnc3ZiN3MwQTBiZTNOV3lHMFFCY2lRaUpBQUI0Mm1OZ1pOclBPSUdCbFlHQnFaTnBOd01EUXplRVpyelBZTWpJQkJSbFlHVm1nQUZHQmlRUWtPYWFBcVQ4R0tLWTF2MDdEaVRYTWdqRDFBQUE4Q0VMTEFBQUFIamFZMkJnWUdhQVlCa0dSZ1lROEFIeUdNRjhGZ1lESU0wQmhFeEEybzhoaUNIcS8zOEU2Ly9XLzV2K3I0YnFBZ05HTmdZNGx4R2toNGtCRlRBeWtBaEFEbU9Cc2xrWmhnSUFBREVjQy9BQUFDRUNlUUFBQUFILy93QUNlTnBOa1V0ckUxRVVnTSs1TTVsblhwUE1veVZ0eW1TYVRKdG9TbVl5TTlxa0tmUWhXRkViZkMrVVdpSGRLSWdiSzNRcHRMb1FjU0VhZjROaWd5c1hTaGV0NEVaUTNLbTRVeGRkaTJCRzc5QUszcnM1cnd2Myt3NFFNQUZ3bkhTQkFSNnFtd2dUelI3UHdxNnp5Y1UrTlhzTW9TRnNNbEU1RnBWN1BJZS9tejJNNnE1aUtyYXJXQ1lLMzNaMlNMZmZNY2w1QUJZRy8reVNWK1FwTktBSk16QUxrRlZVamk5b3F0NUFwNFZlM2FxaXA2RHVPcDVTOXdQSHE1Y3FXRWlpcHJwNTFCU3M0cjlVTnpoTnhKTHRvblpkTHc0cHlwTzRMT1h0QVh3dVM0cFdNTkxLZzdnc0Q0OE5oTzk1T2ZPTU5qWFRJUGc1UEs2d043Rk5Ub1VENVdGVTRoeUtnb0lqWlh6YjMwNlp4S3ZrL2l1R2IvQ1J4RVlKbXhQUy9hOWtXbVhEdy9lQkhnblNBT1ExWlFuZ0VDV1pnMFZvdzBXNEJCMVlvZVpjUXpmeXVFOWxsK2lOZ2lxeHpMMy9PN3BHMGEwSTNUWDMwQXVsS1F6OHVwMW5OQ3JGcnJkSU5FV0hQTWFuT215WG8wOE1LK3U3VHFBYkZvUHgwWWRGSVNabDdsSzYxT2pDdWVMSnBkcmloWWx3aDVMbnlxcGF6cVV6bUtITm9YSjJhNlNrMlU2K2VYU0x5RGw5Wm1wK2RVTVFiaVNFYXgrVE1UMS9lK0h5QzV6OFBoa1hHVXFiWklUbHRXYnlSTnM1VmxZaittd3BsRXZaZlMvWjBwZmErTXRhTERVU1dONTg0b2VjVUtYWnMwdjFuLzEzbVNMK0ttYlNWc2dVTTJnUTlzTUNHdFNWQUVQVTFScDFWWUVEVUFNSGZHcHRDbHJVazA5WFRKMXdLVUpGT0lFZitBMUVicytLUDQyMFNYM3hTYnAzTExvYXh3ZW1peFptL1lEakxZK2NGdE5LNkJzU1NaRTRsMkRsNmRhVmRyZ2hwak1FZFpISnlSd3ZNQ1MxdG53UFY4TmhiOUNNNFpsT3VON0JXMTZsZ01JY3VaT0l4VGxSWFUrSVVtcldIdXQzbzF4UXR3VkprT0pIcnBJT1lqSi9zUCtZclBTN2crTkNBLzhDbk9TTlh3QUFBSGphWTJCa1lHQUE0c20vTjMrTzU3ZjV5c0ROL0J3b3duQjdXOE5tT0Mzdy95M1RmcWExUUM0SEF4TklGQUNwdmc3SkFBQjQybU5nWkdCZ1d2di9MVU1VMHlVR0lHRGF6OERJZ0FyWUFIclZCSk1BQUFGckFDRUFBQUFBQVUwQUFBTFNBQmtDMGdBUUFwb0FIQUFBQUNvQUtnQXFBSkFCSmdHTUFBQjQybU5nWkdCZ1lHUElZT0JpQUFFbUlHWmtBSWs1TU9pQkJBQU96d0RzQUhqYVRZMU5Dc0l3RUlVLy94VkZYSW5MZ091V0pFc1AwQU80Y0sxQ0xBWGJRdHJld0dONEFFL2crWnpHSUNaTTVwdko0ejFnem8wQi9Sa3lZeE41eEo1ejVBbExucEduY3QveU94Z3ZSTDhPeXA1SFpPd2lUOWp5aUR4bHhZc2pqcHlPT3hjOEhGM2UzUzhDR1RVVmJlaGVGQTZGSlVWTFAwaVZORnpsTmIrTkZVN0NuQWpyVUdSMTFXYTF6NTJ5cVZZSFZUYlgwdlJnVFdKMFlyVVYwVW5jdmZnVklWT0pSNS9EeWZtbXFDdGxVaG4rOC9pNjhBSGNXQ2U4ZU5wallHTEFEOWlBbUpHQmljR1F3WlRCRmdBQ3ZnQ3YpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpybS1sbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUWtBQTBBQUFBQUJaQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZi8wOVRMeklBQUFGTUFBQUFRZ0FBQUZaV2NWNkhZMjFoY0FBQUFaQUFBQUJFQUFBQlFnQVBCdGhqZG5RZ0FBQUIxQUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUhZQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWVBQUFBRGVBQUFBL0tCeVFnWm9aV0ZrQUFBQ3dBQUFBREVBQUFBMkYvaEVQbWhvWldFQUFBTDBBQUFBSGdBQUFDUUVsUUNRYUcxMGVBQUFBeFFBQUFBU0FBQUFFZ1RJQUlSc2IyTmhBQUFES0FBQUFBd0FBQUFNQUg0QTBtMWhlSEFBQUFNMEFBQUFId0FBQUNBQVNRQktibUZ0WlFBQUExUUFBQUMzQUFBQktSOU1NNUZ3YjNOMEFBQUVEQUFBQUJnQUFBQXNBQk1BRDNqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5RzBRQmNpUWlKQUFCNDJtTmdaR3hsbk1EQXlzREExTW0wbTRHQm9SdENNOTVuTUdSa0Fvb3lzSEl5d0FBakF4SUlTSE5OQVZJYURKck0wdjlOR0tLWTNqSDhncWtCQU5BY0NxUUFBSGphWTJCZ1lHYUFZQmtHUmdZUXNBSHlHTUY4RmdZRklNMENoQ0MrNXYvL1FGTGovLy8vdDZFcUdSalpHR0JNQmtZbUlNSEVnQW9ZRVV4bUZvWmhDUUJ3SFFicUFDRUNlUUFBQUFILy93QUNlTnBqWUdKUVpHQmcxR1NheGNETXdNNmd0NUdSUWQ5bUV6c0x3MXVqald5c2QydzJNVE1CbVF3Ym1VSENyQ0RoVGV4c2pIOXNOakdDeEkwRkZRWFZqUVdWRlJrNW5oODd4alRyYjVvaVV3UURBeE5EOG44MlJtK21kd3ppREJJTURLd202bXFDQXVabXBpYktTbnlNN0d5aUl1SnlUTVpHcG96ZWduTVg4bkt4RzNsTDJ6dEpleG13YzMxZ0ZaekhhTVpvdW9TSGxVc3J3YkpqNVlZT2l4Z05MZ1lHa0ptV1FETVZZV2FxbXFqck1Ta3JBWTBTRXhRQUdXbHNaTWNJdElKUkVXS1M4R3lZeWI4Z1pyQUt6ZjEzNnQ5cHVNbEFJd0dFOWpjekFBQjQybU5nWkdCZ0FHSmVZWHZYZUg2YnJ3emN6TStCSWd5M3R6VnNodE9LLzlrWXZabmVBYmtjREV3Z1VRQW9LUXN2QUFBQWVOcGpZR1JnWUhyM240MGhpckdWQVFnWXZSa1lHVkFCQ3dCWU9BTW9BQUFCaFFBaEFBQUFBQUdGQUFBQmhRQmpBRGtBQUFBQUFDb0FLZ0FxQUZRQWZuamFZMkJrWUdCZ1paQmtZR0lBQVJESnlBQVNjMkRRQXdrQUFBWkZBSlFBZU5wZGpUc093akFNaGo4ZVJid0d4TUNjaFRGVmtyRUg2TUFCT3JLVnFsSWZVdG9qY0F3T3dCazRIVzRJRXNLUzVjLzJiLy9BbWhzenBwaVRzSSs4NE13MWNzS09SK1NWNkYreW5TMDNvdDhHNWNRTExod2pKNXk0UjE1eDRFbERpOGRpb0dtOWxaTFQwekdHNnFrb1VUaFNVU2d5U1M4WCt1ZnVNM1hDT3ZSYTJJUWs3N3N4NzMxVktwY2FsU25mNm1BaTZLeTJSanZqUkZhSWgyZWdEczVLdmt4dUZLVWY2cjVUTnBYbTM1WHZMOTc2OVNnT0FIamFZMkJpUUFhTURPaUFGU3pLeE1ETndBTUFBUlFBSXc9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmxtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVjRBQTBBQUFBQUIwQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZi8wOVRMeklBQUFGTUFBQUFRQUFBQUZaVloxK3JZMjFoY0FBQUFZd0FBQUJNQUFBQlNnUnNDUHBqZG5RZ0FBQUIyQUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUhjQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWVRQUFBSWhBQUFDb0NEQU9jMW9aV0ZrQUFBRUNBQUFBREVBQUFBMkdhQkZGMmhvWldFQUFBUThBQUFBSGdBQUFDUUdHd0wrYUcxMGVBQUFCRndBQUFBWUFBQUFHQXRIQUpWc2IyTmhBQUFFZEFBQUFBNEFBQUFPQWdZQlNtMWhlSEFBQUFTRUFBQUFIZ0FBQUNBQVRnQjZibUZ0WlFBQUJLUUFBQUM4QUFBQkkveTBlTFJ3YjNOMEFBQUZZQUFBQUJnQUFBQXVBRndBSjNqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5RzBRQmNpUWlKQUFCNDJtTmdaTHJGT0lHQmxZR0JxWXRwRHdNRFF3K0VabnpBWU1qSUJCUmxZR1ZtZ0FGR0JpUVFrT2FhQXFRY0dYeVkzdjFuWTRoaU9vTlFBd0R5REFxK2VOclZpc0VOZ0RBTXhIeHQ2UlFNd0JvZ25pek1sOFhDRlZBbFhyeXhsRGlXQW1UdUdSR04xYVdyQzVOZGJaRlkyQ0xjYzNNY3NULy9ScFVlU2w2Sk4rS2JYUG81OEQ5T1EvRUpiQUFoQW5rQUFBQUIvLzhBQW5qYWRaRTliTk5BRk1mZnV6djdmTEhqMnJIeklWS2x0ZDNFTktDMHN2TlJKY0ZGTFJVUmdoYXBpR1ppUVNBeGxxa3NTS2ppUTR5SXFTdHNMQ1FEWXFFU0ErcUNoTHAxWUVXd3NDQWtrS0JSN1NDWXlnMVBkLy8zaHQvdkhoQndBTEJLZG9BQ2g5b0FZYTQ3NUF5K0JnTlordGdkVWhKZllVQ1RXRXJpSVpmeGQzZUlTUjZhanVtSHB1ZWcrTEszUjNZT2J6cWtEOERBQXlENzVEMUVzQWhMc0F4UXJudHV4YWMxNnJrY2RlUTZ5ZHBCTXd4eVlkQ29lNVZHdlJXUlZtaVhNR3Q3cmg3WFhENzgyL2U5SXBMOS9HbUxuRUZrTWpkU28rZVQ3YklpOHhNZDNWdzJMR05PUjlVdC9SSzhKeFRPR2MxZXNiVitPdlAyMDd0cFc5VUtaRk53anViaDY1cEhFWVZRS2JVME5wVXVFTE1kc28wZWN6QWxKQWtwdGIvaGhkRXJpSThNMWRqaE8za0JKMkVXR3RDRTg5QkxQQ3AraEkxNnhYUCtZSVpCdmhTN2NLcGpERTZTeEFtYURXckxwN0FWWVFlRFhIYjhjUDNFMGdxRGVKenNydmZXNzE3ZkdMM1VoS0laV1ZNVm5EMVFpZ3NLRjFRMThNYm1zL0pXLzBuRUo2YnZkWUtGTzFjZkdYSmFXbm5qenVkVEI2MVZaZUxXdWZabEZDbUZFaVJjcHNiaDV5a0RxZUFLZmJ5S2wxWnUveXlxMGV4bzkrSldyQ3RsTUYrb3pGaXhEdmh4Mlk2ZGtyMk1keUp6bWV2c0gxMkVZWkRvZWR4My95dTNTTWkySmtzTVVjOVU1OWVDYXduY1ErNHNaVFRGZUhyZk9rYm9RMGF3TmZaRGxWT1VsS3RuWjRwakxqSlpNb2tpdFBqZmp6Rmg2UU1kamdEdjcydVdBQUFBZU5wallHUmdZQUJpNDEvckpPUDViYjR5Y0RPL0FJb3czTjdXc0JsT0t6SXdNSDFoT2dQa2NqQXdnVVFCV2s0TUF3QUFBSGphWTJCa1lHQTZ3OERBRU1YMEhVZ3lNSDFoWUdSQUJXd0FUV2NESUFBQUFXd0FJUUFBQUFBQlRRQUFBdTRBSXdMM0FDb0NxUUFuQUFBQUtnQXFBQ29BakFEMkFWQUFBSGphWTJCa1lHQmdZL0FFWWhCZ0FtSkdCcENZQTRNZVNBQUFDMndBeVFBQWVOcE5qVTBLd2pBUWhUK3R2eWppU2x3R1hMY2tXZllBUFlDTHJuVVJTNkUvRVBVR0hzTURlQUxQNTZRR01jTXczMlFlN3dFTExvd0liOHljYmVTRUE2ZklVMVk4STgrazNuSWRUWmFpM3d6S3dBa0YrOGhUZGp3aXoxano0b2lqNGs3REdROUhWOTJiczBCQlQ4ZHRtRjRVRG9VbFE4dk1wUnRhcVJyeis3SEM2YkNud25wb2lyNjdGYjJ2bkxLWlZybHEyclkyQWF4SmpVNnR0aUlxeGQxekZiZVFxY1FqNUZBNmY2MzdUcGxNbHY4OHZpNThBTnhBSjd4NDJtTmdZc0FQMklDWWtZR0pRWVZCbFVFZkFBSS9BSVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5Omxtc3k5O2ZvbnQtc2l6ZTo4Ljk2NjM3NnB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpsbW1pOTtmb250LXNpemU6OC45NjYzNzZweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6cm0tbG1yOTtmb250LXNpemU6OC45NjYzNzZweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6cm0tbG10dDEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5Om1zYm0xMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpsbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6bG1taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjcge2ZvbnQtZmFtaWx5OnJtLWxtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnIHRyYW5zZm9ybT0nc2NhbGUoMiAyKSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC41ODU2IDIuNDkwNjkpJz4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTguMDk0MDM3JyB5PSc3LjE2Nzk0NCc+TDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTEuMzEzODknIHk9JzcuMTY3OTQ0Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny40Mzk0MTInIHk9JzcuMTY3OTQ0Jz5aPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00MC43OTc2MycgeT0nNy4xNjc5NDQnPik8L3RleHQ+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMDA0NyA3My4zNTc2NiknPgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01OC4wOTQwMzcnIHk9JzcuMTY3OTQ0Jz5MPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01MS4zMTM4OScgeT0nNy4xNjc5NDQnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ3LjQzOTQxMicgeT0nNy4xNjc5NDQnPlI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTQwLjI0NDE1MicgeT0nNy4xNjc5NDQnPik8L3RleHQ+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzMuODM2NyAtNjguMzc2MzQpJz4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTguMDk0MDM3JyB5PSc3LjE2Nzk0NCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTQuMjE5NTU5JyB5PSc3LjE2Nzk0NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDMuOTgwMjI3JyB5PSc3LjE2Nzk0NCc+4oaSPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMS4yNTAyMjYnIHk9JzcuMTY3OTQ0Jz5tYXliZTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNS4wOTgzNzInIHk9JzcuMTY3OTQ0Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9JzIuOTU4MjM2JyB5PSc3LjE2Nzk0NCc+KTwvdGV4dD4KPC9nPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01OC4wOTQwMzcnIHk9JzcuMTY3OTQ0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNzMuNTcgLTM5LjA4ODk0KSc+TjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTguMDk0MDM3JyB5PSc3LjE2Nzk0NCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTU5LjM5NyAzOC44NjUwNiknPlI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTU4LjA5NDAzNycgeT0nNy4xNjc5NDQnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIwMi4xNCAtNTMuNzA5NzQpJz5Cb29sPC90ZXh0Pgo8cGF0aCBkPSdNLTQ4LjU5Mzc1IDE2LjY3MTg3TDEuMzcxMSA2Ni42MzI4NCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTIuODgyODE3IDY4LjE0NDU2TDEuNTQ2ODgxIDY1LjE4MzYyMUwxLjQ0MTQwOSA2Ni43MDMxNTRMLS4wNzgxMjIgNjYuODA0NzE4WicvPgo8cGF0aCBkPSdNMi44ODI4MTcgNjguMTQ0NTZMMS41NDY4ODEgNjUuMTgzNjIxTDEuNDQxNDA5IDY2LjcwMzE1NEwtLjA3ODEyMiA2Ni44MDQ3MThaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC43MDcxNCAuNzA3MDMgLS43MDcwMyAuNzA3MTQgMTUuNDY5OTQgNjIuNzQ1OTY0KSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU4LjA5NDAzNycgeT0nNy4xNjc5NDQnPm1hcDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzcuNjE1NTM0JyB5PScuNjA4MjY5Jz7iiJo8L3RleHQ+CjxyZWN0IHg9Jy0yOS45MzYwNDknIHk9Jy4yMjk2ODQnIGhlaWdodD0nLjM3ODU4NScgd2lkdGg9JzUuNjMxNjIyJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTI4LjQwMDE1MicgeT0nNy4xNjc5NDQnPsK3PC90ZXh0Pgo8L2c+CjxwYXRoIGQ9J00yOC40OTYxIDcyLjAxNTY0TDkzLjk2OSA0Ni44MjQyNCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTk1Ljk2NDg2NiA0Ni4wNTg1NTRMOTIuNzE0ODc0IDQ2LjA3ODA4NEw5NC4wNjI1MzEgNDYuNzg5MDE4TDkzLjUzOTA5MSA0OC4yMTg3MDlaJy8+CjxwYXRoIGQ9J005NS45NjQ4NjYgNDYuMDU4NTU0TDkyLjcxNDg3NCA0Ni4wNzgwODRMOTQuMDYyNTMxIDQ2Ljc4OTAxOEw5My41MzkwOTEgNDguMjE4NzA5Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0ODgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01OC4wOTQwMzcnIHk9JzcuMTY3OTQ0JyB0cmFuc2Zvcm09J21hdHJpeCguOTMzMjcgLS4zNTkwOSAuMzU5MDkgLjkzMzI3IDEwMy41MTgzNTIgMjkuODMxOTAyKSc+cHJvPHRzcGFuIHg9Jy00NC41MDYwNDEnPmQ8L3RzcGFuPgo8L3RleHQ+CjxwYXRoIGQ9J00zOS4wNDMtNTQuMTc5NjZDNi42MTcyLTE5Ljg1NTQ2LTMuNDAyMyAxOS40MDYyNCA5LjIzNDQgNjUuNjEzMjQnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J005LjgwODU5NiA2Ny42NDQ1MzZMMTAuMDg5ODUxIDY0LjQwNjI1Mkw5LjI1MzkxMSA2NS42ODM2MDFMNy44Nzg5MTQgNjUuMDI3MzQ4WicvPgo8cGF0aCBkPSdNOS44MDg1OTYgNjcuNjQ0NTM2TDEwLjA4OTg1MSA2NC40MDYyNTJMOS4yNTM5MTEgNjUuNjgzNjAxTDcuODc4OTE0IDY1LjAyNzM0OFonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDc2JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguMDk0MDM3JyB5PSc3LjE2Nzk0NCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTYuODAwNzUgLTMuMjc4MjQpJz5nPC90ZXh0Pgo8cGF0aCBkPSdNMTE5LjA3LTI2Ljk5MjE2QzExOC45OC00LjMzNTk2IDExNi42MDUgMTAuMDk3NjYgMTA4LjkxNCAzMS43NzczNCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTEwOC4xODc5OTkgMzMuNzkyOTE4TDExMC4yOTczNzIgMzEuMzE2MzUxTDEwOC44Nzk0MDUgMzEuODc0OTUxTDEwOC4xMzcyMTYgMzAuNTQyOTE0WicvPgo8cGF0aCBkPSdNMTA4LjE4Nzk5OSAzMy43OTI5MThMMTEwLjI5NzM3MiAzMS4zMTYzNTFMMTA4Ljg3OTQwNSAzMS44NzQ5NTFMMTA4LjEzNzIxNiAzMC41NDI5MTRaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3OC4xNzMgLS4zMTAzNSknPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01OC4wOTQwMzcnIHk9Jy42MDgyNjknPuKImjwvdGV4dD4KPHJlY3QgeD0nLTUwLjQxNDU1MycgeT0nLjIyOTY4NCcgaGVpZ2h0PScuMzc4NTg1JyB3aWR0aD0nNS42MzE2MjInLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNDguODc4NjU2JyB5PSc3LjE2Nzk0NCc+wrc8L3RleHQ+CjwvZz4KPHBhdGggZD0nTTExMC45MTgtNDAuNjk5MjZDMTAzLjUyMy00Ny4wMzkwNiA5Ny41MTYtNTAuODUxNTYgODguMDU5LTU0LjcwNzA2JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNODYuMDc0MTc5LTU1LjQ5MjE5OUw4OC40NzY1MjctNTMuMzA0Njk1TDg3Ljk2ODcxMy01NC43NDIxOTlMODkuMzI0MTgzLTU1LjQzNzUxNVonLz4KPHBhdGggZD0nTTg2LjA3NDE3OS01NS40OTIxOTlMODguNDc2NTI3LTUzLjMwNDY5NUw4Ny45Njg3MTMtNTQuNzQyMTk5TDg5LjMyNDE4My01NS40Mzc1MTVaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ3Nicgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU4LjA5NDAzNycgeT0nNy4xNjc5NDQnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1NC4zMTE0IC02MS44MzQ0NCknPmY8L3RleHQ+CjxwYXRoIGQ9J00xMTMuNDQ5IDQxLjExMzI0QzEyNy4yNjIgMzguNjcxODQgMTE5LjUgNTkuNTQyOTQgMTExLjU1MSA1Mi44MzIwNCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTExMC4wOTc3MiA1MS4xODM1NTZMMTExLjI3NzQxNiA1NC4yMTA4OThMMTExLjQ2MTAwNCA1Mi42OTkxODhMMTEyLjk4NDQ0NSA1Mi42NzU3MzlaJy8+CjxwYXRoIGQ9J00xMTAuMDk3NzIgNTEuMTgzNTU2TDExMS4yNzc0MTYgNTQuMjEwODk4TDExMS40NjEwMDQgNTIuNjk5MTg4TDExMi45ODQ0NDUgNTIuNjc1NzM5Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0ODgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01OC4wOTQwMzcnIHk9JzcuMTY3OTQ0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxODEuNjU5IDQ1LjgyODQ2KSc+aWQ8L3RleHQ+CjxwYXRoIGQ9J00xMjEuNTc0LTQzLjcyMjY2QzEyMi40MS01MC42NjAxNiAxMzAuMjUtNTYuODc0OTYgMTM4LjM3OS01Ni42OTEzNicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTE0MC41MDgwMjktNTYuNDQ5MTc5TDEzNy42MDU2ODYtNTcuOTEwMTEyTDEzOC40ODA2OTUtNTYuNjY0MDIzTDEzNy4zNjM1MS01NS42Mjg4NjlaJy8+CjxwYXRoIGQ9J00xNDAuNTA4MDI5LTU2LjQ0OTE3OUwxMzcuNjA1Njg2LTU3LjkxMDExMkwxMzguNDgwNjk1LTU2LjY2NDAyM0wxMzcuMzYzNTEtNTUuNjI4ODY5Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OTInIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01OC4wOTQwMzcnIHk9JzcuMTY3OTQ0JyB0cmFuc2Zvcm09J21hdHJpeCguODM3NDggLS41NDY0IC41NDY0IC44Mzc0OCAxNjUuMzM0MDAxIC05MC40NjUzNjgpJz5vPHRzcGFuIHg9Jy01My4yMzAzMjknPmRkPC90c3Bhbj4KPC90ZXh0Pgo8cGF0aCBkPSdNMTI3LjU3OC0zMi41ODU5NkMxMzQuODMyLTMwLjIyMjY2IDE0My40NTctMzIuODQ3NjYgMTQ4LjgxNi0zOS41ODIwNicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTE1MC4wNDI3NDYtNDEuMzM5ODk4TDE0Ny4zNTEzNC0zOS41MTU2NzdMMTQ4Ljg2Njk1Ny0zOS42NzE5MjZMMTQ5LjIyNjMzNS0zOC4xOTE0NlonLz4KPHBhdGggZD0nTTE1MC4wNDI3NDYtNDEuMzM5ODk4TDE0Ny4zNTEzNC0zOS41MTU2NzdMMTQ4Ljg2Njk1Ny0zOS42NzE5MjZMMTQ5LjIyNjMzNS0zOC4xOTE0NlonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDc4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTguMDk0MDM3JyB5PSc3LjE2Nzk0NCcgdHJhbnNmb3JtPSdtYXRyaXgoLjkyNzU1IC0uMzczNiAuMzczNiAuOTI3NTUgMTg2LjE3MTE0NyAtNTEuNTAzNTQxKSc+ZXY8dHNwYW4geD0nLTQ5LjM4NzEyNCc+ZW48L3RzcGFuPgo8L3RleHQ+CjxwYXRoIGQ9J00tNTIuMzgyODEgMTYuODkwNjJDMTEuOTg0NCAxMjYuMzAwOTQgMTIuNzYxNyAxMjcuNjI0OTQgOTQuNzk3IDUxLjk2MDk0JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNOTYuMzU1NTA2IDUwLjUxOTU3M0w5My4zNDM3OTMgNTEuNzM4MzI3TDk0Ljg1NTUwOSA1MS45MDIzODdMOTQuODk4NDcyIDUzLjQyNTgyNVonLz4KPHBhdGggZD0nTTk2LjM1NTUwNiA1MC41MTk1NzNMOTMuMzQzNzkzIDUxLjczODMyN0w5NC44NTU1MDkgNTEuOTAyMzg3TDk0Ljg5ODQ3MiA1My40MjU4MjVaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4Micgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQwLjM1ODYgMTA3LjUwNjA2KSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU4LjA5NDAzNycgeT0nNy4xNjc5NDQnPnBybzx0c3BhbiB4PSctNDQuNTA2MDQxJz5kPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNy44NTAzNTUnIHk9JzcuMTY3OTQ0Jz7il6Y8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMzLjI0MjY2NScgeT0nNy4xNjc5NDQnPihtYXA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTkuMTgwNTk5JyB5PScuNjA4MjY5Jz7iiJo8L3RleHQ+CjxyZWN0IHg9Jy0xLjUwMTExNCcgeT0nLjIyOTY4NCcgaGVpZ2h0PScuMzc4NTg1JyB3aWR0aD0nNS42MzE2MjInLz4KPHRleHQgY2xhc3M9J2YwJyB4PScuMDM0NzgzJyB5PSc3LjE2Nzk0NCc+wrc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNC4xMzA1MDgnIHk9JzcuMTY3OTQ0Jz4pPC90ZXh0Pgo8L2c+CjxwYXRoIGQ9J00xMTAuNjMzLTMyLjgwNDY2QzYwLjI1LTE3LjgwMDc2IDI5LjE5MTQgMTQuMDU0NjkgMTUuNzY1NiA2NS41NjY0NCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTE1LjI0NjA4OSA2Ny42MjEwOTlMMTcuMTA1NDU4IDY0Ljk1NzAzM0wxNS43NDk5OTcgNjUuNjQ0NTI5TDE0Ljg4MjgxMSA2NC4zOTA2M1onLz4KPHBhdGggZD0nTTE1LjI0NjA4OSA2Ny42MjEwOTlMMTcuMTA1NDU4IDY0Ljk1NzAzM0wxNS43NDk5OTcgNjUuNjQ0NTI5TDE0Ljg4MjgxMSA2NC4zOTA2M1onIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgyJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLjY4NzIxIC0uNzI2MzggLjcyNjM4IC42ODcyMSA3Mi43MTE1MjkgLTM5Ljk4OTM2KSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU4LjA5NDAzNycgeT0nNy4xNjc5NDQnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjMzMDIzNCcgeT0nNy4xNjc5NDQnPuKXpjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDQuNjc0NjgxJyB5PSc3LjE2Nzk0NCc+ZjwvdGV4dD4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></p>
<p>Category theory is not only concerned with categories but also with transformations between them. As in most of mathematics, we study the transformations that preserve the structure of composition and identity, called <em>functors</em>. More precisely, a functor from <span class="math inline">\mathcal{C}</span> to <span class="math inline">\mathcal{D}</span> is comprised of a function taking objects of <span class="math inline">\mathcal{C}</span> to objects of <span class="math inline">\mathcal{D}</span> and a function taking arrows of <span class="math inline">\mathcal{C}</span> to arrows of <span class="math inline">\mathcal{D}</span> (normally both denoted by <span class="math inline">F</span>) such that composition and identities are preserved, <span class="math display"> \begin{aligned}
F(g \circ f) &amp;= F(g) \circ F(f) \\
F(\operatorname{\mathrm{id}}) &amp;= \operatorname{\mathrm{id}}.
\end{aligned}</span> As an example, the type operator <span class="math inline">\mathop{\mathrm{\mathtt{maybe}}}</span> is a functor from <span class="math inline">\mathtt{Types}</span> to itself when coupled with the operation on arrows <span class="math display"> \begin{aligned}
\mathop{\mathrm{\mathtt{maybe}}}(f)(\operatorname{\mathrm{nothing}}) &amp;= \operatorname{\mathrm{nothing}} \\
\mathop{\mathrm{\mathtt{maybe}}}(f)(\operatorname{\mathrm{just}}(x)) &amp;= \operatorname{\mathrm{just}} (f(x)).
\end{aligned} </span> More generally, if a type operator <span class="math inline">G</span> is defined using only products, coproducts, other functors, and function types with the variable appearing only on the right-hand side there is a canonical way to turn it into a functor from <span class="math inline">\mathtt{Types}</span> to itself. Some compilers, such as Haskell’s GHC <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/derive-functor">can even do that automatically for us</a>. Instead of going through the constructions gory details, I think doing an example is better to elucidate how the method. Say we have a type operator <span class="math display"> G X = \operatorname{\mathrm{pig}} A \mid \operatorname{\mathrm{chicken}} A \times X \times (\mathop{\mathrm{\mathtt{maybe}}}X) \mid \operatorname{\mathrm{cow}} B \times (C \to X).</span> To turn it into a functor, we define an action on functions as <span class="math display"> \begin{aligned}
(G\,f)(\operatorname{\mathrm{pig}}(a)) &amp;= \operatorname{\mathrm{pig}}(a) \\
(G\,f)(\operatorname{\mathrm{chicken}}(a, x, m)) &amp;= \operatorname{\mathrm{chicken}}(a, f(x), \mathop{\mathrm{\mathtt{maybe}}}(f)(m)) \\
(G\,f)(\operatorname{\mathrm{cow}}(b, g)) &amp;= \operatorname{\mathrm{cow}}(c, f \circ g)
\end{aligned} </span> Essentially, what <span class="math inline">G\,f</span> does is to unwrap each constructor and pass <span class="math inline">f</span> to each of its arguments according to one of the following rules:</p>
<ol type="1">
<li>If the term if of type <span class="math inline">X</span>, apply <span class="math inline">f</span> to it.</li>
<li>If the term is of type <span class="math inline">(A \to X)</span>, compose <span class="math inline">f</span> with it.</li>
<li>If the term is of type <span class="math inline">F X</span> for some functor <span class="math inline">F</span>, apply <span class="math inline">F\,f</span> to it.</li>
<li>Otherwise, just return the term itself.</li>
</ol>
<h3 id="sec:f-algebras">Functors and their fixed points</h3>
<p>Now we know that both the natural numbers and lists aren’t just the fixed points of ordinary type operators but of functors from <span class="math inline">\mathtt{Types}</span> to itself. But is there anything special in this? As you may expect, the answer is <em>yes</em>. If a type is the fixed point of a functor, then we can define recursion schemes for it that work very much like structural induction. Since this construction works on any category, it won’t bite to do that in full generality. We begin by fixing a category <span class="math inline">\mathcal{C}</span> and a functor <span class="math inline">F</span> from <span class="math inline">\mathcal{C}</span> to itself. From <span class="math inline">F</span>, we will construct an auxiliary category, called the category of <em><span class="math inline">F</span>-algebras</em>.</p>
<p>A <span class="math inline">F</span>-algebra is an object <span class="math inline">X</span> of <span class="math inline">\mathcal{C}</span> together with an arrow <span class="math inline">f \colon F X \to X</span>. Morphisms between <span class="math inline">F</span>-algebras <span class="math inline">f \colon F X \to X</span> and <span class="math inline">g \colon F Y \to Y</span> are given by an arrow <span class="math inline">h \colon X \to Y</span> such that the following diagram commutes</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzMC4yMDU5MzlwdCcgaGVpZ2h0PSc5Mi44MTM3MDNwdCcgdmlld0JveD0nLTEzNS40MjIyNjYgLTEzOS43MTEwODEgMTMwLjIwNTkzOSA5Mi44MTM3MDMnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmxtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFaWUFBMEFBQUFBQ0R3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJvQUFBQWNpeVBnQVU5VEx6SUFBQUZNQUFBQVFnQUFBRlpXT0Y5VVkyMWhjQUFBQVpBQUFBQlFBQUFCU2dlaUNlVmpkblFnQUFBQjRBQUFBQVFBQUFBRUFDRUNlV2RoYzNBQUFBSGtBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBZXdBQUFMdUFBQURuQmJUYWVOb1pXRmtBQUFFM0FBQUFERUFBQUEyR2VoRVFXaG9aV0VBQUFVUUFBQUFJQUFBQUNRR1dBR3RhRzEwZUFBQUJUQUFBQUFjQUFBQUhBeUZBU1ZzYjJOaEFBQUZUQUFBQUJBQUFBQVFBallES20xaGVIQUFBQVZjQUFBQUh3QUFBQ0FBVFFDS2JtRnRaUUFBQlh3QUFBQy9BQUFCSGIwNGtwUndiM04wQUFBR1BBQUFBQm9BQUFBd0FIMEFsbmphWTJCZ1lHUUFnc3ZiN3MwQTBiZTNOV3lCMFFCY2t3aUxBQUI0Mm1OZ1pDcG1uTURBeXNEQTFNVzBoNEdCb1FkQ016NWdNR1JrQW9veXNESXp3QUFqQXhJSVNITk5BVkp1REJsTTcvNnpNVVF4SFdBNEExTURBTm5NQ3pnQUFIamF6WXJiQ1lCQURBUW51VE5WV0lDRnlKVWlWbVVuMWhiWEI0SmYrdW5BWmhrMlFPRk1qN0V6eXV6d3lxQU90ZUUwNWt4NVk4ck1OWmZyWDFod2k3bU84OFQ0U0huWmF4ZjhrdzFwcmdtUkFDRUNlUUFBQUFILy93QUNlTm85a3IxdjAwQVl4dS9EOXZrajl0bU80elFPYVQ2Y3hDbHRBM0ppdTBsS29oWmExQmJFQUJJdEZJRUFNUlNZRVFNU0VtSmdRTXpBeE1TQWhHaUVrTmpZUU14czhBY2dKRWFRRUlSeWx3RFQzVDNQRGMvdmZWNkFRQmtBdUI4OUFoZ1EwTnlGNE1EaWtBamdhN2dyaVo4V2h4aXhLOWpGWEJhNVBDUVMvTFU0aEZ4dldXVXJhRmwrR1NxZjM3NUZqMFpYeW1nVEFBUldBTUE5OUJTY0J1d0prN2p1bHlzR2ROeFdtSjJHR1lkZ0EvcE15RGl0TUc1bFE2Wkg3YnBmQ1pxb1BZQ3QwR1ZmcExFNVFHMi9JaEVEenNLa0QzdVFXeE1ud1lHTk5HZjBKYVVwaHUzWVZCYnV5TGtGVFZWTWVvVWUxK09VUzUxOFRsZGwzTCthVkFpMkZFbUlCVXVWQkJvdlhSNUlSdkhoaFQ1L0kvanhlVVpCcWlNZ0tNcklHWDByVXFpcVZJRFlWWm1HaUtIOVNIdldQZ1ZUbVg1d3FFSTcxWjlUYXJqa3pFQkxvNHgzYmErTnR0RWJzQXFPTWw2T3dqT1RDZU0weTQwbFJ0ZEhZMHFXbndIMzJWaVNORCtqZHBQaHhZeVBqY2RBWXplTzBIWnZ4bDlPRzVaOVF0Y1VSZFBXTjkyRHViVHRDbG5MOVR1TndvS25ORElMRnlmbXVSSVJDdmErZnphNldhNEhWVy90RWxKVjF0ZnY0R0pLOGl6SnpGVHlwYURtbSt1M1lUU3hYbmlXOTk4REFBaGdsckZNd2RkZ0RzeURKYkFNZ0pnK21FeVEvb1lQRThabUlNS1o0bjlJMDRpWEVuQnV2MUtQMm5FU3QwSmVOb1h3NlhVaG8xc2VyaDQrLzJUejlpRlprb25pMm5OSG1zVlMxblI5cjFVdDdOelFDNkxwTFJkcTlVbzZYaW5PR1hqK01IeVpvVmFXZHA3dGJHekZaYS9vZWI1Wkk5UzNuRW8razFmeHFlaWRuUzdXNGhuL2J1bE1vNm9JMmt1R3dQclkyUHVPcnFGWGJBOVhBYWl4RldMcnhITkY3WVFGRGxoaWtrNjR6TWM5aVVrdzRZTlA0Z0VjVjhQU1Q3YVFkNFVpZE0zVVJXaDFpN2xzVlBPNzIwZVBDU2ErSlJIRnk3cFl1Qy9hWnQ0UTlDelNvZXFzbk8zMWFOTHdleVg3Z2M3d3V3Ti9xbk52b1Z2SW40U2hhYWlRamQ0UVJWR3dSKy9kbE9QSnlSYUpTYU80czlwOVhEZURBN09kZVpsaC9BSGYxNGpVQUFCNDJtTmdaR0JnQU9KZE00VHk0L2x0dmpKd003OEFpakRjM3Rhd0JVNHIvamRodG1ZNkFPUnlNRENCUkFGZVJ3eFRBQUFBZU5wallHUmdZRHJ3MzRRaGl1a3FBOFAvT2N6V0RFQVJGTUFPQUlGM0JRa0JiQUFoQUFBQUFBRk5BQUFDMVFCRkFpMEFTUUl0QUNzQ25RQkxBQUFBS2dBcUFDb0FvZ0VJQVdvQnpuamFZMkJrWUdCZ1o0aGtZR0VBQVNZZ1ptUUFpVGt3NklFRUFBenBBTmdBZU5wRmpVMktBakVRaFQvSGZ3ZGtWb1BMNEw2YmREYUNhK2tEdUhBNTRDSTJEZjBEVVEvZ01UeUFCL0NHdmpTQlNhaXFyNmpIZThDQ0N5UGkrMkxPVCtJeFcvNFNUL25tbVhpbTdhM3JhTEtVZmowb0k0ODVzRWs4NVpkSDRoa3JYaHp4Vk54cE9CUGc2S3Q3Y3hhVTlIVGNoaG1rOEJnY09WWnpyMnBvOVd0MmFYY1VaQ3FyN3RSalVmYmRyZXhENVkzTHJkbWJwbTNybmFZcnNzSm16anBwVHJJT1hHVVZBNDBzWWdnbkg2NTEzNWtpMS9JZnhtREJCL3JqSnY0QWVOcGpZR0xBRDlpQm1KR0JpVUdUd1pQQmk4RWJBQVRKQVJRQUFBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpsbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVg4QUEwQUFBQUFCK3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdBVTlUTHpJQUFBRk1BQUFBUUFBQUFGWlZiRjlwWTIxaGNBQUFBWXdBQUFCUEFBQUJTZ09BQi9oamRuUWdBQUFCM0FBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIZ0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlZ0FBQUtoQUFBRFRQckNZdWxvWldGa0FBQUVqQUFBQURFQUFBQTJHZmxFK0dob1pXRUFBQVRBQUFBQUh3QUFBQ1FHV2dLT2FHMTBlQUFBQk9BQUFBQVlBQUFBR0FxOUFJVnNiMk5oQUFBRStBQUFBQTRBQUFBT0FuUUJobTFoZUhBQUFBVUlBQUFBSHdBQUFDQUFTZ0NhYm1GdFpRQUFCU2dBQUFDOEFBQUJJL3kwZUxSd2IzTjBBQUFGNUFBQUFCZ0FBQUF1QUc0QVBYamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUIwUUJja3dpTEFBQjQybU5nWkZyRE9JR0JsWUdCcVl0cER3TURRdytFWm56QVlNaklCQlJsWUdWbWdBRkdCaVFRa09hYUFxVGNHQ0taM3Yxblk0aGlXbzFRQXdEakZ3cUJlTnJWaXRzSmdEQVFCT2VTbUNvc3dFSWtOV2lQdG1CdDYvcEFFSC84ZFdCdm1lV0F6Sm1lWUdlMHhlR0Z3VjNkUWFJeFMvYkdKR25WY3YyYnFOd1N5U2Z4SlBoSWZpMmw0eGRzVlpVSmZBQUFJUUo1QUFBQUFmLy9BQUo0MmsyU3oyc1RRUlRINTcyWjNabk56dTVtczd2NTRiWk5rMjJUTmtKcmswMVdUVTBMQlFYMTRvL1dvSGhRYVBVZ0hyMElSYUZYajE1NkVUeUlJQXJ0eFQraGY0QVhGUStDbDNyUW5nUXROamdicmZReTdMenZ6TENmejNzRVNZVVFhT0Ftb1lTVG1TMGdzL1BibkpGdnpTMWQrelMvVFZGOWtpMmFsclcwdk0xMStEMi9EV205NVZiY2VzdU5LbURzN3V6ZzVzRmFCZnVFSUttcDVUdStKQ3ZrbW5vOTZkU2lTdFdHd00rM21tUG9jMnBETk55M2trS3pIZGRtb1JaVjZ6UFFqaGVnMWN3SHZnTitxOWxaZ0U1YkJUcTM0VGdrUGVoQ21uRTlTTU1FMy90bytJTzh6QWpUemJtQm9XMkk4S1JwQ0dmamFVQVJhQ2tzQlNicjNZckxuRXJPV0VJeHd6V2FuVnU4c2NpZDhZMythWXBTTUlUUHJ6MEJSa1pRb0VMbUR2YktXVEFNU2FuSE5BQkFGQm5oL0FxSzNwZ3BkZWVEcVpuQzZrNE9RamwzSmd3dFRScFpraktIaE5BcitJcmNJWGNKbVl5akdhalRIaWFkcElmdFdGRkVWY1VTK0lVaDNpekVQZVhsYUtEQUM1NUM1WW9YaDRpcWt0cUo2alVsQnN2Z3EzQVlKVTBsc28wZmMzTkY2M0Y0ODV4OTZxeWhjOHRaeUhybmM1NmM4cDVmMWN4UnozZjg1VUQyWmE3UUtJa0g3eWludmVYRGN4Y21kRXFud3JYcnE1b2N5WEd1Tyt0eXhmSThDYklNN1pIVmkvSUVCYVhCcE5RM2tJVk84R2JIWXFaRWRKVVozN1M4d2RjdlZLTkwydUVwcGdNTHM2UDNidS9aVEpvSUtFVHFjT2dtVXN1K2NuT0pYRmJ6RUI5aFZ2MDBvUjYzbWozVi9ZZ2ZVYUU4cFozbmZ3ZW44RzlVL3M5SkovR1NWRzk2RWZlUEpiYTdsUFdjaVhEM3Z0NDFCRmM0ZmVrVkdnWHhrRTJ6VEtsckdweFR0djdJTTkzQXpacDJwSXVmZGxEc2pPdU1VM3lXL3FvczJOWEJENWgyaTVBWklwbFdNSGdyTlh4aE43S0tKNk5wb0txQ0ltb0c2ejdKR3pCcUIwRUpnUW1ka0Q4KzhuZXZBQUFBZU5wallHUmdZQURpaGczUnlmSDhObDhadUpsZkFFVVlibTlyMkFLbnBSa1ltSU9aVmdPNUhBeE1JRkVBVDRvTE9BQUFBSGphWTJCa1lHQmF6Y0RBRU1Wc3c4RHczNXM1bUFFb2dnTFlBRWR4QXU4QUFXd0FJUUFBQUFBQlRRQUFBb01BSmdNOEFCc0NSUUFqQUFBQUtnQXFBQ29BcEFFeUFhWUFBSGphWTJCa1lHQmdZOGhrWUdJQUFSREp5QUFTYzJEUUF3a0FBQTR3QU9VQWVOcE5qVTBLd2pBUWhUK3R2eWppU2x3R1hMY2tXZllBUFlDTHJuVVJTNkUvRVBVR0hzTURlQUxQNTZRR01jTXczMlFlN3dFTExvd0liOHljYmVTRUE2ZklVMVk4STgrazNuSWRUWmFpM3d6S3dBa0YrOGhUZGp3aXoxano0b2lqNGs3REdROUhWOTJiczBCQlQ4ZHRtRjRVRG9VbFE4dk1wUnRhcVJyeis3SEM2YkNud25wb2lyNjdGYjJ2bkxLWlZybHEyclkyQWF4SmpVNnR0aUlxeGQxekZiZVFxY1FqNUZBNmY2MzdUcGxNbHY4OHZpNThBTnhBSjd4NDJtTmdZc0FQMklDWWtZR0pRWlBCbXNFR0FBS25BS3c9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmxtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpsbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMScgdHJhbnNmb3JtPSdzY2FsZSgyIDIpJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjIuNDU2ODMzJyB5PSctNzkuNTk3OTc3JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuMjU0MyAxOS40MjA0KSc+Rjx0c3BhbiB4PSctMTQuNjY2NTc3Jz5YPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzI2LjMzOTE3MScgeT0nLTc5LjU5Nzk3NycgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjczNTQgMTkuNDIwNCknPkY8dHNwYW4geD0nMzQuMTI5NDI3Jz5ZPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yMi40NTY4MzMnIHk9Jy00Ny41NjUzODknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00MS4zNTkyIDE5LjQyMDQpJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzI2LjMzOTE3MScgeT0nLTQ3LjU2NTM4OScgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQwLjg0MDMgMTkuNDIwNCknPlk8L3RleHQ+CjxwYXRoIGQ9J00tNTkuMjk2OS01Ni4zMzIwM1YtMzkuMTk1MzEnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTU2LjkwNjI4LTQxLjA3MDMyQy01OC4zMzk4NzQtNDAuNjkxNDItNTkuMDE5NTYxLTM5Ljg0NzY2Ni01OS4yOTY5MDUtMzguOTk2MTAzQy01OS41NzgxNTUtMzkuODQ3NjY2LTYwLjI1MzkzNi00MC42OTE0Mi02MS42ODc1My00MS4wNzAzMicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzUuMTU5MTM4JyB5PSctNDcuNTY1Mzg5JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzEuMTQ5NSAxLjc0MzUpJz5mPC90ZXh0Pgo8cGF0aCBkPSdNLTQ2LjM5NDUtNjIuNjY4SC0yMy4yODEzJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTS0yNS4xNTYyMy02NS4wNTg2M0MtMjQuNzc3MzItNjMuNjI1MDQxLTIzLjkzMzU3NC02Mi45NDkyNi0yMy4wODIwMTEtNjIuNjY4MDFDLTIzLjkzMzU3NC02Mi4zOTA2NjYtMjQuNzc3MzItNjEuNzEwOTc4LTI1LjE1NjIzLTYwLjI3NzM4JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNS4xNTkxMzgnIHk9Jy00Ny41NjUzODknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Ljg3NTggLTE3LjQ0NzIpJz5GPHRzcGFuIHg9Jy0yOS4wMzQxNTcnPmg8L3RzcGFuPgo8L3RleHQ+CjxwYXRoIGQ9J00tMTAuNS01Ni4zMzIwM1YtMzkuMTk1MzEnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTguMTA5MzQtNDEuMDcwMzJDLTkuNTQ2ODM2LTQwLjY5MTQyLTEwLjIyMjYxNy0zOS44NDc2NjYtMTAuNDk5OTYxLTM4Ljk5NjEwM0MtMTAuNzgxMjExLTM5Ljg0NzY2Ni0xMS40NTY5OTItNDAuNjkxNDItMTIuODkwNTktNDEuMDcwMzInIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM1LjE1OTEzOCcgeT0nLTQ3LjU2NTM4OScgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjcuMDAxNzEgLjgyMzMpJz5nPC90ZXh0Pgo8cGF0aCBkPSdNLTUwLjI5My0zMC42MzY3SC0xOS4zODY3JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTS0yMS4yNjE2OC0zMy4wMjczN0MtMjAuODgyNzctMzEuNTkzNzgtMjAuMDM5MDIyLTMwLjkxNDA5My0xOS4xODc0Ni0zMC42MzY3NDlDLTIwLjAzOTAyMi0zMC4zNTU0OTktMjAuODgyNzctMjkuNjc5NzE4LTIxLjI2MTY4LTI4LjI0NjEyJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNS4xNTkxMzgnIHk9Jy00Ny41NjUzODknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xLjgxMzMgMjQuMTE2NyknPmg8L3RleHQ+CjwvZz4KPC9zdmc+" /></p>
<p>You can check that this definition turns <span class="math inline">F</span>-algebras into a category where the identity for <span class="math inline">f \colon F X \to X</span> is given by <span class="math inline">\operatorname{\mathrm{id}}_X</span> itself. On this category, we are interested in a special kind of object called an <em>initial <span class="math inline">F</span>-algebra</em>. That is a <span class="math inline">F</span>-algebra <span class="math inline">\operatorname{\mathrm{in}}</span> with the special property that for any other <span class="math inline">F</span>-algebra <span class="math inline">f</span> there is a <em>unique</em> morphism going from <span class="math inline">\operatorname{\mathrm{in}}</span> to <span class="math inline">f</span>. Ok, time for some action. We haven’t proved any theorem in this post yet.</p>
<div class="Theorem">
<p>Any initial <span class="math inline">F</span>-algebra <span class="math inline">\operatorname{\mathrm{in}}\colon F I \to I</span> is an isomorphism in <span class="math inline">\mathcal{C}</span>.</p>
</div>
<p>Before we prove this theorem, notice that it implies that <span class="math inline">I</span> is a fixed point of <span class="math inline">F</span>! It’s not every fixed point that defines an initial algebra, but the just the ones that are “smallest” in a certain sense.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> Nevertheless, finite length inductive data structures are generally initial.</p>
<div class="Proof">
<p>First, notice that if <span class="math inline">\operatorname{\mathrm{in}}\colon F I \to I</span> is a <span class="math inline">F</span>-algebra, so is <span class="math inline">F\operatorname{\mathrm{in}}\colon F(FI) \to F I</span>. Since <span class="math inline">\operatorname{\mathrm{in}}</span> is initial, there is a unique arrow <span class="math inline">g \colon I \to FI</span> making the following diagram commute</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE1My40MTMyOTdwdCcgaGVpZ2h0PSc5OS4zODM1OTVwdCcgdmlld0JveD0nLTEzNi40OTE2MjQgLTEzOS43MTExMzIgMTUzLjQxMzI5NyA5OS4zODM1OTUnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmxtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXMEFBMEFBQUFBQjNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJvQUFBQWNpeVBnQTA5VEx6SUFBQUZNQUFBQVFnQUFBRlpXT0Y5RlkyMWhjQUFBQVpBQUFBQlBBQUFCU2dlaEErVmpkblFnQUFBQjRBQUFBQVFBQUFBRUFDRUNlV2RoYzNBQUFBSGtBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBZXdBQUFKVEFBQUMxRmxML2h4b1pXRmtBQUFFUUFBQUFERUFBQUEyR2VoRVEyaG9aV0VBQUFSMEFBQUFJQUFBQUNRR1dBR3JhRzEwZUFBQUJKUUFBQUFXQUFBQUZnZm1BSzlzYjJOaEFBQUVyQUFBQUE0QUFBQU9BallCWEcxaGVIQUFBQVM4QUFBQUh3QUFBQ0FBVEFDS2JtRnRaUUFBQk53QUFBQy9BQUFCSGIwNGtwUndiM04wQUFBRm5BQUFBQmdBQUFBdUFId0FTM2phWTJCZ1lHUUFnc3ZiN3MwQTBiZTNOV3lGMFFCY25RaU5BQUI0Mm1OZ1pFcGxuTURBeXNEQTFNVzBoNEdCb1FkQ016NWdNR1JrQW9veXNESXp3QUFqQXhJSVNITk5BVkp1RE9sTTcvNnpNVVF4SFdBNEExTURBTlV2Q3lrQUFIamF6WXJKRFlBd0VBTm5rNUFxS0lCQ1VFcUJydWlFMm93NWhNUUxub3prdFVaZUlIT21KOWdaYlhGNFlYQlhkNUJvekpLOU1VbGF0VnovSmlxM1JQSkpQQWsra2wvMjB2RlRObVVCQ1lvQUFDRUNlUUFBQUFILy93QUNlTm85a1UxUEUwRVl4NStaMmU0cjNlbnNXMkZMYVhlMzdSYUJTbmJiV1Jxd0JCQU5HT1BGUkRRWURSb09HTS9HRzRueFE4ak5Fd2NUSXcwWGI5N3dBM2pURDJCTVBIb3dpanBMd2RQTS9IOXorUCtlQnpBRUFPZ1NQZ0FDQ25TT0VGeGVHaW9TZkUrTzVNS1hwU0hCNGdwSEpJOExlVHhVWlBSN2FZanlQR1VCaTFNV0JVajdlbktDRDA1M0E3d0ZnR0VkZ0N6aVE3Z0Q0b2t5M29xQzBFU09seWJsS2VRNkNqRlJKQUxYU1JPZWxoT1I5N3F0S0l3N3VMdU0wc1FUWCtRenVJeTdVU2dySnBwQjJRQXRvaHlOU0VaaUN4dk82YmN4UXpNdHg2S3E5RUtkV0RCMHJVUjM2YzBpSC9Pb1U1a282aW9aUE1sQ2hUQk5scmpFZEZtaWZPWHhzbXpXWGowYzVHK01QcjkxTmF3N0VrWUZGVHVuUDJvVTZUcVZFUEYwa1dIRk5IN2FQcHZVQ0ZYcEo0ZHF0Ti80TmE0bks4NDBZZ1lWdmh0L3UzZ2JmNEJyY0YzNDVpcDVaMlhrT0NWNkUxbllEZkNacGVndmhBZGlMSm1kbjcxdVIraHg0U2ZHWStJenludDRlM0U2V3JWTlp0MHFHcHBtR0p0YjN2eUViWGxTbVhsUnYxMWQ4TFcydTdBemd2ZnJpbFMxSmk4d2ZoNjA0b2EvOFFqcnV0alhuM2huVFBhWlhITERTajF1UnFYTmZkUWJvWGMrOC84ekFKQmdScmlNby9jd0MzT3dBcXNBQlhzK0d5bWRsMDh5NFdaaUpYZmlGMHBUT0Y5S25IdEhZYXZYNVJsUGszelpGS0hEcDVKYlpENXByRDE0dmJWL1JaVlZSZk9zMmF1ZFdyMWM4aUkvYlZUM25oV3JoWksvV20yMlFwdXYxMlpOTXJlR2psM0t5clQvWnUvR1hSNzROZCtQU2syRlJzd0pLMjVGSjdkN0h5MjcxdVRUMGN2NnZYWkRrNHhqb2ZBUFFPQnJjZ0I0Mm1OZ1pHQmdBR0s3Vi8vZDQvbHR2akp3TTc4QWlqRGMzdGF3RlU0ci9qZGh0bVk2QU9SeU1EQ0JSQUY0bXd6d0FBQUFlTnBqWUdSZ1lEcnczNFFoaXVrcUE4UC9PY3pXREVBUkZNQUtBSUYxQlFjQmJBQWhBQUFBQUFGTkFBQUMxUUJGQWkwQVNRQXJBQUFBQUFBcUFDb0FLZ0NpQVFnQmFnQUFlTnBqWUdSZ1lHQmppR1JnWVFBQkppQm1aQUNKT1REb2dRUUFETTRBMXdCNDJrV05UWW9DTVJDRlA4ZC9CMlJXZzh2Z3ZwdDBOb0pyNlFPNGNEbmdJallOL1FOUkQrQXhQSUFIOElhK05JRkpxS3F2cU1kN3dJSUxJK0w3WXM1UDRqRmIvaEpQK2VhWmVLYnRyZXRvc3BSK1BTZ2pqem13U1R6bGwwZmlHU3RlSFBGVTNHazRFK0RvcTN0ekZwVDBkTnlHR2FUd0dCdzVWbk92YW1qMWEzWnBkeFJrS3F2dTFHTlI5dDJ0N0VQbGpjdXQyWnVtYmV1ZHBpdXl3bWJPT21sT3NnNWNaUlVEalN4aUNDY2ZyblhmbVNMWDhoL0dZTUVIK3VNbS9nQjQybU5nWXNBUDJJQ1lrWUdKUVpQQms4RUxBQUxmQU1nPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnJtLWxtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJVQUEwQUFBQUFCY2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdBMDlUTHpJQUFBRk1BQUFBUUFBQUFGWlZ0bDdJWTIxaGNBQUFBWXdBQUFCTUFBQUJTZ1NJQkNaamRuUWdBQUFCMkFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIY0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlUUFBQUVMQUFBQk9GdHlZWTFvWldGa0FBQUM4QUFBQURFQUFBQTJHUHBFNkdob1pXRUFBQU1rQUFBQUhnQUFBQ1FGUXdKOWFHMTBlQUFBQTBRQUFBQVVBQUFBRkFaeUFJOXNiMk5oQUFBRFdBQUFBQXdBQUFBTUFJZ0E4RzFoZUhBQUFBTmtBQUFBSHdBQUFDQUFTd0JmYm1GdFpRQUFBNFFBQUFDMkFBQUJJSVhtSG5kd2IzTjBBQUFFUEFBQUFCWUFBQUFzQUZRQVUzamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUYwUUJjblFpTkFBQjQybU5nWkx6TE9JR0JsWUdCcVpOcE53TURRemVFWnJ6UFlNaklCQlJsWUdWbWdBRkdCaVFRa09hYUFxUXlHZktZSmY4Yk1VUXh6VUtvQVFEcFFBb3FlTnBqWUdCZ1pvQmdHUVpHQmhCd0FmSVl3WHdXQmcwZ3pRYWtHUm1ZR0RJWjh2Ny9CL0xCOVA5Wi82ZEIxUU1CSXhzRG5NUElCQ1NZR0ZBQkl3UDFBTWl0UUNjTk5nQUFrWVVKcndBaEFua0FBQUFCLy84QUFuamFZMkJpVUdSZ1lOUmttc1hBek1ET29MZVJrVUhmWmhNN0M4TmJvNDFzckhkc05qRXpBWmtNRzVsQndxd2c0VTNzYkl4L2JEWXhnc1NOQlJVRjFZMEZsUlVaT1o0Zk84WTA2MithSWxNRUF3TUxnd1hRVENHbUtReENETUlNOGd3S0RBeUtwa3BxcG9Mc29rWmlvb0lpYk1xaVpzWkc0c3dtYXNwS2JLSWlZc1pHWnFhTVFucGlrdzBrSkl3OU5LejF6UlVsSkJWQVdJVkhqakdiVzBWSTlkOGZlUjRWRmhhbUtBa2xKWEVRWmdBQ0pnWXpJT0hIdUpOQmgwRVhZb2N0bzRteUVydXlLYXBORUFrZ1MweVdFU2JHNUdjc01TM2ZoSEd5a1NUUVVpMS9GV09KV0F0OUJRaGJoVWYrUVZkaUlyZUtzT3EvdjJDYmdTSmJQQU90REo2QWVRd0E1dWM0a3dCNDJtTmdaR0JnQU9MZG91cVg0dmx0dmpKd016OEhpakRjM3Rhd0ZVNHJNakF3K1RITkFuSTVHSmhBb2dCSUFRc0RBQUFBZU5wallHUmdZSnJGd01BUXhWUU9KQm1ZL0JnWUdWQUJLd0F1aGdISEFBQUJhd0FoQUFBQUFBRk5BQUFCUXdBNEFuY0FOZ0FBQUNvQUtnQXFBRjRBbkhqYVkyQmtZR0JnWmRCallHRUFBU1lnWm1RQWlUa0F4WUFBQUFpQUFLc0FlTnBWalUwS3dqQVFSbCsxclZWQmQ2NnpjSnVTWkNQMEFNVVRGRHhBbFVKL0lIYnRNVHlBUi9DRVRtc1FERXptemN3Mzh3RVpWeUttdHlCbUUzakprVXZnaEMzUHdDa3IzaktONHJYb3MxazU4Wkl6KzhBSkJ4NkJVM2E4YU9ud25LRHR2UHdsQXozam5EMDNhaFNPSENPNWtQQWkxNytsYjg5aHBXZEZvNFhOSEpSRFA1YUR2OVhLNVVZVnluZDZjaEJ5Vmx1am5YR2lxc1RBYzZlWmJaVWNtYXlvYW45dmhsN1pYSXAvUzhJaFByazNKdVVBQUhqYVkyQml3QTlZZ1ppUmdZbkJoeUVRQUFIL0FLZ0FBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6cm0tbG1yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFrQUEwQUFBQUFCWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdBMDlUTHpJQUFBRk1BQUFBUWdBQUFGWldjVjZIWTIxaGNBQUFBWkFBQUFCRUFBQUJRZ0FQQnRoamRuUWdBQUFCMUFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIWUFBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlQUFBQURlQUFBQS9LQnlRZ1pvWldGa0FBQUN3QUFBQURFQUFBQTJGL2hFUW1ob1pXRUFBQUwwQUFBQUhnQUFBQ1FFbFFDUWFHMTBlQUFBQXhRQUFBQVNBQUFBRWdUSUFJUnNiMk5oQUFBREtBQUFBQXdBQUFBTUFINEEwbTFoZUhBQUFBTTBBQUFBSHdBQUFDQUFTUUJLYm1GdFpRQUFBMVFBQUFDM0FBQUJLUjlNTTVGd2IzTjBBQUFFREFBQUFCZ0FBQUFzQUJNQUQzamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUYwUUJjblFpTkFBQjQybU5nWkd4bG5NREF5c0RBMU1tMG00R0JvUnRDTTk1bk1HUmtBb295c0hJeXdBQWpBeElJU0hOTkFWSWFESnJNMHY5TkdLS1kzakg4Z3FrQkFOQWNDcVFBQUhqYVkyQmdZR2FBWUJrR1JnWVFzQUh5R01GOEZnWUZJTTBDaENDKzV2Ly9RRkxqLy8vL3Q2RXFHUmpaR0dCTUJrWW1JTUhFZ0FvWUVVeG1Gb1poQ1FCd0hRYnFBQ0VDZVFBQUFBSC8vd0FDZU5wallHSlFaR0JnMUdTYXhjRE13TTZndDVHUlFkOW1FenNMdzF1ampXeXNkMncyTVRNQm1Rd2JtVUhDckNEaFRleHNqSDlzTmpHQ3hJMEZGUVhWalFXVkZSazVuaDg3eGpUcmI1b2lVd1FEQXhORDhuODJSbSttZHd6aURCSU1ES3dtNm1xQ0F1Wm1waWJLU255TTdHeWlJdUp5VE1aR3BvemVnbk1YOG5LeEczbEwyenRKZXhtd2MzMWdGWnpIYU1ab3VvU0hsVXNyd2JKajVZWU9peGdOTGdZR2tKbVdRRE1WWVdhcW1xanJNU2tyQVkwU0V4UUFHV2xzWk1jSXRJSlJFV0tTOEd5WXliOGdackFLemYxMzZ0OXB1TWxBSXdHRTlqY3pBQUI0Mm1OZ1pHQmdBR0plWVh2VGVINmJyd3pjek0rQklneTN0elZzaGRPSy85a1l2Wm5lQWJrY0RFd2dVUUFsMVFzakFBQUFlTnBqWUdSZ1lIcjNuNDBoaXJHVkFRZ1l2UmtZR1ZBQkN3QllPQU1vQUFBQmhRQWhBQUFBQUFHRkFBQUJoUUJqQURrQUFBQUFBQ29BS2dBcUFGUUFmbmphWTJCa1lHQmdaWkJrWUdJQUFSREp5QUFTYzJEUUF3a0FBQVpGQUpRQWVOcGRqVHNPd2pBTWhqOGVSYndHeE1DY2hURlZrckVINk1BQk9yS1ZxbElmVXRvamNBd093Qms0SFc0SUVzS1M1Yy8yYi8vQW1oc3pwcGlUc0krODRNdzFjc0tPUitTVjZGK3luUzAzb3Q4RzVjUUxMaHdqSjV5NFIxNXg0RWxEaThkaW9HbTlsWkxUMHpHRzZxa29VVGhTVVNneVNTOFgrdWZ1TTNYQ092UmEySVFrNzdzeDczMVZLcGNhbFNuZjZtQWk2S3kyUmp2alJGYUloMmVnRHM1S3ZreHVGS1VmNnI1VE5wWG0zNVh2TDk3NjlTZ09BSGphWTJCaVFBYU1ET2lBRlN6S3hNRE53QU1BQVJRQUl3PT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpsbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdJQUEwQUFBQUFCMkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdBMDlUTHpJQUFBRk1BQUFBUUFBQUFGWlZiRjduWTIxaGNBQUFBWXdBQUFCUEFBQUJVZ05pQkh4amRuUWdBQUFCM0FBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIZ0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlZ0FBQUl3QUFBQ3VIWHl1MTlvWldGa0FBQUVHQUFBQURFQUFBQTJHYVpFK21ob1pXRUFBQVJNQUFBQUlBQUFBQ1FHQVFIVmFHMTBlQUFBQkd3QUFBQVlBQUFBR0FrNUFJeHNiMk5oQUFBRWhBQUFBQTRBQUFBT0Fpb0JQRzFoZUhBQUFBU1VBQUFBSHdBQUFDQUFTZ0NKYm1GdFpRQUFCTFFBQUFDOEFBQUJJL3kwZUxSd2IzTjBBQUFGY0FBQUFCZ0FBQUF1QUc0QUxuamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUYwUUJjblFpTkFBQjQybU5nWk5KaW5NREF5c0RBMU1XMGg0R0JvUWRDTXo1Z01HUmtBb295c0RJendBQWpBeElJU0hOTkFWSnVESkZNNy82ek1VUXhyVWFvQVFDNDhRbi9lTnBqWUdCZ1pvQmdHUVpHQmhEd0FmSVl3WHdXQmdNZ3pRR0VURURhamNHVElmTC9md1RyLzk3L3UvK3ZnZW9DQTBZMkJqaVhFYVNIaVFFVk1ESVFDWUFPWWtFVFltVVlFZ0FBSENVTDNnQUFJUUo1QUFBQUFmLy9BQUo0MmxXUk1XOFRNUlRIL1o1OVovdnMzT1Z5ZDdtRzBLYTVvNGxhb0ZXVGE2NGlKYTNFamdRRFZHSmlZZVFMSUZWSWhESXhzblJoUTBpSW9WbjRDUDBLSURHd0lIVUJ4SUFFRlkyd1U0ckU4bVQvbit6MysvOGZRZEltQkZid2dGREN5ZW9oa0xXdENXZmtTKy9RZFQ1dVRTaWFJem1rVm5hc1BPRXUvTjZhZ05YN1lUdnM5c084RGZMNDZBZ1BUaCswY1pjUUpCMVR2dUpyY29mY05iK1hnMDdlem54STRucS90NEF4cHo3a3MzdS9USHNiUldjTk9ubldYWVdOWWh2NnZYb1NCeEQzZTROdEdHeVloc3Q5dUF6bENJWmdlOXhOYkxQRTl6SEtlRnJYbmxCaExVeWtNeGJOVFNWRk1INlJVQVRhYURZU3hVYjNpeGFubWpOV1V2UzRRNnZyTy9kMmVMQTQzcjFHVVF1RzhPbHRKRUI2Z2dJVnVuYjZyVlVGS1RXbEVYTUFBRkY0SXZpVnpFVUxTcnZCQitVb1VSa3VUWnQ2L1hxeldYRzByQkxyT1ROT3YrTWJjb1ZjSldTcE9ITlVsTkhJV0JvWmF6bnZack1FcklmL0U0Q2J1cGJHZ2NmMitjVk5YL0ZnL0RSV1lhZUZ6K3pkVEgreUgwZVdsTmQ4VE9aREZCWXZGdFN0Y0huNmVjRUluaks4TTQ3Y2xCUERjWXZjTmtSRjV1YVpZYkdabWJrS3VzVTV6cmxjVHlPRFpGUG1aMHRLLzY3bDMwNEdaVlNPc0J6WWgzaHlvZlRERzlVb3VOUThmdWdPcGVEQm50N1ZVYnFTaWtkc21YbU5vWktjVTdiM09GSmhFbGFWbjd2aXA1L01EUlpkeGltK3ROSHExTSttUDJBNW5BTlBHdlpZVlpMcE8rM2dLMytsQ3NhUDQ4RE1JcUlqMmZCNVhjSzhueVFOQkNaY1F2NEFjaTVqT0hqYVkyQmtZR0FBNHY3NjdlN3gvRFpmR2JpWlh3QkZHRzV2YTlnS3B4VVpHSmgrTWEwR2Nqa1ltRUNpQUYyOERBUUFBQUI0Mm1OZ1pHQmdXczNBd0JERjFNekE4TitiNlJjRFVBUUZzQUVBV3BjRDJ3RnNBQ0VBQUFBQUFVMEFBQUtEQUNZQnVBQWlBa1VBSXdBQUFDb0FLZ0FxQUtRQTZBRmNBQUI0Mm1OZ1pHQmdZR09JWUdCaUFBRVF5Y2dBRW5OZzBBTUpBQUFNaHdEVUFIamFUWTFOQ3NJd0VJVS9yYjhvNGtwY0JseTNKRm4yQUQyQWk2NTFFVXVoUHhEMUJoN0RBM2dDeitla0JqSERNTjlrSHU4QkN5Nk1DRy9Nbkcza2hBT255Rk5XUENQUHBONXlIVTJXb3Q4TXlzQUpCZnZJVTNZOElzOVk4K0tJbytKT3d4a1BSMWZkbTdOQVFVL0hiWmhlRkE2RkpVUEx6S1ViV3FrYTgvdXh3dW13cDhKNmFJcSt1eFc5cjV5eW1WYTVhdHEyTmdHc1NZMU9yYllpS3NYZGN4VzNrS25FSStSUU9uK3QrMDZaVEpiL1BMNHVmQURjUUNlOGVOcGpZR0xBRDlpQW1KR0JpVUdUUVlmQkJnQUNlZ0NkKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmxtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpsbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6cm0tbG1yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6cm0tbG1yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMScgdHJhbnNmb3JtPSdzY2FsZSgyIDIpJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTkuOTc5ODg1JyB5PSctNzkuODk2ODQ0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDcuNzMxMyAyMC45OTc5KSc+Rjx0c3BhbiB4PSctMTIuMTg5NjI5Jz5JPC90c3Bhbj4KPC90ZXh0Pgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTUuNTAxIDIwLjk5NzkpJz4KPHRleHQgY2xhc3M9J2YxJyB4PSczMy4yMzAyNDUnIHk9Jy03OS44OTY4NDQnPkY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNDEuMDIwNTAxJyB5PSctNzkuODk2ODQ0Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzQ0Ljg5NDk3OScgeT0nLTc5Ljg5Njg0NCc+Rjx0c3BhbiB4PSc1Mi42ODUyMzUnPkk8L3RzcGFuPgo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNTcuODQ2NDI3JyB5PSctNzkuODk2ODQ0Jz4pPC90ZXh0Pgo8L2c+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE5Ljk3OTg4NScgeT0nLTQ1LjM3MzU5NicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQzLjgzNjEgMjAuOTk3OSknPkk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMzMuMjMwMjQ1JyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuMjU0NCAyMC45OTc5KSc+WTwvdGV4dD4KPHBhdGggZD0nTS02MS4yMzQ0LTU1LjA1NDY5Vi0zNS40MjU3OCcgc3Ryb2tlPScjZjAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtZGFzaGFycmF5PScyLjc4OTQxLDEuNTkzOTUnLz4KPHBhdGggZD0nTS01OC44NDM4LTM3LjMwMDc0Qy02MC4yNzczOTEtMzYuOTIxODMtNjAuOTU3MDc5LTM2LjA3ODA4My02MS4yMzQ0MjMtMzUuMjI2NTIxQy02MS41MTU2NzMtMzYuMDc4MDgzLTYyLjE5MTQ1NC0zNi45MjE4My02My42MjUwNS0zNy4zMDA3NCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzAuNzQ1MDEyJyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzcuNTAwOCAyLjA3NTYpJz5mPC90ZXh0Pgo8cGF0aCBkPSdNLTUwLjI2OTUtNjEuMzkwNkgtMjcuMTU2MjUnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTI5LjAzMTI1LTYzLjc4MTI1Qy0yOC42NTIzNC02Mi4zNDc2NTgtMjcuODA4NTkzLTYxLjY2Nzk3LTI2Ljk1NzAzLTYxLjM5MDYyNkMtMjcuODA4NTkzLTYxLjEwOTM3Ni0yOC42NTIzNC02MC40MzM1OTUtMjkuMDMxMjUtNTknIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTMwLjc0NTAxMicgeT0nLTQ1LjM3MzU5NicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEyLjkwMDcgLTE5LjcxNjUpJz5GPHRzcGFuIHg9Jy0yNC42MjAwMyc+ZzwvdHNwYW4+CjwvdGV4dD4KPHBhdGggZD0nTS04LjAyMzQtNTIuNTYyNVYtMzUuNDI1NzgnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTUuNjMyODEtMzcuMzAwNzRDLTcuMDY2NDA2LTM2LjkyMTgzLTcuNzQ2MDkzLTM2LjA3ODA4My04LjAyMzQzNy0zNS4yMjY1MjFDLTguMzA0Njg3LTM2LjA3ODA4My04Ljk4MDQ2OC0zNi45MjE4My0xMC40MTQwNi0zNy4zMDA3NCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzAuNzQ1MDEyJyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS4wNjQ1MSAzLjk2MDIpJz5GPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy4yNTkzOTUnIHk9Jy00NS4zNzM1OTYnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1LjA2NDUxIDMuOTYwMiknPmluPC90ZXh0Pgo8cGF0aCBkPSdNLTU0LjE2NDEtMjYuODY3MkgtMTYuOTEwMicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtZGFzaGFycmF5PScyLjc4OTQxLDEuNTkzOTUnLz4KPHBhdGggZD0nTS0xOC43ODUxMS0yOS4yNTc4Qy0xOC40MDYyLTI3LjgyNDIwOS0xNy41NjI0NTEtMjcuMTQ0NTIyLTE2LjcxMDg4OC0yNi44NjcxNzhDLTE3LjU2MjQ1MS0yNi41ODU5MjgtMTguNDA2Mi0yNS45MTAxNDctMTguNzg1MTEtMjQuNDc2NTUnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTMwLjc0NTAxMicgeT0nLTQ1LjM3MzU5NicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYuNjYyNSAyMy44NTM4KSc+ZzwvdGV4dD4KPC9nPgo8L3N2Zz4K" /></p>
<p>Since <span class="math inline">\operatorname{\mathrm{in}}</span> itself may be viewed as a morphism between the <span class="math inline">F</span>-algebras <span class="math inline">F \operatorname{\mathrm{in}}</span> and <span class="math inline">\operatorname{\mathrm{in}}</span>, we get that their composition is a morphism from <span class="math inline">\operatorname{\mathrm{in}}</span> to itself represented by the following diagram, where all paths still commute</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0OC44NDIwNDNwdCcgaGVpZ2h0PSc5OS42NTQ1NHB0JyB2aWV3Qm94PSctMTM5LjcxMjE5OCAtMTM5LjcxMTEzMiAyNDguODQyMDQzIDk5LjY1NDU0Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpsbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWdBQTBBQUFBQUJwZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZ0JVOVRMeklBQUFGTUFBQUFRZ0FBQUZaV09GOUlZMjFoY0FBQUFaQUFBQUJNQUFBQlNnT2hBK1JqZG5RZ0FBQUIzQUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUhnQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWVnQUFBSE1BQUFDQ0hJZUF2NW9aV0ZrQUFBRHRBQUFBREVBQUFBMkdlaEVMR2hvWldFQUFBUG9BQUFBSUFBQUFDUUdQd0dyYUcxMGVBQUFCQWdBQUFBVUFBQUFGQWU3QUpGc2IyTmhBQUFFSEFBQUFBd0FBQUFNQU13QldHMWhlSEFBQUFRb0FBQUFId0FBQUNBQVN3Q0tibUZ0WlFBQUJFZ0FBQUMvQUFBQkhiMDRrcFJ3YjNOMEFBQUZDQUFBQUJZQUFBQXNBREVBVEhqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5RDBRQmNwd2lQQUFCNDJtTmdaR3Brbk1EQXlzREExTVcwaDRHQm9RZENNejVnTUdSa0Fvb3lzREl6d0FBakF4SUlTSE5OQVZKdURPbE03LzZ6TVVReExXYzRBMU1EQU4wd0N5d0FBSGphWTJCZ1lHYUFZQmtHUmdZUWNBSHlHTUY4RmdZTklNMEdwQmtabUJqY0dOTC8vd2Z5d2ZUL3ZmL25RdFVEQVNNYkE1ekR5QVFrbUJoUUFTTURrWUNaa0FJV2hrRUtBR0lHQ1lVQUlRSjVBQUFBQWYvL0FBSjQyaVdRUFcvVFVCU0d6N25YOGZWSDR4czcxMDdya0xyMnpRZWxhVUMyYzAzVmtDZ3RuUkFiRW9VRkJ0U2hpSmtWQ2ZFajZNYlVBUWtwVVJkK1Fma0JiUEFERUJJakE0SUk3TEljbmZkNXovSWNJQkFENEExeUJoUVlqQllJTnlkTHBzR1BkS0hYdms2V2xKUXJMR2lGYXhWZU1oMy9USlpZOGN5TjNVSG15aGpOYjVlWDVHeDFFcE5qQUFKSEFIU2ZuTU5ES0NNV3FpL2p4RUVSWkdsckUzM0JxSU95Qkw3SVVwVzEwcEtQODc1TUJpT1N6ekJMZy9KRXZ5cG5KSmVKemh6Y3dXS0srMWhWLzV1Q0RqeGlpOVgzTmR0MFBPRnhRM3R0Yk55MkxiUEJUL2o5dWxvTHVHaHYxQzJEVHA4WENhT3VxV3RLY3kxZDQycitiS1k3MGR1bjB5b1QvUExCTjRrbE5JSTFnNGpWejRpalpYRU5hV0NWakRESC90VU0zV3NtNVFiL0xMako5N3EvMTYxMExyYlJ0VGxvc1BNM0ordjRFWWF3QzNNNEFLZzFieFdWa2M2cTRZc2dMUnhrRG1GNmFhbXVaRXU2U1NxUlFlVW5rLzQ0VjRYSzB1cEJIUEg4aGViWDNaQjJENSs4TzM1MXg5QU5aZ2JlOE80bzJtbzFBaGxtM2M3cHkzcW4xZ2dQT3IxKzBsUkgwZENodTRkNDRYTzN4ZmZlbjk1N3BPSXdDa1BaNkRFdVhaRzAvYlpGSDR3L2VjMm9wN2JsbTYzSDE3dW1abDhBd0QvbjBWRldlTnBqWUdSZ1lBQmlTYXRmbXZIOE5sOFp1SmxmQUVVWWJtOXIyQWFuRmYrYk1Gc3pMUWR5T1JpWVFLSUFURG9MNFFBQUFIamFZMkJrWUdCYS90K0VJWXJwS2dQRC96bk0xZ3hBRVJUQUNnQitiZ1R1QVd3QUlRQUFBQUFCVFFBQUF0VUFSUUl0QUNzQUFBQXFBQ29BS2dDaUFRUjQybU5nWkdCZ1lHV0laR0JoQUFFbUlHWmtBSWs1TU9pQkJBQU1zd0RXQUhqYVJZMU5pZ0l4RUlVL3gzOEhaRmFEeStDK20zUTJnbXZwQTdod09lQWlOZzM5QTFFUDRERThnQWZ3aHI0MGdVbW9xcStveDN2QWdnc2o0dnRpemsvaU1WditFay81NXBsNHB1MnQ2Mml5bEg0OUtDT1BPYkJKUE9XWFIrSVpLMTRjOFZUY2FUZ1Q0T2lyZTNNV2xQUjAzSVlacFBBWUhEbFdjNjlxYVBWcmRtbDNGR1FxcSs3VVkxSDIzYTNzUStXTnk2M1ptNlp0NjUybUs3TENaczQ2YVU2eURseGxGUU9OTEdJSUp4K3VkZCtaSXRmeUg4Wmd3UWY2NHliK0FIamFZMkJpd0E5WWdaaVJnWWxCazhFTEFBR1BBSDRBQUE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnJtLWxtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJVQUEwQUFBQUFCY2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdCVTlUTHpJQUFBRk1BQUFBUUFBQUFGWlZ0bDdJWTIxaGNBQUFBWXdBQUFCTUFBQUJTZ1NJQkNaamRuUWdBQUFCMkFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIY0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlUUFBQUVMQUFBQk9GdHlZWTFvWldGa0FBQUM4QUFBQURFQUFBQTJHUHBFNm1ob1pXRUFBQU1rQUFBQUhnQUFBQ1FGUXdKOWFHMTBlQUFBQTBRQUFBQVVBQUFBRkFaeUFJOXNiMk5oQUFBRFdBQUFBQXdBQUFBTUFJZ0E4RzFoZUhBQUFBTmtBQUFBSHdBQUFDQUFTd0JmYm1GdFpRQUFBNFFBQUFDMkFBQUJJSVhtSG5kd2IzTjBBQUFFUEFBQUFCWUFBQUFzQUZRQVUzamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUQwUUJjcHdpUEFBQjQybU5nWkx6TE9JR0JsWUdCcVpOcE53TURRemVFWnJ6UFlNaklCQlJsWUdWbWdBRkdCaVFRa09hYUFxUXlHZktZSmY4Yk1VUXh6VUtvQVFEcFFBb3FlTnBqWUdCZ1pvQmdHUVpHQmhCd0FmSVl3WHdXQmcwZ3pRYWtHUm1ZR0RJWjh2Ny9CL0xCOVA5Wi82ZEIxUU1CSXhzRG5NUElCQ1NZR0ZBQkl3UDFBTWl0UUNjTk5nQUFrWVVKcndBaEFua0FBQUFCLy84QUFuamFZMkJpVUdSZ1lOUmttc1hBek1ET29MZVJrVUhmWmhNN0M4TmJvNDFzckhkc05qRXpBWmtNRzVsQndxd2c0VTNzYkl4L2JEWXhnc1NOQlJVRjFZMEZsUlVaT1o0Zk84WTA2MithSWxNRUF3TUxnd1hRVENHbUtReENETUlNOGd3S0RBeUtwa3BxcG9Mc29rWmlvb0lpYk1xaVpzWkc0c3dtYXNwS2JLSWlZc1pHWnFhTVFucGlrdzBrSkl3OU5LejF6UlVsSkJWQVdJVkhqakdiVzBWSTlkOGZlUjRWRmhhbUtBa2xKWEVRWmdBQ0pnWXpJT0hIdUpOQmgwRVhZb2N0bzRteUVydXlLYXBORUFrZ1MweVdFU2JHNUdjc01TM2ZoSEd5a1NUUVVpMS9GV09KV0F0OUJRaGJoVWYrUVZkaUlyZUtzT3EvdjJDYmdTSmJQQU90REo2QWVRd0E1dWM0a3dCNDJtTmdaR0JnQU9MZG91cW40dmx0dmpKd016OEhpakRjM3Rhd0RVNHJNakF3K1RITkFuSTVHSmhBb2dCRzF3cjlBQUFBZU5wallHUmdZSnJGd01BUXhWUU9KQm1ZL0JnWUdWQUJLd0F1aGdISEFBQUJhd0FoQUFBQUFBRk5BQUFCUXdBNEFuY0FOZ0FBQUNvQUtnQXFBRjRBbkhqYVkyQmtZR0JnWmRCallHRUFBU1lnWm1RQWlUa0F4WUFBQUFpQUFLc0FlTnBWalUwS3dqQVFSbCsxclZWQmQ2NnpjSnVTWkNQMEFNVVRGRHhBbFVKL0lIYnRNVHlBUi9DRVRtc1FERXptemN3Mzh3RVpWeUttdHlCbUUzakprVXZnaEMzUHdDa3IzaktONHJYb3MxazU4Wkl6KzhBSkJ4NkJVM2E4YU9ud25LRHR2UHdsQXozam5EMDNhaFNPSENPNWtQQWkxNytsYjg5aHBXZEZvNFhOSEpSRFA1YUR2OVhLNVVZVnluZDZjaEJ5Vmx1am5YR2lxc1RBYzZlWmJaVWNtYXlvYW45dmhsN1pYSXAvUzhJaFByazNKdVVBQUhqYVkyQml3QTlZZ1ppUmdZbkJoeUVRQUFIL0FLZ0FBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6cm0tbG1yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFrQUEwQUFBQUFCWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdCVTlUTHpJQUFBRk1BQUFBUWdBQUFGWldjVjZIWTIxaGNBQUFBWkFBQUFCRUFBQUJRZ0FQQnRoamRuUWdBQUFCMUFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIWUFBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlQUFBQURlQUFBQS9LQnlRZ1pvWldGa0FBQUN3QUFBQURFQUFBQTJGL2hFUkdob1pXRUFBQUwwQUFBQUhnQUFBQ1FFbFFDUWFHMTBlQUFBQXhRQUFBQVNBQUFBRWdUSUFJUnNiMk5oQUFBREtBQUFBQXdBQUFBTUFINEEwbTFoZUhBQUFBTTBBQUFBSHdBQUFDQUFTUUJLYm1GdFpRQUFBMVFBQUFDM0FBQUJLUjlNTTVGd2IzTjBBQUFFREFBQUFCZ0FBQUFzQUJNQUQzamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUQwUUJjcHdpUEFBQjQybU5nWkd4bG5NREF5c0RBMU1tMG00R0JvUnRDTTk1bk1HUmtBb295c0hJeXdBQWpBeElJU0hOTkFWSWFESnJNMHY5TkdLS1kzakg4Z3FrQkFOQWNDcVFBQUhqYVkyQmdZR2FBWUJrR1JnWVFzQUh5R01GOEZnWUZJTTBDaENDKzV2Ly9RRkxqLy8vL3Q2RXFHUmpaR0dCTUJrWW1JTUhFZ0FvWUVVeG1Gb1poQ1FCd0hRYnFBQ0VDZVFBQUFBSC8vd0FDZU5wallHSlFaR0JnMUdTYXhjRE13TTZndDVHUlFkOW1FenNMdzF1ampXeXNkMncyTVRNQm1Rd2JtVUhDckNEaFRleHNqSDlzTmpHQ3hJMEZGUVhWalFXVkZSazVuaDg3eGpUcmI1b2lVd1FEQXhORDhuODJSbSttZHd6aURCSU1ES3dtNm1xQ0F1Wm1waWJLU255TTdHeWlJdUp5VE1aR3BvemVnbk1YOG5LeEczbEwyenRKZXhtd2MzMWdGWnpIYU1ab3VvU0hsVXNyd2JKajVZWU9peGdOTGdZR2tKbVdRRE1WWVdhcW1xanJNU2tyQVkwU0V4UUFHV2xzWk1jSXRJSlJFV0tTOEd5WXliOGdackFLemYxMzZ0OXB1TWxBSXdHRTlqY3pBQUI0Mm1OZ1pHQmdBR0plWVh2ZGVINmJyd3pjek0rQklneTN0elZzZzlPSy85a1l2Wm5lQWJrY0RFd2dVUUFrcXdzZEFBQUFlTnBqWUdSZ1lIcjNuNDBoaXJHVkFRZ1l2UmtZR1ZBQkN3QllPQU1vQUFBQmhRQWhBQUFBQUFHRkFBQUJoUUJqQURrQUFBQUFBQ29BS2dBcUFGUUFmbmphWTJCa1lHQmdaWkJrWUdJQUFSREp5QUFTYzJEUUF3a0FBQVpGQUpRQWVOcGRqVHNPd2pBTWhqOGVSYndHeE1DY2hURlZrckVINk1BQk9yS1ZxbElmVXRvamNBd093Qms0SFc0SUVzS1M1Yy8yYi8vQW1oc3pwcGlUc0krODRNdzFjc0tPUitTVjZGK3luUzAzb3Q4RzVjUUxMaHdqSjV5NFIxNXg0RWxEaThkaW9HbTlsWkxUMHpHRzZxa29VVGhTVVNneVNTOFgrdWZ1TTNYQ092UmEySVFrNzdzeDczMVZLcGNhbFNuZjZtQWk2S3kyUmp2alJGYUloMmVnRHM1S3ZreHVGS1VmNnI1VE5wWG0zNVh2TDk3NjlTZ09BSGphWTJCaVFBYU1ET2lBRlN6S3hNRE53QU1BQVJRQUl3PT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpsbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRZQUEwQUFBQUFCbVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdCVTlUTHpJQUFBRk1BQUFBUUFBQUFGWlZiRjdLWTIxaGNBQUFBWXdBQUFCS0FBQUJTZ05oQkFaamRuUWdBQUFCMkFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIY0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlUUFBQUdNQUFBQjBOWGl5enhvWldGa0FBQURjQUFBQURFQUFBQTJHWnBFL0dob1pXRUFBQU9rQUFBQUlBQUFBQ1FGOVFJZ2FHMTBlQUFBQThRQUFBQVVBQUFBRkFiMEFHbHNiMk5oQUFBRDJBQUFBQXdBQUFBTUFNNEJQRzFoZUhBQUFBUGtBQUFBSHdBQUFDQUFTUUNKYm1GdFpRQUFCQVFBQUFDOEFBQUJJL3kwZUxSd2IzTjBBQUFFd0FBQUFCWUFBQUFzQURFQUxuamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUQwUUJjcHdpUEFBQjQybU5nWkpKbG5NREF5c0RBMU1XMGg0R0JvUWRDTXo1Z01HUmtBb295c0RJendBQWpBeElJU0hOTkFWSnVESjVNNy82ek1VUXhyVWFvQVFDemlnbmllTnJWanNFSmdFQU1CR2ZqY1ZWWWdJWElnVFdMdGNYMWxBTi9maDFJaG9FOEFremNNeU11VnBkNkZ4YTcyaUpvYkpudTdqeHlmKzZOS2lNVVhzRWI4UkUvVXZnbEowQmtDV2NBQUFBaEFua0FBQUFCLy84QUFuamFWWkRQYnROQUVNWm5abTN2cm5kangvRTZwVElrT0ZZZGlUK3RhanR4UlVQYUorQUlsVGh4NFVVSTdSUDAwaWRBUWh5U2wrZ3JnTVNCQ3hJWFFCeVJTTVZ1T1hFWnpYeWZOUFA5QmdnS0FIeEFWOENBdy80YTRXQ3g0UjU4cjllQi8zbXhZV1JiV0RNbiswN2U4QUQvTERibzlDWXBrbW1UbEFYS2I5ZlhkTFY5WGRBWkFFRmx5dzk2QjgvaGhkM2V6YXV5bUVTWW1XRlRqOGh3Rm1GNU96ZmRUajFycXdPc3lzbDBIMmZ0Q1RiMU1ETXhtcWFlbitCOFpvMkFSL2dRdXlVZW8vTjRrRG16bzQrR3BMa1o2bENvWkpCazBsK0ovRWhKRWE4dU0wYklkdlBkVEhuTFYrMllNODA5cjJNVWNwLzFEMDlmbnZMNC91cnNDU010UE1JdkgxS0JNaFFNbWRDRDdjOXhINlhVaktXZWo0aEVJaFR4Nyt4T09sSTZpRDhwWDRuZThkNU5yZytmNW5uUDE3SVBqbmxpU1gvUmUzZ0Vqd0gyMm45RWJaY3VMZExTb3BWOE9ybjlnR1A0L3dQNFRBOTJUQng2NS96dVVhUjR2SHByVkZLTjZjTE45dnFiYzVPNnBId1FVWFl2SWVIaUdjR0NIcGZicnlNcmhNcm1CZmdMek5wRWpYamFZMkJrWUdBQTR1djljOVBqK1cyK01uQXp2d0NLTU56ZTFyQU5UaXN5TURDOVkxb041SEl3TUlGRUFXMzJERmdBQUFCNDJtTmdaR0JnV3MzQXdCREYxTXpBOEg4NjB6c0dvQWdLWUFVQVgrNEVHZ0ZzQUNFQUFBQUFBVTBBQUFLREFDWUJ1QUFpQUFBQUtnQXFBQ29BcEFEb2VOcGpZR1JnWUdCbGlHQmdZZ0FCRU1uSUFCSnpZTkFEQ1FBQURHd0Ewd0I0MmsyTlRRckNNQkNGUDYyL0tPSktYQVpjdHlSWjlnQTlnSXV1ZFJGTG9UOFE5UVlld3dONEFzL25wQVl4d3pEZlpCN3ZBUXN1akFodnpKeHQ1SVFEcDhoVFZqd2p6NlRlY2gxTmxxTGZETXJBQ1FYN3lGTjJQQ0xQV1BQaWlLUGlUc01aRDBkWDNadXpRRUZQeDIyWVhoUU9oU1ZEeTh5bEcxcXBHdlA3c2NMcHNLZkNlbWlLdnJzVnZhK2NzcGxXdVdyYXRqWUJyRW1OVHEyMklpckYzWE1WdDVDcHhDUGtVRHAvcmZ0T21VeVcvenkrTG53QTNFQW52SGphWTJCaXdBOVlnWmlSZ1lsQmswRUhBQUZ4QUdBQUFBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6bG1taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmxtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpybS1sbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpybS1sbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJyB0cmFuc2Zvcm09J3NjYWxlKDIgMiknPgo8dGV4dCBjbGFzcz0nZjEnIHg9JzMuMTE5NTg4JyB5PSctNzkuODk2ODQ0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNzAuNDUxODkgMjAuOTk3OSknPkY8dHNwYW4geD0nMTAuOTA5ODQ0Jz5JPC90c3Bhbj4KPC90ZXh0Pgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNzguMjIxNiAyMC45OTc5KSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNTYuMzI5NzE4JyB5PSctNzkuODk2ODQ0Jz5GPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzY0LjExOTk3NCcgeT0nLTc5Ljg5Njg0NCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc2Ny45OTQ0NTInIHk9Jy03OS44OTY4NDQnPkY8dHNwYW4geD0nNzUuNzg0NzA4Jz5JPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzgwLjk0NTknIHk9Jy03OS44OTY4NDQnPik8L3RleHQ+CjwvZz4KPHRleHQgY2xhc3M9J2YxJyB4PScxMDkuNTM5ODQ4JyB5PSctNzkuODk2ODQ0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNzAuNDUxOSAyMC45OTc5KSc+Rjx0c3BhbiB4PScxMTcuMzMwMTA0Jz5JPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzMuMTE5NTg4JyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjYuNTU2NjkgMjAuOTk3OSknPkk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNTYuMzI5NzE4JyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNzAuNDUxOSAyMC45OTc5KSc+Rjx0c3BhbiB4PSc2NC4xMTk5NzQnPkk8L3RzcGFuPgo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTA5LjUzOTg0OCcgeT0nLTQ1LjM3MzU5NicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTY2LjU1NjcgMjAuOTk3OSknPkk8L3RleHQ+CjxwYXRoIGQ9J00tNDkuODkwNjQtNjEuMzkwNkgtMjYuNzc3MzQnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWRhc2hhcnJheT0nMi43ODk0MSwxLjU5Mzk1Jy8+CjxwYXRoIGQ9J00tMjguNjUyMzYtNjMuNzgxMjVDLTI4LjI3MzQ2LTYyLjM0NzY1OC0yNy40Mjk3MDgtNjEuNjY3OTctMjYuNTc4MTQ2LTYxLjM5MDYyNkMtMjcuNDI5NzA4LTYxLjEwOTM3Ni0yOC4yNzM0Ni02MC40MzM1OTUtMjguNjUyMzYtNTknIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTcuNjQ1NTM5JyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzUuNjIxMjYgLTE5LjcxNjUpJz5GPHRzcGFuIHg9Jy0xLjUyMDU1Nyc+ZzwvdHNwYW4+CjwvdGV4dD4KPHBhdGggZD0nTS02MC44NTU0NC01NS4wNTQ2OVYtMzUuNDI1NzgnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTU4LjQ2NDg4LTM3LjMwMDc0Qy01OS44OTg0NzYtMzYuOTIxODMtNjAuNTc4MTY0LTM2LjA3ODA4My02MC44NTU1MDctMzUuMjI2NTIxQy02MS4xMzY3NTctMzYuMDc4MDgzLTYxLjgxMjUzOS0zNi45MjE4My02My4yNDYxMy0zNy4zMDA3NCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNy42NDU1MzknIHk9Jy00NS4zNzM1OTYnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi4yMTA1NiAyLjU3OTIpJz5pbjwvdGV4dD4KPHBhdGggZD0nTTExLjA4OTg2LTYxLjM5MDZIMzQuMjAzMTYnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMzIuMzI4MTEtNjMuNzgxMjVDMzIuNzA3MDEtNjIuMzQ3NjU4IDMzLjU1MDc2MS02MS42Njc5NyAzNC40MDIzMjQtNjEuMzkwNjI2QzMzLjU1MDc2MS02MS4xMDkzNzYgMzIuNzA3MDEtNjAuNDMzNTk1IDMyLjMyODExLTU5JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy03LjY0NTUzOScgeT0nLTQ1LjM3MzU5NicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjMuNDE5NTQgLTE4LjM2MDUpJz5GPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0uMTU5OTIyJyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMy40MTk1NCAtMTguMzYwNSknPmluPC90ZXh0Pgo8cGF0aCBkPSdNLTcuNjQ0NTMxLTUyLjU2MjVWLTM1LjQyNTc4JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTS01LjI1MzkxLTM3LjMwMDc0Qy02LjY4NzUtMzYuOTIxODMtNy4zNjcxODctMzYuMDc4MDgzLTcuNjQ0NTMxLTM1LjIyNjUyMUMtNy45MjU3ODEtMzYuMDc4MDgzLTguNjAxNTYyLTM2LjkyMTgzLTEwLjAzNTE2LTM3LjMwMDc0JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy03LjY0NTUzOScgeT0nLTQ1LjM3MzU5NicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMi4zNDM5NSAzLjk2MDIpJz5GPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0uMTU5OTIyJyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyLjM0Mzk1IDMuOTYwMiknPmluPC90ZXh0Pgo8cGF0aCBkPSdNNDUuNTY2MzYtNTUuMDU0NjlWLTM1LjQyNTc4JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTTQ3Ljk1NzA1LTM3LjMwMDc0QzQ2LjUyMzQ2LTM2LjkyMTgzIDQ1Ljg0Mzc3My0zNi4wNzgwODMgNDUuNTY2NDI5LTM1LjIyNjUyMUM0NS4yODUxNzktMzYuMDc4MDgzIDQ0LjYwOTM5OC0zNi45MjE4MyA0My4xNzU4LTM3LjMwMDc0JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy03LjY0NTUzOScgeT0nLTQ1LjM3MzU5NicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTUuNTU0NzQgMi41NzkyKSc+aW48L3RleHQ+CjxwYXRoIGQ9J00tNTMuNzg1MTQtMjYuODY3MkgtMTkuMDA3ODQnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWRhc2hhcnJheT0nMi43ODk0MSwxLjU5Mzk1Jy8+CjxwYXRoIGQ9J00tMjAuODgyODMtMjkuMjU3OEMtMjAuNTAzOTMtMjcuODI0MjA5LTE5LjY2MDE3Ni0yNy4xNDQ1MjItMTguODA4NjEzLTI2Ljg2NzE3OEMtMTkuNjYwMTc2LTI2LjU4NTkyOC0yMC41MDM5My0yNS45MTAxNDctMjAuODgyODMtMjQuNDc2NTUnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTcuNjQ1NTM5JyB5PSctNDUuMzczNTk2JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzAuNjIxNDYgMjMuODUzOCknPmc8L3RleHQ+CjxwYXRoIGQ9J00zLjMyMDM2LTI2Ljg2NzJIMzguMDk3NjYnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNMzYuMjIyNjYtMjkuMjU3OEMzNi42MDE1Ny0yNy44MjQyMDkgMzcuNDQ1MzIxLTI3LjE0NDUyMiAzOC4yOTY4ODMtMjYuODY3MTc4QzM3LjQ0NTMyMS0yNi41ODU5MjggMzYuNjAxNTctMjUuOTEwMTQ3IDM2LjIyMjY2LTI0LjQ3NjU1JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy03LjY0NTUzOScgeT0nLTQ1LjM3MzU5NicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuMjI1MTQgMjUuMzQ1MyknPmluPC90ZXh0Pgo8L2c+Cjwvc3ZnPg==" /></p>
<p>Since <span class="math inline">\operatorname{\mathrm{in}}</span> is initial, the unique arrows going from it to itself is the identity. Thus, we must have <span class="math inline">g \circ \operatorname{\mathrm{in}}= \operatorname{\mathrm{id}}</span>. Moreover, from the definition of functor and the previous diagram, <span class="math display"> \operatorname{\mathrm{in}}\circ g = (Fg) \circ (F\operatorname{\mathrm{in}}) = F(g \circ \operatorname{\mathrm{in}}) = F(\operatorname{\mathrm{id}}) = \operatorname{\mathrm{id}}.</span> Therefore, <span class="math inline">g</span> is an inverse to <span class="math inline">\operatorname{\mathrm{in}}</span>, concluding the proof.</p>
</div>
<h2 id="sec:cata">Using catastrophes in your favor</h2>
<p>We finally have the necessary tools to define our first recursion scheme in all its glory and generality. Consider, just as in the previous section, a functor <span class="math inline">F</span> from <span class="math inline">\mathtt{Types}</span> to itself and call its initial algebra <span class="math inline">\operatorname{\mathrm{in}}\colon F A \to A</span>. Given a <span class="math inline">F</span>-algebra <span class="math inline">f \colon F X \to X</span>, its <em>catamorphism</em>, which we will denote by <span class="math inline">\operatorname{\mathrm{cata}}f</span>, is the unique arrow from <span class="math inline">A</span> to <span class="math inline">X</span> given by the initially of <span class="math inline">\operatorname{\mathrm{in}}</span>.</p>
<p>Before proceeding, I must allow myself a little rant: sometimes mathematicians are just terrible name-givers. Like, what in hell is a catamorphism? What kind of intuition should it elicit? Well… as a matter of fact the name makes a lot of sense if you happen to be speaking in ancient Greek. Since, despite the arcane name, the catamorphism is a super cool concept, I think it deserves that we do a little etymological break to explain where its name comes from.</p>
<p>The word catamorphism has two parts, <em>cata-</em> + <em>morphism</em>. The later comes comes from the Greek <span lang="grc">‘μορφή’</span> and means <a href="https://outils.biblissima.fr/fr/eulexis-web/?lemma=%CE%BC%CE%BF%CF%81%CF%86%CE%AE&amp;dict=LSJ">“form” or “shape”</a>. Its use is common in category theory and stems from the fact that usually, the arrows in a category are structure (or shape) preserving functions. For example, in the category of <span class="math inline">F</span>-algebras, the morphisms are functions that commute with the algebras, thus “preserving” its application. The prefix “cata-” comes from the Greek <span lang="grc">‘κατά’</span> and means something like a <a href="https://outils.biblissima.fr/fr/eulexis-web/?lemma=%CE%BA%CE%B1%CF%84%CE%AC&amp;dict=LSJ">“downward motion”</a>. It is the same prefix as in “cataclysm” or “catastrophe” and this is the intuition we shall keep in mind. If you think of an inductive data structure as a great tower piercing the sky, the catamorphism is a divine smite that, in a catastrophic manner, collapses the tower into a single value.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>Ok, back to mathematics.</p>
<p>As you may have imagined, the catamorphism is a generalization of the <span class="math inline">\operatorname{\mathrm{reduce}}</span> operator. The difference is that while <span class="math inline">\operatorname{\mathrm{reduce}}</span> only works for lists, <span class="math inline">\operatorname{\mathrm{cata}}</span> can collapse the initial algebra of any functor. But, in all this generality, how do we actually compute a catamorphism? Let’s start by taking a look at its type signature: <span class="math display"> \operatorname{\mathrm{cata}}\colon (F X \to X) \to (A \to X).</span> It is a higher-order operator that takes a function from <span class="math inline">F X</span> to <span class="math inline">X</span> and turns it into another function, now from the fixed point <span class="math inline">A</span> to <span class="math inline">X</span>. Intuitively, what it encapsulates is that if we know how to collapse one step of a data structure, then we can use structural induction to collapse the entire structure.</p>
<p>To properly calculate <span class="math inline">\operatorname{\mathrm{cata}}</span>, let’s take a look at the commutative diagram defining it,</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Mi4yMjY4NDRwdCcgaGVpZ2h0PSc5OS43ODc2MjdwdCcgdmlld0JveD0nLTEzOS43MTIwNTggLTEzOS43MTExMzcgMTcyLjIyNjg0NCA5OS43ODc2MjcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnJtLWxtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBvQUEwQUFBQUFCVEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdCMDlUTHpJQUFBRk1BQUFBUUFBQUFGWlZlRjlYWTIxaGNBQUFBWXdBQUFCQkFBQUJRZ0FQQTk5amRuUWdBQUFCMEFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIVUFBQUFDQUFBQUFqLy93QURaMng1WmdBQUFkd0FBQUNyQUFBQXJMbXB0NmRvWldGa0FBQUNpQUFBQURFQUFBQTJHTlpFN0dob1pXRUFBQUs4QUFBQUhnQUFBQ1FGSHdLdWFHMTBlQUFBQXR3QUFBQVFBQUFBRUFmN0FMQnNiMk5oQUFBQzdBQUFBQW9BQUFBS0FJQUFWRzFoZUhBQUFBTDRBQUFBSHdBQUFDQUFTQUJOYm1GdFpRQUFBeGdBQUFDMkFBQUJJSVhnR25Wd2IzTjBBQUFEMEFBQUFCWUFBQUFxQUJzQUEzamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUgwUUJjc1FpUkFBQjQybU5nWkZySk9JR0JsWUdCcVpOcE53TURRemVFWnJ6UFlNaklCQlJsWU9Wa2dBRkdCaVFRa09hYUFxUU1HUXlaaGYvck1FUXh6VUtvQVFEUUN3bDhlTnBqWUdCZ1pvQmdHUVpHQmhDd0FmSVl3WHdXQmdVZ3pRS0VJTDdoLy84UTh2OGxxRW9HUmpZR0dKT0JrUWxJTURHZ0FrWUdUTURNTUt3QUFIV0NCdTRBQUFBQUlRSjVBQUFBQWYvL0FBSjQybU5nWWxCa1lHRFVaSnJGd016QXpxQzNrWkZCMzJZVE93dkRXNk9OYkt4M2JEWXhNd0daREJ1WlFjS3NJT0ZON0d5TWYydzJNWUxFalFVVkJkV05CWlVWR1RtZUh6dkdOT3R2bWlKVEJBTURFME0va05BQ21pbkZJTTNBb0dpcXJLVEhhQ3Bvb3FiTXBzMG9hbXhrTGlqQ3h3aGttU21JTTJrWm1laHhjRW01TndzS0JqcHk2SmtZbVRPcW1ldHc4UWt4cVlseE9PakkvT01SNHVQU1lXRmhZR0FBQU9GQUg2d0FlTnBqWUdSZ1lBQmlOclgydW5oK202OE0zTXpQZ1NJTXQ3YzFiSWZUaWd3TVRGcE1zNEJjRGdZbWtDZ0FLMlFLU3dBQUFIamFZMkJrWUdDYXhjREFFTVcwRWtneU1Ha3hNREtnQWhZQU1Mc0IxQUFBQXFrQUlRQUFBQUFDcVFBQUFxa0Fqd0FBQUNvQUtnQXFBRllBQUhqYVkyQmtZR0JnWVpCaFlHSUFBUkRKeUFBU2MyRFFBd2tBQUFaMUFKWUFlTnBWalUwS3dqQVFSbCsxclZWQmQ2NnpjSnVTQk56MEFNVVRGRHhBbFVKL0lIYnRNVHlBUi9DRVRtc1FERXptemN3Mzh3RVpWeUttdHlCbUUzakprVXZnaEMzUHdDa3IzaktONHJYb3MxazU4Wkl6KzhBSkJ4NkJVM2E4YU9ud25LRHR2UHdsQXozam5EMDNhaFNPSENPNWtQQWkxNytsYjg5aHBXZEZvNFhOSEpSRFA1YUR2OVhLNVVZVnluZDZjaEJ5Vmx1am5YR2lxc1RBYzZlWmJaVWNtYXlvYW45dmhsN1pYSXAvUzhJaFByVExKdGtBQUhqYVkyQmlRQWFNRE9pQUJTekt4Q0FDQUFEYUFCOEFBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6bG1zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBBQUEwQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdCMDlUTHpJQUFBRk1BQUFBUXdBQUFGWjJUSUNyWTIxaGNBQUFBWkFBQUFBK0FBQUJRZ0FQSmIxamRuUWdBQUFCMEFBQUFBUUFBQUFFQUNFQnBtZGhjM0FBQUFIVUFBQUFDQUFBQUFqLy93QURaMng1WmdBQUFkd0FBQUI4QUFBQWZQS0FKY0ZvWldGa0FBQUNXQUFBQURJQUFBQTJHa2RFR1dob1pXRUFBQUtNQUFBQUhnQUFBQ1FGdlFSQWFHMTBlQUFBQXF3QUFBQVFBQUFBRUF5eEFNRnNiMk5oQUFBQ3ZBQUFBQW9BQUFBS0FHZ0FWRzFoZUhBQUFBTElBQUFBSHdBQUFDQUFTQUE2Ym1GdFpRQUFBdWdBQUFDK0FBQUJIYjlPdUtad2IzTjBBQUFEcUFBQUFCWUFBQUFxQVBZQUEzamFZMkJnWUdRQWdzdmI3czBBMGJlM05XeUgwUUJjc1FpUkFBQjQybU5nWkxGbW5NREF5c0RBMU1tMG00R0JvUnRDTTk1bk1HUmtBb295c0hJeUlBTUhHQ01nelRXRmdVRkpTRW1JOGZqZkJ3eFJqTWZCd293Z0FnRE8rd3JsQUhqYVkyQmdZR2FBWUJrR1JnWVFzQUh5R01GOEZnWUZJTTBDaEVDK2t0RC8veER5N2tlb1NnWkdOZ1lZazRHUkNVZ3dNYUFDUm9aaER3QjJpQWJ1QUFBQUlRR21BQUFBQWYvL0FBSUFBZ0FoQUFBQktRSEhBQU1BQndBdXNRRUFMenl5QndRQTdUS3hCZ1hjUExJREFnRHRNZ0N4QXdBdlBMSUZCQUR0TXJJSEJnSDhQTElCQWdEdE1qTVJJUkVuTXhFaklRRUk1OGJHQWNmK09TRUJoUUFBQWdDZ0FONERtd0VXQUFjQUNBQUFKRFFqSVNJVU15RTNBNXNvL1ZVb0tBS3JLTjQ0T0J3QWVOcGpZR1JnWUFEaUM0OWZMbzdudC9uS3dNMzhIQ2pDY0h0YnczWTRyY2pBd0R5YjhUaVF5OEhBQkJJRkFJK21EUGNBQUhqYVkyQmtZR0E4enNEQUVNVmlEU1FabUdjek1ES2dBaFlBTS9zQ0JnQUFCRHNBSVFBQUFBQUVPd0FBQkRzQW9BQUFBQ29BS2dBcUFENEFBSGphWTJCa1lHQmdZZUJrWUdJQUFSREp5QUFTYzJEUUF3a0FBQVNhQUlNQWVOcEZqVHNLd2tBVVJZL0d2eUJXWWpuWUowd0cwcVNXTE1EQ1VyQVlReUFmbUNTRnBjdHdBUzdBSGZvU0JoeTQ3NTNMWE80RFZqeVlNTHdwUy9hZUEwN2NQTS9aOHZhOEVQZVYzOGxzTGZuZG1CdzQ0TXpSODV3REw4OExObnk0WU1ucEtibmo0R0x6dnJ3TFpEVFVkT04ya3JBb0RCRmFkaW9xcVdoNWtuaHZpQWxGV3FhUk9ZaXNxYnVzY2JsVkp0SXFWV1hWUGhQWkpnNWpIUnB0SkhPVmFpZFZ4WGhRU2NWd2hLdDFiZEhVS283RS9JOHhWdkFEQ3hJblRnQUFlTnBqWUdKQUJvd002SUFGTE1yRThCNEFBYlVBK2dBQSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmxtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVUUFBMEFBQUFBQnFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJvQUFBQWNpeVBnQjA5VEx6SUFBQUZNQUFBQVFnQUFBRlpXT0Y5Z1kyMWhjQUFBQVpBQUFBQk1BQUFCU2dlYkErVmpkblFnQUFBQjNBQUFBQVFBQUFBRUFDRUNlV2RoYzNBQUFBSGdBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBZWdBQUFHN0FBQUNFRjVMdkFab1pXRmtBQUFEcEFBQUFERUFBQUEyR2VoRVIyaG9aV0VBQUFQWUFBQUFJQUFBQUNRR1dBR3JhRzEwZUFBQUEvZ0FBQUFVQUFBQUZBZTdBSzlzYjJOaEFBQUVEQUFBQUF3QUFBQU1BTXdCWEcxaGVIQUFBQVFZQUFBQUh3QUFBQ0FBU1FDS2JtRnRaUUFBQkRnQUFBQy9BQUFCSGIwNGtwUndiM04wQUFBRStBQUFBQllBQUFBc0FERUFTM2phWTJCZ1lHUUFnc3ZiN3MwQTBiZTNOV3lIMFFCY3NRaVJBQUI0Mm1OZ1pHcGtuTURBeXNEQTFNVzBoNEdCb1FkQ016NWdNR1JrQW9veXNESXp3QUFqQXhJSVNITk5BVkp1REdsTTcvNnpNVVF4SFdBNEExTURBTjR3QzBRQUFIamFZMkJnWUdhQVlCa0dSZ1lRY0FIeUdNRjhGZ1lOSU0wR3BCa1ptQmpjR05MKy93Znl3ZlQvdmYvblFkVURBU01iQTV6RHlBUWttQmhRQVNNRGtZQ1pnRHdMdzJBRkFHRG5DWVFBSVFKNUFBQUFBZi8vQUFKNDJqMlJUMjdUUUJTSDM3eHhiTTg0OFdTY2lVUGN2N1pMM0lJVWtPM1lxUkk1S2hKVXJZUlkwa1dSVUVIZGNBSjJTSnlDWG9BZElqa0J1MTZBSFJ3QUliRmtnU0RBT0JHc1p0N3ZtOFh2ZXdNSUlRQzVoVmRBd1lMaG5NQ2Q2Y0l5NEZzNk54dWZwd3VLK2dweldzZU5PbDVZSnZrMVhaQTZ6MlFvazB6R0lXRmZycS94YW5rWjRoa0F3bjBBT3NHMzhCajBTTXBpRUllUlM1U2ZwYjF0MGxVV2RVbXNnNjdLMGlMcnBUb2Y1WU00U29hWXowaVcrdnFKdVlJenpPUEl0Rnh5bTVRVm1aQWFyVWxKRXc4ZHRmemFkSmpyS1UvWXhtdTdQM1k0YTR0TDhiQlZOSDJoTnZvdGJ0UHFSUmxaVkRMVEtBekpUVU1VUjg5bnBydno1bWxWejBnK3Zlc3k1TXBBMHJCUkxiL3ZDTUs1TUFqMXVjN1FjcDBmblVCdU1pcHM4VkVKSmc3M2Z0N2c2WkU2SU5JUjJ2ZmtUNDduK0FFZXdMSDJyVlhxenRiYWNWdjNwcWEycTNCbHFmdHI0VXF2cGV6VTV5Z2ZhcjFDKytuMXVMaWl4UWpQSndmeHZZNHJ2VWN0aHpISE9UM3o3L1k3bm0vMHBCOGY3bStOQTdiZkhWK3M0Wk5keTlqeU52OWhmQmtPa3IzZzVCbHlydi9yZDNMUk5BTnB0cnZSeG01eU0yNmZ2aUtqTlhvZnlPQS9BL2dMdjJoT05BQjQybU5nWkdCZ0FHS0x2ZTNPOGZ3Mlh4bTRtVjhBUlJodWIydllEcWNWLzVzd1d6TWRBSEk1R0poQW9nQmFyZ3hGQUFBQWVOcGpZR1JnWURydzM0UWhpdWtxQThQL09jeldERUFSRk1BS0FJRjFCUWNCYkFBaEFBQUFBQUZOQUFBQzFRQkZBaTBBU1FBQUFDb0FLZ0FxQUtJQkNIamFZMkJrWUdCZ1pZaGtZR0lBQVJESnlBQVNjMkRRQXdrQUFBeUZBTlFBZU5wRmpVMktBakVRaFQvSGZ3ZGtWb1BMNEw2YmREYUNhK2tEdUhBNTRDSTJEZjBEVVEvZ01UeUFCL0NHdmpTQlNhaXFyNmpIZThDQ0N5UGkrMkxPVCtJeFcvNFNUL25tbVhpbTdhM3JhTEtVZmowb0k0ODVzRWs4NVpkSDRoa3JYaHp4Vk54cE9CUGc2S3Q3Y3hhVTlIVGNoaG1rOEJnY09WWnpyMnBvOVd0MmFYY1VaQ3FyN3RSalVmYmRyZXhENVkzTHJkbWJwbTNybmFZcnNzSm16anBwVHJJT1hHVVZBNDBzWWdnbkg2NTEzNWtpMS9JZnhtREJCL3JqSnY0QWVOcGpZR0xBRDFpQm1KR0JpVUdUd1JNQUFZNEFmUUFBKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6cm0tbG1yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWmtBQTBBQUFBQUNEQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZ0IwOVRMeklBQUFGTUFBQUFRZ0FBQUZaV2JsOG1ZMjFoY0FBQUFaQUFBQUJxQUFBQmFnbTJFTjVqZG5RZ0FBQUIvQUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUlBQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWdnQUFBTE9BQUFEVkd1NWdRcG9aV0ZrQUFBRTJBQUFBREVBQUFBMkdQZEVSMmhvWldFQUFBVU1BQUFBSGdBQUFDUUZtQUdKYUcxMGVBQUFCU3dBQUFBb0FBQUFLQS9oQWNGc2IyTmhBQUFGVkFBQUFCWUFBQUFXQkRZRFZtMWhlSEFBQUFWc0FBQUFId0FBQUNBQVVBQnhibUZ0WlFBQUJZd0FBQUMyQUFBQklJWG1IbmR3YjNOMEFBQUdSQUFBQUNBQUFBQTJBUDhBcFhqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5SDBRQmNzUWlSQUFCNDJtTmdaSHpJT0lHQmxZR0JxWk5wTndNRFF6ZUVacnpQWU1qSUJCUmxZR1ZtZ0FGR0JpUVFrT2FhQXFRMEdFcVlKZjhiTVVReHZXUDRDVk1EQVBJR0MwQUFBSGphWTJCZ1lHYUFZQmtHUmdZUVNBSHlHTUY4RmdZUElNM0h3TUhBeE1ER29NbVF5SkRNa01tUXgxRHkvejlRWEFPWi8vLzIveVgvRi8rZjkzL1cvNmxRYzVBQUl4c0RYSkNSQ1Vnd29TdEFNSmxaR01nRHJFQTNnZ0E3aU9BQU16a1pCZzhBQUl6OUU1OEFBQUFoQW5rQUFBQUIvLzhBQW5qYVZWSk5UQk5CR1AxbWR0c0ZXZ3U3M2UzMkQ5cjlhWGVMOUlmOWFTc3RoVVFFV2dsRzVZQVlpSUNCUkUxTTlGQmlvdkZBb29FanhnUEJtd21KaVRFMHhraE1QSEl5OGNMUmd3Y1RUM2p3d01GQWNaYkt3Y05NWnQ1azNudmYrejdBSUFHZ0ZONEVDaGpJN0NESWxoc01EUWZHanR2MXJkeWdNRG5DRHVYQUxnZHVNRzUwVkc0Z0J6ZFppZFZNVnBGUTI4KzlQYng1dkNUaGFRQU1EMDhZVk1lL1FJQUFnTXZTa214WElXOWJpbzhTK0I0c0dqYXFkM3pZWmZpUkJWTVUrbStQOGdldWp0ZklRdlkyNC9MbW5qNS9YQ210cks4YVhvZHJqSERWQ0ZjQVJJQ0VsY0dhTFBCaWdPMWkzQUp2R2hWRW1GSE5ZZkczZjNqTG5XdXpyL1ZVLzdUKzA1N3Q1dGZtbDFlY3k2dlBYVmg3QTBCRCt1UVF4OUZuTU1HQ0Nnd1JUbHNSZUhrUVdSbWtKUldac0FZTVlsYkxtMGFnRzdrWkh5S21rV25rQzJRZlFCWGExbmkzSWlkdEsxOFFjRnl1VVVLZ1BGMjlFZFVqaWpxY0hhMWZyaFRMdFZTaDVxZFNFbVlFVG1ROW42YlNldW5PbzVsQ2ZxRDhUcGJPYzRhVkZzTVJYdTBJVlVveE9pcU9KM1diNjFla0RNMzQvSEcvT1Z6S3F1WjExeUtBazBIbTVCRHRFODhhNkU0R3hDUngxYkpnR3VLWjR3eHV1U2VoVURiYVo5dmRkRmMxTzdnd05UYW9Sc085a2RSSVFyajNiSDJ4ZDBRTHQ2OTQzWjUwN3RiaTNIS25OODVId21KTTk5SHJOK2RXUTdJZWRwR2NpbVF1T1B3Q09QQkRET0lBa2swRVdVWXdBZ0pMQWhBY2FjcEtubW1TTG5DWndFWXVHRFRIOVZLMklBVkRjV2VwM2g1MDE2TnlpZVpSekt2U05KNEp5ckxvckZadGViSk5vbDNvZzNSTGczUkNrUm5GL2wrcDlkRHF5Um1HSjgzZ3kvc1cyakJDUkxUM2ltb0daNHZaZU91c2VtUGYxK2JuUGFvLzBUdytWU2JJKytyVmdkeVAwNXVqM1UxeXJlTmxpRUQwM3h5UXh0cXNhU3UyNGtPTVlMSmtYRTlMcTh0NjdOTFdsb3hHTDg1RzBuMUJZK2hKSWQ5ZlhFS2Q2c2VKQnpqYS9LMFhvNTZKTWlucEw4S0dvRHdBQUhqYVkyQmtZR0FBNHFLYXZYcngvRFpmR2JpWm53TkZHRzV2YTlnT3AyWC9zelA1TWIwRGNqa1ltRUNpQUY5SERHMEFBQUI0Mm1OZ1pHQmdldmVmblNHS3Fad0JDSmo4R0JnWlVBRVhBRmRrQXlZQUFBRnJBQ0VBQUFBQUFVMEFBQUcrQUhNQnZnQkhBamtBTFFIOEFDNEJRd0E0QW5jQU5nRytBQjBBQUFBcUFDb0FLZ0JRQUhnQTBnRU1BVUFCZmdHcUFBQjQybU5nWkdCZzRHSndZR0JoQUFFbUlHWmtBSWs1TU9pQkJBQUt5UURDQUhqYVZZMU5Dc0l3RUVaZnRhMVZRWGV1czNDYmttUWo5QURGRXhROFFKVkNmeUIyN1RFOGdFZndoRTVyRUF4TTVzM01OL01CR1ZjaXByY2daaE40eVpGTDRJUXR6OEFwSzk0eWplSzE2TE5aT2ZHU00vdkFDUWNlZ1ZOMnZHanA4SnlnN2J6OEpRTTk0NXc5TjJvVWpod2p1WkR3SXRlL3BXL1BZYVZuUmFPRnpSeVVReitXZzcvVnl1VkdGY3AzZW5JUWNsWmJvNTF4b3FyRXdIT25tVzJWSEptc3FHcC9iNFplMlZ5S2YwdkNJVDY1TnlibEFBQjQybU5nWXNBUHVJQ1lrWUdKZ1p1Qmg4R0Z3WTNCaHlHUUlSd0FDY2dCcFE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmxtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWk1BQTBBQUFBQUNEQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZ0IwOVRMeklBQUFGTUFBQUFRZ0FBQUZaV0UxOU5ZMjFoY0FBQUFaQUFBQUJhQUFBQldnWGZEVGxqZG5RZ0FBQUI3QUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUh3QUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWZnQUFBTGFBQUFEZkhqZDhmeG9aV0ZrQUFBRTFBQUFBREVBQUFBMkdmcEVYbWhvWldFQUFBVUlBQUFBSUFBQUFDUUdmQUlhYUcxMGVBQUFCU2dBQUFBY0FBQUFIQXg4QU50c2IyTmhBQUFGUkFBQUFCQUFBQUFRQWE0Q3lHMWhlSEFBQUFWVUFBQUFId0FBQUNBQVRRQ2FibUZ0WlFBQUJYUUFBQUM4QUFBQkkveTBlTFJ3YjNOMEFBQUdNQUFBQUJvQUFBQXdBRUlBWVhqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTld5SDBRQmNzUWlSQUFCNDJtTmdaQ3Bnbk1EQXlzREExTVcwaDRHQm9RZENNejVnTUdSa0Fvb3lzREl6d0FBakF4SUlTSE5OQVZJNkRCRk03LzZ6TVVReG5XRTRDRk1EQU5XaUN3d0FBSGphWTJCZ1lHYUFZQmtHUmdZUUNBSHlHTUY4RmdZTElNM0Z3TUhBQklRNkRJNE1iZ3dSLy84RHhlRHMvOWYvSC82Ly8vODZxRjRvWUdSamdBc3dNZ0VKSmdaVXdJaktaV2JBQWxoQUJDdUdNQnZEMEFBQXl5Y09JQUFBQUNFQ2VRQUFBQUgvL3dBQ2VOcE5rYjl2RTBrVXg5OTdNN3V6NjUzZDlYcG5iU2NieDdHWDJJZ2Z6c1ZyZXlFSmRrUWlRRUFIaEFoRUFZZ2ZRalEwbEVoSStSZXVvVHhkZ1lUdXBLUkF0RmVjVW5BTnVvWTdYWEhTNlNRb0FJa09RUXhqaHlDYXA2YzNvNW4zL1h5QW9BYUFCK2dSTUJEUTJrU1lXOW9TSE42ME4wM2puNlV0UnJxRlRUWWFHNlB4bGpEeDA5SVdqdVpwVUF1YWFaRFUwSDYxdlUyUGRtN1dhQjJBWU8zekFKN0RIWmlBU1lDczAwanFacVNLYVh1QXhVZ0ozYWZ0UHVzK1R5cmxTcVVjZVFhdE9qbXVKc3NCemgrcEZxTVpsNkYzZmRVeG5DQTV2S3dYQk9DUTZJZGYwQi9RaHdFY2h4V0EyVTVTYnpSWml5VjFnUjRLanlMVjdxVnQvVSsza3pTNm5heFBXYXFtTVZKSjNkTzFXRXIzenB0SmpQU2lkQ2lrWTRqY0ZQbmM4T2VwaFZuTEZKT0xYckNTRC9OekhqcjE2WSsyT0dWYlFuQVduVmR5M1MzODl2L3ZNOHFSWmJwbkM0SEJ6ck5Xd2hCdDIyRXNsTHpxbGlsWVNQbkZVN3lHT2Rzd2tESDFIazhQbjQ0eUVEUjBlVXVQWVEwdWF1cFpyNUhVZGpkTDI5T2tCUE53ZDlNMEsra01qVG5VNUpvdDdIWUdxUGVPbEkrYVhHK0F2ZTRJcWZEd0lHWjlYTVQyTjZ5OWpGNHFzdFd3S0hPV0V4U0N5RFkyclBpSVkxdit4bzhSSTJRVDhVVGs4UDdWVGxVd0tUalBHT1dFd2ZMenk1ZVhoVCt6c2I3QVNGcWM4TjlmUWd2dG5NV1FXYkt3ODY2YTEwR2xEc29OUkNTeWNwYi9JU3FIMDQ0MC9iKzBMY3RkbkIzR2N2NVlITHVHdFBQanpERUFPMGRQNEJiY0hqdHJZWk5wTVQxdFIydXFtMXBpVW85VWFSeHZEanQ5emVYN0F4MjhGT3Fvd2h3YjNsVTRvcE0wdGVNQlZWRjlsWjltWTdmMGQyRys3RDZNcjV6MGpwNndUZUg2ZzN4NHVoREsvZUZQNXcybkVpcGZYWWprdWl5VURreFk5LzlrZ3ZVdjdOMDdzODlrYkg5ODg5SU5RMDRWaEREOUIzTE5EVU9Kc29yZHFSdG41UTk3dnBWTlBQYWpYN2RkN2tpaVFKTlJqaHNPWC8vSERMWmk3TjNpSnZJNFg3bDc3WjNIcFVOSWxqVmlDUEFGMThLQTVRQUFlTnBqWUdSZ1lBRGltbmI5ei9IOE5sOFp1SmxmQUVVWWJtOXIyQTZucGYvYk13Y3puUUZ5T1JpWVFLSUFiZE1NMUFBQUFIamFZMkJrWUdBNjg5K2VJWXJaaG9IaC8zVG1ZQWFnQ0FwZ0J3QjJzZ1NiQVd3QUlRQUFBQUFCVFFBQUFSWUFWZ0x1QUNNQ2d3QW1BendBR3dBQUFDb0FLZ0FxQUZRQXRnRXdBYjU0Mm1OZ1pHQmdZR2ZJWkdCaEFBRW1JR1prQUlrNU1PaUJCQUFPZVFEb0FIamFUWTFOQ3NJd0VJVS9yYjhvNGtwY0JseTNKRm4yQUQyQWk2NTFFVXVoUHhEMUJoN0RBM2dDeitla0JqSERNTjlrSHU4QkN5Nk1DRy9Nbkcza2hBT255Rk5XUENQUHBONXlIVTJXb3Q4TXlzQUpCZnZJVTNZOElzOVk4K0tJbytKT3d4a1BSMWZkbTdOQVFVL0hiWmhlRkE2RkpVUEx6S1ViV3FrYTgvdXh3dW13cDhKNmFJcSt1eFc5cjV5eW1WYTVhdHEyTmdHc1NZMU9yYllpS3NYZGN4VzNrS25FSStSUU9uK3QrMDZaVEpiL1BMNHVmQURjUUNlOGVOcGpZR0xBRDlpQm1KR0JpWUdmUVlWQms4RWFBQUxuQUtRQUFBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6bG1zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6bG1taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmxtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpybS1sbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OnJtLWxtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnIHRyYW5zZm9ybT0nc2NhbGUoMiAyKSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQuMTEwMTA2JyB5PSctNzYuNDk4NDcnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NC4yMDk2OSAxOC40NTE4KSc+Rjx0c3BhbiB4PSczLjY4MDE1Jz5BPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ0LjQyMjk5OCcgeT0nLTc2LjQ5ODQ3JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDQuOTkxNDMgMTguNDUxOCknPkY8dHNwYW4geD0nNTIuMjEzMjU0Jz5YPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00LjExMDEwNicgeT0nLTQ0LjQ2NTg4MicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQxLjY5ODE5IDE4LjQ1MTgpJz5BLDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc0NC40MjI5OTgnIHk9Jy00NC40NjU4ODInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00MS4wOTYyNSAxOC40NTE4KSc+WDwvdGV4dD4KPHBhdGggZD0nTS00MC42ODc1LTU0LjIwMzEyVi0zNy4wNjY0MScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMzguMjk2OTEtMzguOTM3NTFDLTM5LjczMDUwNy0zOC41NTg2LTQwLjQxMDE5NC0zNy43MTQ4NTQtNDAuNjg3NTM4LTM2Ljg2NzE5OEMtNDAuOTY4Nzg4LTM3LjcxNDg1NC00MS42NDQ1NjktMzguNTU4Ni00My4wNzgxNi0zOC45Mzc1MScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTYuMDMwNjI5JyB5PSctNDQuNDY1ODgyJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjIuMzEzOCAxLjI3ODUpJz5pbjwvdGV4dD4KPHBhdGggZD0nTS0yOC41NzAzLTYwLjUzOTFILTUuNDUzMScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tNy4zMjgxMy02Mi45Mjk2NEMtNi45NDkyMi02MS40OTIxNDUtNi4xMDU0NjktNjAuODE2MzY0LTUuMjUzOTA3LTYwLjUzOTAyQy02LjEwNTQ2OS02MC4yNTc3Ny02Ljk0OTIyLTU5LjU4MTk4OS03LjMyODEzLTU4LjE0ODM5JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTcuMjc4NCAtMjAuMTU5MyknPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNi4wMzA2MjknIHk9Jy00NC40NjU4ODInPkY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTkuOTA1NjQ4JyB5PSctNDQuNDY1ODgyJz4oY2F0YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc5LjE4MjI4NicgeT0nLTQ0LjQ2NTg4Mic+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxMy44NDg4NycgeT0nLTQ0LjQ2NTg4Mic+KTwvdGV4dD4KPC9nPgo8cGF0aCBkPSdNNy44NDM3LTU0LjIwMzEyVi0zNy4wNjY0MScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00xMC4yMzQzOC0zOC45Mzc1MUM4LjgwMDc4MS0zOC41NTg2IDguMTI1LTM3LjcxNDg1NCA3Ljg0Mzc1LTM2Ljg2NzE5OEM3LjU2NjQwNi0zNy43MTQ4NTQgNi44OTA2MjUtMzguNTU4NiA1LjQ1MzEzLTM4LjkzNzUxJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNi4wMzA2MjknIHk9Jy00NC40NjU4ODInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIxOTkgLjc3NDkpJz5mPC90ZXh0Pgo8cGF0aCBkPSdNLTQ4Ljg0NzctMzYuNjY3OTdDLTUzLjE5MTQtNDIuMDE5NTMtNTIuMzc1LTQ5Ljg1OTM3LTQ3LjMzMi01My45NDkyMicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tNTAuMjkyOTctNTQuNjI4ODg5Qy00OS4wOTM3NTUtNTMuNzQ5OTgyLTQ4LjAxMTcyMS01My43NTc3OTMtNDcuMTc5NjktNTQuMDc4MTA1Qy00Ny42NjAxNjMtNTMuMzI0MTk4LTQ3Ljg5MDYzMy01Mi4yNjU2MDEtNDcuMjgxMjYtNTAuOTE0MDQzJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTMuODI1NCAtMy42OTExKSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjAzMDYyOScgeT0nLTQ0LjQ2NTg4Mic+aW48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTkuMzc0OTI0JyB5PSctNDcuNDcyNCc+4oiSPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zLjk3ODQxNScgeT0nLTQ3LjQ3MjQnPjE8L3RleHQ+CjwvZz4KPHBhdGggZD0nTS0zMS4wNzgxLTI4LjUwMzlILTEuNTU4Nicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtZGFzaGFycmF5PScyLjc4OTQxLDEuNTkzOTUnLz4KPHBhdGggZD0nTS0zLjQzMzU5LTMwLjg5NDU3Qy0zLjA1NDY5LTI5LjQ2MDk3Ny0yLjIxMDkzOC0yOC43ODUxOTYtMS4zNTkzNzYtMjguNTAzOTQ2Qy0yLjIxMDkzOC0yOC4yMjY2MDItMy4wNTQ2OS0yNy41NDY5MTQtMy40MzM1OS0yNi4xMTMzMicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTYuMDMwNjI5JyB5PSctNDQuNDY1ODgyJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuNDEwNyAyMy4xNDgxKSc+Y2F0YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctLjA1NjAxOScgeT0nLTQ0LjQ2NTg4MicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEwLjQxMDcgMjMuMTQ4MSknPmY8L3RleHQ+CjwvZz4KPC9zdmc+" /></p>
<p>In this diagram, there are two ways to go from <span class="math inline">A</span> to <span class="math inline">X</span>. From its commutativity, we know that they are equal. Hence, <span class="math inline">\operatorname{\mathrm{cata}}</span> must satisfy <span class="math display"> \operatorname{\mathrm{cata}}f = f \circ F(\operatorname{\mathrm{cata}}f) \circ \operatorname{\mathrm{in}}^{-1}.</span> So, that’s a pretty concise formula. Let’s unpack it with some examples before trying to give a full explanation.</p>
<p>The first inductive data type we encountered where the natural numbers, defined as the least fixed point of <span class="math display">F X = \operatorname{\mathrm{zero}}\mid \operatorname{\mathrm{succ}}\, X.</span> For it, the initial algebra and its inverse are defined as <span class="math display">\begin{aligned}
\operatorname{\mathrm{in}}(\operatorname{\mathrm{zero}}) &amp;= 0, \\
\operatorname{\mathrm{in}}(\operatorname{\mathrm{succ}}n) &amp;= n+1,
\end{aligned}\quad
\begin{aligned}
\operatorname{\mathrm{in}}^{-1}(0) &amp;= \operatorname{\mathrm{zero}}, \\
\operatorname{\mathrm{in}}^{-1}(n) &amp;= \operatorname{\mathrm{succ}}(n-1).
\end{aligned}</span> If these definitions seem too obvious, remember that the <span class="math inline">\mathbb{N}</span> are the natural numbers as we think of them everyday while <span class="math inline">\operatorname{\mathrm{zero}}</span> and <span class="math inline">\operatorname{\mathrm{succ}}</span> are the formal constructors of the functor <span class="math inline">F</span>. Keeping track of this boilerplate is essential.</p>
<p>As our first example, let’s construct the function <span class="math inline">\exp \colon \mathbb{N}\to \mathbb{R}</span>, which takes a natural <span class="math inline">n</span> to the real number <span class="math inline">e^n</span>, as a catamorphism. Exponentiation is recursively defined by the equations <span class="math display">\begin{aligned}
e^{0} &amp;= 1 \\
e^{n+1} &amp;= e \cdot e^n.
\end{aligned}</span> In terms of an algebra <span class="math inline">f \colon F \mathbb{R}\to \mathbb{R}</span>, this means that on the constructor <span class="math inline">\operatorname{\mathrm{zero}}</span> we must return <span class="math inline">1</span> while in each <span class="math inline">\operatorname{\mathrm{succ}}</span> step, we must return <span class="math inline">e</span> times the already accumulated value. Then, <span class="math inline">\exp = \operatorname{\mathrm{cata}}f</span>, where <span class="math display">\begin{aligned}
f(\operatorname{\mathrm{zero}}) &amp;= 1 \\
f(\operatorname{\mathrm{succ}}x) &amp;= e \cdot x.
\end{aligned}</span> Let’s use the catamorphism formula to unwrap the calculations of <span class="math inline">\exp</span>. First, <span class="math inline">in^{-1}</span> writes a number as the <span class="math inline">\operatorname{\mathrm{succ}}</span> of its predecessor. Then, the way we defined the functor action of a data type means that <span class="math inline">F (\operatorname{\mathrm{cata}}f)</span> unwraps <span class="math inline">\operatorname{\mathrm{succ}}n</span> to apply <span class="math inline">\operatorname{\mathrm{cata}}f</span> to the natural number <span class="math inline">n</span> stored inside it and then reapplies the constructor, leaving us with <span class="math inline">\operatorname{\mathrm{succ}}((\operatorname{\mathrm{cata}}f)(n))</span>. This process recursively continues until we encounter a <span class="math inline">\operatorname{\mathrm{zero}}</span>. But this time <span class="math inline">F (\operatorname{\mathrm{cata}}f)</span> <em>does not</em> reapplies <span class="math inline">\operatorname{\mathrm{cata}}f</span>; instead, it returns <span class="math inline">\operatorname{\mathrm{zero}}</span> as is. At this point, our call stack is consists of the function <span class="math inline">f</span> applied exactly <span class="math inline">n</span> times to the constructor <span class="math inline">\operatorname{\mathrm{succ}}</span> applied exactly <span class="math inline">n</span> times to <span class="math inline">\operatorname{\mathrm{zero}}</span>. For example, let’s take a look at the traceback of calling <span class="math inline">\exp(2)</span>: <span class="math display">\begin{aligned}
\exp(2) &amp;= (f \circ F(\operatorname{\mathrm{cata}}f) \circ \operatorname{\mathrm{in}}^{-1})(2) \\
        &amp;= f(F(\operatorname{\mathrm{cata}}f)(\operatorname{\mathrm{in}}^{-1}(2))) \\
        &amp;= f(F(\operatorname{\mathrm{cata}}f)(\operatorname{\mathrm{succ}}1)) \\
        &amp;= f(\operatorname{\mathrm{succ}}(\operatorname{\mathrm{cata}}f(1))) \\
        &amp;= f(\operatorname{\mathrm{succ}}(f(F(\operatorname{\mathrm{cata}}f)(\operatorname{\mathrm{in}}^{-1}(1))))) \\
        &amp;= f(\operatorname{\mathrm{succ}}(f(F(\operatorname{\mathrm{cata}}f)(\operatorname{\mathrm{succ}}0)))) \\
        &amp;= f(\operatorname{\mathrm{succ}}(f(\operatorname{\mathrm{succ}}(\operatorname{\mathrm{cata}}f (0)))) \\
        &amp;= f(\operatorname{\mathrm{succ}}(f(\operatorname{\mathrm{succ}}(f(F(\operatorname{\mathrm{cata}}f)(\operatorname{\mathrm{in}}^{-1}(0))))))) \\
        &amp;= f(\operatorname{\mathrm{succ}}(f(\operatorname{\mathrm{succ}}(f(F(\operatorname{\mathrm{cata}}f)(\operatorname{\mathrm{zero}})))))) \\
        &amp;= f(\operatorname{\mathrm{succ}}(f(\operatorname{\mathrm{succ}}(f(\operatorname{\mathrm{zero}}))))) \\
        &amp;= f(\operatorname{\mathrm{succ}}(f(\operatorname{\mathrm{succ}}1))) \\
        &amp;= f(\operatorname{\mathrm{succ}}(e\cdot 1)) \\
        &amp;= e \cdot (e \cdot 1).
\end{aligned}</span> Ok, these were a lot of parentheses. However, if you actually followed that mess above, the catamorphism’s pattern should be clear by now.</p>
<p>As a final example of catamorphism, let’s write a little calculator that supports addition, multiplication and exponentiation by a natural. A calculator should take an arithmetic expression and return a real number. We define an expression recursively. It may be a real number, the sum of two other expressions, the multiplication of two expressions, or an expression raised to a natural exponent. This is represented by a type <span class="math inline">\mathtt{Expr}</span> which is the least fixed point of the functor <span class="math display">F\,X \simeq \operatorname{\mathrm{const}}\, \mathbb{R}\mid \operatorname{\mathrm{add}}\, X \times X \mid \operatorname{\mathrm{mult}}\, X \times X \mid \operatorname{\mathrm{pow}}\,X \times\mathbb{N}.</span></p>
<p>To evaluate an expression, we need an appropriate <span class="math inline">F</span>-algebra <span class="math inline">f \colon F \mathbb{R}\to \mathbb{R}</span>. As with natural numbers, the idea in here is to treat the constructor <span class="math inline">\operatorname{\mathrm{const}}</span> where <span class="math inline">X</span> don’t appear as a base case and to think of the others constructors as storing an already solved problem on the <span class="math inline">X</span>. With this in mind, the evaluator <span class="math inline">F</span>-algebra is <span class="math display">\begin{aligned}
f(\operatorname{\mathrm{const}}(a)) &amp;= a \\
f(\operatorname{\mathrm{add}}(x,y)) &amp;= x + y \\
f(\operatorname{\mathrm{mult}}(x,y)) &amp;= x \cdot y \\
f(\operatorname{\mathrm{pow}}(x,n)) &amp;= x^n.
\end{aligned}</span> And the evaluator <span class="math inline">\operatorname{\mathrm{eval}} \colon \mathtt{Expr}\to \mathbb{R}</span> is just <span class="math inline">\operatorname{\mathrm{cata}}f</span>.</p>
<p>Another application of a catamorphism is if instead of evaluating the expression, we want to print it as a string. Let’s say we have a method <span class="math inline">\operatorname{\mathrm{str}}</span> that converts numbers to strings and an operator <span class="math inline">\diamond</span> that concatenates two strings. Erring on the side of too many parentheses, a candidate <span class="math inline">F</span>-algebra is <span class="math display">\begin{aligned}
g(\operatorname{\mathrm{const}}(a)) &amp;= \operatorname{\mathrm{str}}(a) \\
g(\operatorname{\mathrm{add}}(x,y)) &amp;= x \diamond \mathtt{&quot;\mathord{+}&quot;} \diamond y \\
g(\operatorname{\mathrm{mult}}(x,y)) &amp;= \mathtt{&quot;(&quot;} \diamond x \diamond \mathtt{&quot;)\mathord*(&quot;} \diamond y \diamond \mathtt{&quot;)&quot;} \\
g(\operatorname{\mathrm{pow}}(x,n)) &amp;= \mathtt{&quot;(&quot;} \diamond x \diamond \mathtt{&quot;)\char`\^&quot;} \diamond \operatorname{\mathrm{str}}(n).
\end{aligned}</span> As you probably already expect, the function <span class="math inline">\operatorname{\mathrm{show}} \colon \mathtt{Expr}\to \mathtt{String}</span> that converts an expression to a string is just <span class="math inline">\operatorname{\mathrm{cata}}g</span>.</p>
<p>Least fixed points are recursive data structures. The catamorphism abstracts the process of transforming these structures into another type via structural induction. All recursion occurs inside the formula for <span class="math inline">\operatorname{\mathrm{cata}}</span>. If you just use it as a black box that turns functions <span class="math inline">F X \to X</span> into functions <span class="math inline">A \to X</span> (where A is the fixed point), you will never actually see the recursion’s autoreference. The operator <span class="math inline">\operatorname{\mathrm{cata}}</span> abstracts recursion just like a <code>for</code> loop abstracts the <code>goto</code> away. It is still there but following a fixed structure.</p>
<p>Since <span class="math inline">\operatorname{\mathrm{cata}}</span> is a more rigid structure than general recursion, it is easier to reason about it. For example, one of the strongest properties of catamorphisms is that if the recursive data structure is finite and <span class="math inline">f</span> is total function, then <span class="math inline">\operatorname{\mathrm{cata}}f</span> is also guaranteed to eventually stop; As a lot of applications use finite data, this facilitates a lot the act of debugging a program.</p>
<h2 id="sec:ana">Taking your functions to the gym</h2>
<p>Collapsing a data structure into a value has many use cases but is not the end of the story. Sometimes we want to do the exact opposite: take a value as a seed to construct a list or another structure from it. This notion is dual to the catamorphism and, of course, there is also a recursion scheme to encapsulate it: the <em>anamorphism</em>.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<p>Again we have a pretty arcane name in our hands. Let’s take a look at its etymology in order to clarify things. The prefix <em>ana-</em> comes from the Greek <span lang="grc">‘ἀνα’</span> and generally means <a href="https://outils.biblissima.fr/fr/eulexis-web/?lemma=%E1%BC%80%CE%BD%CE%B1&amp;dict=LSJ">“upward motion”</a> but is also used to mean “strengthening” or “spreading all over”. It is the same prefix of <em>analogy</em> and of <em>anabolic steroids</em>. In both these words, the prefix means that we are building something up.</p>
<p>In order to describe the catamorphism in all its generality and yet with a concise formula, we had to dive into some categorical abstract nonsense. As you might expect, the same applies to the anamorphism. Fortunately, there is a tool in category theory called <a href="https://en.wikipedia.org/wiki/Dual_%28category_theory%29">duality</a>. If we simply reverse the arrows in a theorem, its conclusion still holds but also with some arrows reversed.</p>
<p>Given a category <span class="math inline">\mathcal{C}</span> and a functor <span class="math inline">F \colon \mathcal{C}\to \mathcal{C}</span>, we define a <span class="math inline">F</span>-coalgebra to a object <span class="math inline">X</span> of <span class="math inline">\mathcal{C}</span> together with an arrow <span class="math inline">f \colon X \to F X</span>. The <span class="math inline">F</span>-coalgebras form a category where the morphisms between <span class="math inline">f \colon X \to F X</span> and <span class="math inline">g \colon Y \to F Y</span> are arrows <span class="math inline">h \colon X \to Y</span> such that the diagram below commutes.</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzMC4yMDU5MzlwdCcgaGVpZ2h0PSc4My42MTczMjFwdCcgdmlld0JveD0nLTEzNS40MjIyNjYgLTEzOS43MTEwODEgMTMwLjIwNTkzOSA4My42MTczMjEnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmxtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFaWUFBMEFBQUFBQ0R3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJvQUFBQWNpeVBnQ1U5VEx6SUFBQUZNQUFBQVFnQUFBRlpXT0Y5VVkyMWhjQUFBQVpBQUFBQlFBQUFCU2dlaUNlVmpkblFnQUFBQjRBQUFBQVFBQUFBRUFDRUNlV2RoYzNBQUFBSGtBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBZXdBQUFMdUFBQURuQmJUYWVOb1pXRmtBQUFFM0FBQUFERUFBQUEyR2VoRVNXaG9aV0VBQUFVUUFBQUFJQUFBQUNRR1dBR3RhRzEwZUFBQUJUQUFBQUFjQUFBQUhBeUZBU1ZzYjJOaEFBQUZUQUFBQUJBQUFBQVFBallES20xaGVIQUFBQVZjQUFBQUh3QUFBQ0FBVFFDS2JtRnRaUUFBQlh3QUFBQy9BQUFCSGIwNGtwUndiM04wQUFBR1BBQUFBQm9BQUFBd0FIMEFsbmphWTJCZ1lHUUFnc3ZiN3MwQTBiZTNOZXlBMFFCY3V3aVRBQUI0Mm1OZ1pDcG1uTURBeXNEQTFNVzBoNEdCb1FkQ016NWdNR1JrQW9veXNESXp3QUFqQXhJSVNITk5BVkp1REJsTTcvNnpNVVF4SFdBNEExTURBTm5NQ3pnQUFIamF6WXJiQ1lCQURBUW51VE5WV0lDRnlKVWlWbVVuMWhiWEI0SmYrdW5BWmhrMlFPRk1qN0V6eXV6d3lxQU90ZUUwNWt4NVk4ck1OWmZyWDFod2k3bU84OFQ0U0huWmF4ZjhrdzFwcmdtUkFDRUNlUUFBQUFILy93QUNlTm85a3IxdjAwQVl4dS9EOXZrajl0bU80elFPYVQ2Y3hDbHRBM0ppdTBsS29oWmExQmJFQUJJdEZJRUFNUlNZRVFNU0VtSmdRTXpBeE1TQWhHaUVrTmpZUU14czhBY2dKRWFRRUlSeWx3RFQzVDNQRGMvdmZWNkFRQmtBdUI4OUFoZ1EwTnlGNE1EaWtBamdhN2dyaVo4V2h4aXhLOWpGWEJhNVBDUVMvTFU0aEZ4dldXVXJhRmwrR1NxZjM3NUZqMFpYeW1nVEFBUldBTUE5OUJTY0J1d0prN2p1bHlzR2ROeFdtSjJHR1lkZ0EvcE15RGl0TUc1bFE2Wkg3YnBmQ1pxb1BZQ3QwR1ZmcExFNVFHMi9JaEVEenNLa0QzdVFXeE1ud1lHTk5HZjBKYVVwaHUzWVZCYnV5TGtGVFZWTWVvVWUxK09VUzUxOFRsZGwzTCthVkFpMkZFbUlCVXVWQkJvdlhSNUlSdkhoaFQ1L0kvanhlVVpCcWlNZ0tNcklHWDByVXFpcVZJRFlWWm1HaUtIOVNIdldQZ1ZUbVg1d3FFSTcxWjlUYXJqa3pFQkxvNHgzYmErTnR0RWJzQXFPTWw2T3dqT1RDZU0weTQwbFJ0ZEhZMHFXbndIMzJWaVNORCtqZHBQaHhZeVBqY2RBWXplTzBIWnZ4bDlPRzVaOVF0Y1VSZFBXTjkyRHViVHRDbG5MOVR1TndvS25ORElMRnlmbXVSSVJDdmErZnphNldhNEhWVy90RWxKVjF0ZnY0R0pLOGl6SnpGVHlwYURtbSt1M1lUU3hYbmlXOTk4REFBaGdsckZNd2RkZ0RzeURKYkFNZ0pnK21FeVEvb1lQRThabUlNS1o0bjlJMDRpWEVuQnV2MUtQMm5FU3QwSmVOb1h3NlhVaG8xc2VyaDQrLzJUejlpRlprb25pMm5OSG1zVlMxblI5cjFVdDdOelFDNkxwTFJkcTlVbzZYaW5PR1hqK01IeVpvVmFXZHA3dGJHekZaYS9vZWI1Wkk5UzNuRW8razFmeHFlaWRuUzdXNGhuL2J1bE1vNm9JMmt1R3dQclkyUHVPcnFGWGJBOVhBYWl4RldMcnhITkY3WVFGRGxoaWtrNjR6TWM5aVVrdzRZTlA0Z0VjVjhQU1Q3YVFkNFVpZE0zVVJXaDFpN2xzVlBPNzIwZVBDU2ErSlJIRnk3cFl1Qy9hWnQ0UTlDelNvZXFzbk8zMWFOTHdleVg3Z2M3d3V3Ti9xbk52b1Z2SW40U2hhYWlRamQ0UVJWR3dSKy9kbE9QSnlSYUpTYU80czlwOVhEZURBN09kZVpsaC9BSGYxNGpVQUFCNDJtTmdaR0JnQU9KZE00VDg0L2x0dmpKd003OEFpakRjM3Rhd0EwNHIvamRodG1ZNkFPUnlNRENCUkFGWm53dzdBQUFBZU5wallHUmdZRHJ3MzRRaGl1a3FBOFAvT2N6V0RFQVJGTUFPQUlGM0JRa0JiQUFoQUFBQUFBRk5BQUFDMVFCRkFpMEFTUUl0QUNzQ25RQkxBQUFBS2dBcUFDb0FvZ0VJQVdvQnpuamFZMkJrWUdCZ1o0aGtZR0VBQVNZZ1ptUUFpVGt3NklFRUFBenBBTmdBZU5wRmpVMktBakVRaFQvSGZ3ZGtWb1BMNEw2YmREYUNhK2tEdUhBNTRDSTJEZjBEVVEvZ01UeUFCL0NHdmpTQlNhaXFyNmpIZThDQ0N5UGkrMkxPVCtJeFcvNFNUL25tbVhpbTdhM3JhTEtVZmowb0k0ODVzRWs4NVpkSDRoa3JYaHp4Vk54cE9CUGc2S3Q3Y3hhVTlIVGNoaG1rOEJnY09WWnpyMnBvOVd0MmFYY1VaQ3FyN3RSalVmYmRyZXhENVkzTHJkbWJwbTNybmFZcnNzSm16anBwVHJJT1hHVVZBNDBzWWdnbkg2NTEzNWtpMS9JZnhtREJCL3JqSnY0QWVOcGpZR0xBRDlpQm1KR0JpVUdUd1pQQmk4RWJBQVRKQVJRQUFBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpsbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVg4QUEwQUFBQUFCK3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdDVTlUTHpJQUFBRk1BQUFBUUFBQUFGWlZiRjlwWTIxaGNBQUFBWXdBQUFCUEFBQUJTZ09BQi9oamRuUWdBQUFCM0FBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIZ0FBQUFDQUFBQUFqLy93QURaMng1WmdBQUFlZ0FBQUtoQUFBRFRQckNZdWxvWldGa0FBQUVqQUFBQURFQUFBQTJHZmxGQUdob1pXRUFBQVRBQUFBQUh3QUFBQ1FHV2dLT2FHMTBlQUFBQk9BQUFBQVlBQUFBR0FxOUFJVnNiMk5oQUFBRStBQUFBQTRBQUFBT0FuUUJobTFoZUhBQUFBVUlBQUFBSHdBQUFDQUFTZ0NhYm1GdFpRQUFCU2dBQUFDOEFBQUJJL3kwZUxSd2IzTjBBQUFGNUFBQUFCZ0FBQUF1QUc0QVBYamFZMkJnWUdRQWdzdmI3czBBMGJlM05leUEwUUJjdXdpVEFBQjQybU5nWkZyRE9JR0JsWUdCcVl0cER3TURRdytFWm56QVlNaklCQlJsWUdWbWdBRkdCaVFRa09hYUFxVGNHQ0taM3Yxblk0aGlXbzFRQXdEakZ3cUJlTnJWaXRzSmdEQVFCT2VTbUNvc3dFSWtOV2lQdG1CdDYvcEFFSC84ZFdCdm1lV0F6Sm1lWUdlMHhlR0Z3VjNkUWFJeFMvYkdKR25WY3YyYnFOd1N5U2Z4SlBoSWZpMmw0eGRzVlpVSmZBQUFJUUo1QUFBQUFmLy9BQUo0MmsyU3oyc1RRUlRINTcyWjNabk56dTVtczd2NTRiWk5rMjJUTmtKcmswMVdUVTBMQlFYMTRvL1dvSGhRYVBVZ0hyMElSYUZYajE1NkVUeUlJQXJ0eFQraGY0QVhGUStDbDNyUW5nUXROamdicmZReTdMenZ6TENmejNzRVNZVVFhT0Ftb1lTVG1TMGdzL1BibkpGdnpTMWQrelMvVFZGOWtpMmFsclcwdk0xMStEMi9EV205NVZiY2VzdU5LbURzN3V6ZzVzRmFCZnVFSUttcDVUdStKQ3ZrbW5vOTZkU2lTdFdHd00rM21tUG9jMnBETk55M2trS3pIZGRtb1JaVjZ6UFFqaGVnMWN3SHZnTitxOWxaZ0U1YkJUcTM0VGdrUGVoQ21uRTlTTU1FMy90bytJTzh6QWpUemJtQm9XMkk4S1JwQ0dmamFVQVJhQ2tzQlNicjNZckxuRXJPV0VJeHd6V2FuVnU4c2NpZDhZMythWXBTTUlUUHJ6MEJSa1pRb0VMbUR2YktXVEFNU2FuSE5BQkFGQm5oL0FxSzNwZ3BkZWVEcVpuQzZrNE9RamwzSmd3dFRScFpraktIaE5BcitJcmNJWGNKbVl5akdhalRIaWFkcElmdFdGRkVWY1VTK0lVaDNpekVQZVhsYUtEQUM1NUM1WW9YaDRpcWt0cUo2alVsQnN2Z3EzQVlKVTBsc28wZmMzTkY2M0Y0ODV4OTZxeWhjOHRaeUhybmM1NmM4cDVmMWN4UnozZjg1VUQyWmE3UUtJa0g3eWludmVYRGN4Y21kRXFud3JYcnE1b2N5WEd1Tyt0eXhmSThDYklNN1pIVmkvSUVCYVhCcE5RM2tJVk84R2JIWXFaRWRKVVozN1M4d2RjdlZLTkwydUVwcGdNTHM2UDNidS9aVEpvSUtFVHFjT2dtVXN1K2NuT0pYRmJ6RUI5aFZ2MDBvUjYzbWozVi9ZZ2ZVYUU4cFozbmZ3ZW44RzlVL3M5SkovR1NWRzk2RWZlUEpiYTdsUFdjaVhEM3Z0NDFCRmM0ZmVrVkdnWHhrRTJ6VEtsckdweFR0djdJTTkzQXpacDJwSXVmZGxEc2pPdU1VM3lXL3FvczJOWEJENWgyaTVBWklwbFdNSGdyTlh4aE43S0tKNk5wb0txQ0ltb0c2ejdKR3pCcUIwRUpnUW1ka0Q4KzhuZXZBQUFBZU5wallHUmdZQURpaGczUnp2SDhObDhadUpsZkFFVVlibTlyMkFHbnBSa1ltSU9aVmdPNUhBeE1JRkVBU3VJTElBQUFBSGphWTJCa1lHQmF6Y0RBRU1Wc3c4RHczNXM1bUFFb2dnTFlBRWR4QXU4QUFXd0FJUUFBQUFBQlRRQUFBb01BSmdNOEFCc0NSUUFqQUFBQUtnQXFBQ29BcEFFeUFhWUFBSGphWTJCa1lHQmdZOGhrWUdJQUFSREp5QUFTYzJEUUF3a0FBQTR3QU9VQWVOcE5qVTBLd2pBUWhUK3R2eWppU2x3R1hMY2tXZllBUFlDTHJuVVJTNkUvRVBVR0hzTURlQUxQNTZRR01jTXczMlFlN3dFTExvd0liOHljYmVTRUE2ZklVMVk4STgrazNuSWRUWmFpM3d6S3dBa0YrOGhUZGp3aXoxano0b2lqNGs3REdROUhWOTJiczBCQlQ4ZHRtRjRVRG9VbFE4dk1wUnRhcVJyeis3SEM2YkNud25wb2lyNjdGYjJ2bkxLWlZybHEyclkyQWF4SmpVNnR0aUlxeGQxekZiZVFxY1FqNUZBNmY2MzdUcGxNbHY4OHZpNThBTnhBSjd4NDJtTmdZc0FQMklDWWtZR0pRWlBCbXNFR0FBS25BS3c9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmxtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpsbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMScgdHJhbnNmb3JtPSdzY2FsZSgyIDIpJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjIuNDU2ODMzJyB5PSctNzkuNTk3OTc3JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuMjU0MyAxOS40MjA0KSc+Rjx0c3BhbiB4PSctMTQuNjY2NTc3Jz5YPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzI2LjMzOTE3MScgeT0nLTc5LjU5Nzk3NycgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjczNTQgMTkuNDIwNCknPkY8dHNwYW4geD0nMzQuMTI5NDI3Jz5ZPC90c3Bhbj4KPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yMi40NTY4MzMnIHk9Jy00Ny41NjUzODknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00MS4zNTkyIDE5LjQyMDQpJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzI2LjMzOTE3MScgeT0nLTQ3LjU2NTM4OScgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQwLjg0MDMgMTkuNDIwNCknPlk8L3RleHQ+CjxwYXRoIGQ9J00tNDYuMzk0NS02Mi42NjhILTIzLjI4MTMnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTI1LjE1NjIzLTY1LjA1ODYzQy0yNC43NzczMi02My42MjUwNDEtMjMuOTMzNTc0LTYyLjk0OTI2LTIzLjA4MjAxMS02Mi42NjgwMUMtMjMuOTMzNTc0LTYyLjM5MDY2Ni0yNC43NzczMi02MS43MTA5NzgtMjUuMTU2MjMtNjAuMjc3MzgnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM1LjE1OTEzOCcgeT0nLTQ3LjU2NTM4OScgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuODc1OCAtMTcuNDQ3MiknPkY8dHNwYW4geD0nLTI5LjAzNDE1Nyc+aDwvdHNwYW4+CjwvdGV4dD4KPHBhdGggZD0nTS01OS4yOTY5LTM4Ljc5Njg4Vi01NS45MzM1OScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tNjEuNjg3NTMtNTQuMDYyNDlDLTYwLjI1MzkzNi01NC40NDE0LTU5LjU3ODE1NS01NS4yODUxNDktNTkuMjk2OTA1LTU2LjEzMjgwNUMtNTkuMDE5NTYxLTU1LjI4NTE0OS01OC4zMzk4NzQtNTQuNDQxNC01Ni45MDYyOC01NC4wNjI0OScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzUuMTU5MTM4JyB5PSctNDcuNTY1Mzg5JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzEuMTQ5NSAxLjc0MzUpJz5mPC90ZXh0Pgo8cGF0aCBkPSdNLTUwLjI5My0zMC42MzY3SC0xOS4zODY3JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTS0yMS4yNjE2OC0zMy4wMjczN0MtMjAuODgyNzctMzEuNTkzNzgtMjAuMDM5MDIyLTMwLjkxNDA5My0xOS4xODc0Ni0zMC42MzY3NDlDLTIwLjAzOTAyMi0zMC4zNTU0OTktMjAuODgyNzctMjkuNjc5NzE4LTIxLjI2MTY4LTI4LjI0NjEyJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNS4xNTkxMzgnIHk9Jy00Ny41NjUzODknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xLjgxMzMgMTQuNTg1OCknPmg8L3RleHQ+CjxwYXRoIGQ9J00tMTAuNS0zOC43OTY4OFYtNTUuOTMzNTknIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTEyLjg5MDU5LTU0LjA2MjQ5Qy0xMS40NTY5OTItNTQuNDQxNC0xMC43ODEyMTEtNTUuMjg1MTQ5LTEwLjQ5OTk2MS01Ni4xMzI4MDVDLTEwLjIyMjYxNy01NS4yODUxNDktOS41NDY4MzYtNTQuNDQxNC04LjEwOTM0LTU0LjA2MjQ5JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNS4xNTkxMzgnIHk9Jy00Ny41NjUzODknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI3LjAwMTcxIC44MjMzKSc+ZzwvdGV4dD4KPC9nPgo8L3N2Zz4=" /></p>
<p>The dual notion to an initial object <span class="math inline">F-</span>algebra is a <em>terminal</em> <span class="math inline">F</span>-coalgebra. Namely, a algebra <span class="math inline">\operatorname{\mathrm{out}}\colon S \to F S</span> such that there is a unique morphism from any other <span class="math inline">F</span>-coalgebra to <span class="math inline">\operatorname{\mathrm{out}}</span>. As you probably already expect, terminal coalgebras are always isomorphisms. The proof is essentially the same as the one for initial <span class="math inline">F</span>-algebras. The only difference being some arrows reversed.</p>
<div class="Theorem">
<p>Any terminal <span class="math inline">F</span>-coalgebra <span class="math inline">\operatorname{\mathrm{out}}\colon C \to F S</span> is an isomorphism.</p>
</div>
<p>The most direct consequence of this theorem is that <span class="math inline">S</span> must be a fixed point of <span class="math inline">F</span>. Since there is an arrow from every other coalgebra to <span class="math inline">S</span>, it is called the <em>greatest fixed point</em> of <span class="math inline">F</span>. For this presentation, there is no need to discriminate between least and greatest fixed points. Specially because there are languages such as Haskell where they are the same. Just keep in mind that when working with coalgebras, there is no guarantee that functions must eventually stop. We are no longer on the land of finite data structures but in the much greater land of possibly infinite data structures.</p>
<p>Given a <span class="math inline">F</span>-coalgebra <span class="math inline">f \colon X \to F X</span>, its anamorphism <span class="math inline">\operatorname{\mathrm{ana}}f</span> is defined as the unique arrow from <span class="math inline">f</span> to the terminal object</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE4MC44ODg1MDZwdCcgaGVpZ2h0PSc5OS43ODc2MjdwdCcgdmlld0JveD0nLTEzOS43MTIwMjcgLTEzOS43MTExIDE4MC44ODg1MDYgOTkuNzg3NjI3Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpsbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVVFBQTBBQUFBQUJxQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCTUFBQUFCb0FBQUFjaXlQZ0MwOVRMeklBQUFGTUFBQUFRZ0FBQUZaV09GOWdZMjFoY0FBQUFaQUFBQUJNQUFBQlNnZWJBK1ZqZG5RZ0FBQUIzQUFBQUFRQUFBQUVBQ0VDZVdkaGMzQUFBQUhnQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQWVnQUFBRzdBQUFDRUY1THZBWm9aV0ZrQUFBRHBBQUFBREVBQUFBMkdlaEVTMmhvWldFQUFBUFlBQUFBSUFBQUFDUUdXQUdyYUcxMGVBQUFBL2dBQUFBVUFBQUFGQWU3QUs5c2IyTmhBQUFFREFBQUFBd0FBQUFNQU13QlhHMWhlSEFBQUFRWUFBQUFId0FBQUNBQVNRQ0tibUZ0WlFBQUJEZ0FBQUMvQUFBQkhiMDRrcFJ3YjNOMEFBQUUrQUFBQUJZQUFBQXNBREVBUzNqYVkyQmdZR1FBZ3N2YjdzMEEwYmUzTmV5RTBRQmN4UWlWQUFCNDJtTmdaR3Brbk1EQXlzREExTVcwaDRHQm9RZENNejVnTUdSa0Fvb3lzREl6d0FBakF4SUlTSE5OQVZKdURHbE03LzZ6TVVReEhXQTRBMU1EQU40d0MwUUFBSGphWTJCZ1lHYUFZQmtHUmdZUWNBSHlHTUY4RmdZTklNMEdwQmtabUJqY0dOTCsvd2Z5d2ZUL3ZmL25RZFVEQVNNYkE1ekR5QVFrbUJoUUFTTURrWUNaZ0R3THcyQUZBR0RuQ1lRQUlRSjVBQUFBQWYvL0FBSjQyajJSVDI3VFFCU0gzN3h4Yk04NDhXU2NpVVBjdjdaTDNJSVVrTzNZcVJJNUtoSlVyWVJZMGtXUlVFSGRjQUoyU0p5Q1hvQWRJamtCdTE2QUhSd0FJYkZrZ1NEQU9CR3NadDd2bThYdmV3TUlJUUM1aFZkQXdZTGhuTUNkNmNJeTRGczZOeHVmcHd1SytncHpXc2VOT2w1WUp2azFYWkE2ejJRb2swekdJV0ZmcnEveGFua1o0aGtBd24wQU9zRzM4QmowU01waUVJZVJTNVNmcGIxdDBsVVdkVW1zZzY3SzBpTHJwVG9mNVlNNFNvYVl6MGlXK3ZxSnVZSXp6T1BJdEZ4eW01UVZtWkFhclVsSkV3OGR0ZnphZEpqcktVL1l4bXU3UDNZNGE0dEw4YkJWTkgyaE52b3RidFBxUlJsWlZETFRLQXpKVFVNVVI4OW5wcnZ6NW1sVnowZyt2ZXN5NU1wQTByQlJMYi92Q01LNU1BajF1YzdRY3AwZm5VQnVNaXBzOFZFSkpnNzNmdDdnNlpFNklOSVIydmZrVDQ3bitBRWV3TEgyclZYcXp0YmFjVnYzcHFhMnEzQmxxZnRyNFVxdnBlelU1eWdmYXIxQysrbjF1TGlpeFFqUEp3Znh2WTRydlVjdGh6SEhPVDN6Ny9ZN25tLzBwQjhmN20rTkE3YmZIVitzNFpOZHk5anlOdjloZkJrT2tyM2c1Qmx5cnYvcmQzTFJOQU5wdHJ2UnhtNXlNMjZmdmlLak5Yb2Z5T0EvQS9nTHYyaE9OQUI0Mm1OZ1pHQmdBR0tMdmUzRzhmdzJYeG00bVY4QVJSaHViMnZZQ2FjVi81c3dXek1kQUhJNUdKaEFvZ0JZV2d3NUFBQUFlTnBqWUdSZ1lEcnczNFFoaXVrcUE4UC9PY3pXREVBUkZNQUtBSUYxQlFjQmJBQWhBQUFBQUFGTkFBQUMxUUJGQWkwQVNRQUFBQ29BS2dBcUFLSUJDSGphWTJCa1lHQmdaWWhrWUdJQUFSREp5QUFTYzJEUUF3a0FBQXlGQU5RQWVOcEZqVTJLQWpFUWhUL0hmd2RrVm9QTDRMNmJkRGFDYStrRHVIQTU0Q0kyRGYwRFVRL2dNVHlBQi9DR3ZqU0JTYWlxcjZqSGU4Q0NDeVBpKzJMT1QrSXhXLzRTVC9ubW1YaW03YTNyYUxLVWZqMG9JNDg1c0VrODVaZEg0aGtyWGh6eFZOeHBPQlBnNkt0N2N4YVU5SFRjaGhtazhCZ2NPVlp6cjJwbzlXdDJhWGNVWkNxcjd0UmpVZmJkcmV4RDVZM0xyZG1icG0zcm5hWXJzc0ptempwcFRySU9YR1VWQTQwc1lnZ25INjUxMzVraTEvSWZ4bURCQi9yakp2NEFlTnBqWUdMQUQxaUJtSkdCaVVHVHdSTUFBWTRBZlFBQSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnJtLWxtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBvQUEwQUFBQUFCVEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdDMDlUTHpJQUFBRk1BQUFBUUFBQUFGWlZlRjlYWTIxaGNBQUFBWXdBQUFCQkFBQUJRZ0FQQTk5amRuUWdBQUFCMEFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFIVUFBQUFDQUFBQUFqLy93QURaMng1WmdBQUFkd0FBQUNyQUFBQXJMbXB0NmRvWldGa0FBQUNpQUFBQURFQUFBQTJHTlpFOEdob1pXRUFBQUs4QUFBQUhnQUFBQ1FGSHdLdWFHMTBlQUFBQXR3QUFBQVFBQUFBRUFmN0FMQnNiMk5oQUFBQzdBQUFBQW9BQUFBS0FJQUFWRzFoZUhBQUFBTDRBQUFBSHdBQUFDQUFTQUJOYm1GdFpRQUFBeGdBQUFDMkFBQUJJSVhnR25Wd2IzTjBBQUFEMEFBQUFCWUFBQUFxQUJzQUEzamFZMkJnWUdRQWdzdmI3czBBMGJlM05leUUwUUJjeFFpVkFBQjQybU5nWkZySk9JR0JsWUdCcVpOcE53TURRemVFWnJ6UFlNaklCQlJsWU9Wa2dBRkdCaVFRa09hYUFxUU1HUXlaaGYvck1FUXh6VUtvQVFEUUN3bDhlTnBqWUdCZ1pvQmdHUVpHQmhDd0FmSVl3WHdXQmdVZ3pRS0VJTDdoLy84UTh2OGxxRW9HUmpZR0dKT0JrUWxJTURHZ0FrWUdUTURNTUt3QUFIV0NCdTRBQUFBQUlRSjVBQUFBQWYvL0FBSjQybU5nWWxCa1lHRFVaSnJGd016QXpxQzNrWkZCMzJZVE93dkRXNk9OYkt4M2JEWXhNd0daREJ1WlFjS3NJT0ZON0d5TWYydzJNWUxFalFVVkJkV05CWlVWR1RtZUh6dkdOT3R2bWlKVEJBTURFME0va05BQ21pbkZJTTNBb0dpcXJLVEhhQ3Bvb3FiTXBzMG9hbXhrTGlqQ3h3aGttU21JTTJrWm1laHhjRW01TndzS0JqcHk2SmtZbVRPcW1ldHc4UWt4cVlseE9PakkvT01SNHVQU1lXRmhZR0FBQU9GQUg2d0FlTnBqWUdSZ1lBQmlOclgydkhoK202OE0zTXpQZ1NJTXQ3YzE3SVRUaWd3TVRGcE1zNEJjRGdZbWtDZ0FLUkFLUHdBQUFIamFZMkJrWUdDYXhjREFFTVcwRWtneU1Ha3hNREtnQWhZQU1Mc0IxQUFBQXFrQUlRQUFBQUFDcVFBQUFxa0Fqd0FBQUNvQUtnQXFBRllBQUhqYVkyQmtZR0JnWVpCaFlHSUFBUkRKeUFBU2MyRFFBd2tBQUFaMUFKWUFlTnBWalUwS3dqQVFSbCsxclZWQmQ2NnpjSnVTQk56MEFNVVRGRHhBbFVKL0lIYnRNVHlBUi9DRVRtc1FERXptemN3Mzh3RVpWeUttdHlCbUUzakprVXZnaEMzUHdDa3IzaktONHJYb3MxazU4Wkl6KzhBSkJ4NkJVM2E4YU9ud25LRHR2UHdsQXozam5EMDNhaFNPSENPNWtQQWkxNytsYjg5aHBXZEZvNFhOSEpSRFA1YUR2OVhLNVVZVnluZDZjaEJ5Vmx1am5YR2lxc1RBYzZlWmJaVWNtYXlvYW45dmhsN1pYSXAvUzhJaFByVExKdGtBQUhqYVkyQmlRQWFNRE9pQUJTekt4Q0FDQUFEYUFCOEFBQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6bG1zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBBQUEwQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdDMDlUTHpJQUFBRk1BQUFBUXdBQUFGWjJUSUNyWTIxaGNBQUFBWkFBQUFBK0FBQUJRZ0FQSmIxamRuUWdBQUFCMEFBQUFBUUFBQUFFQUNFQnBtZGhjM0FBQUFIVUFBQUFDQUFBQUFqLy93QURaMng1WmdBQUFkd0FBQUI4QUFBQWZQS0FKY0ZvWldGa0FBQUNXQUFBQURJQUFBQTJHa2RFSFdob1pXRUFBQUtNQUFBQUhnQUFBQ1FGdlFSQWFHMTBlQUFBQXF3QUFBQVFBQUFBRUF5eEFNRnNiMk5oQUFBQ3ZBQUFBQW9BQUFBS0FHZ0FWRzFoZUhBQUFBTElBQUFBSHdBQUFDQUFTQUE2Ym1GdFpRQUFBdWdBQUFDK0FBQUJIYjlPdUtad2IzTjBBQUFEcUFBQUFCWUFBQUFxQVBZQUEzamFZMkJnWUdRQWdzdmI3czBBMGJlM05leUUwUUJjeFFpVkFBQjQybU5nWkxGbW5NREF5c0RBMU1tMG00R0JvUnRDTTk1bk1HUmtBb295c0hJeUlBTUhHQ01nelRXRmdVRkpTRW1JOGZqZkJ3eFJqTWZCd293Z0FnRE8rd3JsQUhqYVkyQmdZR2FBWUJrR1JnWVFzQUh5R01GOEZnWUZJTTBDaEVDK2t0RC8veER5N2tlb1NnWkdOZ1lZazRHUkNVZ3dNYUFDUm9aaER3QjJpQWJ1QUFBQUlRR21BQUFBQWYvL0FBSUFBZ0FoQUFBQktRSEhBQU1BQndBdXNRRUFMenl5QndRQTdUS3hCZ1hjUExJREFnRHRNZ0N4QXdBdlBMSUZCQUR0TXJJSEJnSDhQTElCQWdEdE1qTVJJUkVuTXhFaklRRUk1OGJHQWNmK09TRUJoUUFBQWdDZ0FONERtd0VXQUFjQUNBQUFKRFFqSVNJVU15RTNBNXNvL1ZVb0tBS3JLTjQ0T0J3QWVOcGpZR1JnWUFEaUM0OWZUbzdudC9uS3dNMzhIQ2pDY0h0YncwNDRyY2pBd0R5YjhUaVF5OEhBQkJJRkFJMVNET3NBQUhqYVkyQmtZR0E4enNEQUVNVmlEU1FabUdjek1ES2dBaFlBTS9zQ0JnQUFCRHNBSVFBQUFBQUVPd0FBQkRzQW9BQUFBQ29BS2dBcUFENEFBSGphWTJCa1lHQmdZZUJrWUdJQUFSREp5QUFTYzJEUUF3a0FBQVNhQUlNQWVOcEZqVHNLd2tBVVJZL0d2eUJXWWpuWUowd0cwcVNXTE1EQ1VyQVlReUFmbUNTRnBjdHdBUzdBSGZvU0JoeTQ3NTNMWE80RFZqeVlNTHdwUy9hZUEwN2NQTS9aOHZhOEVQZVYzOGxzTGZuZG1CdzQ0TXpSODV3REw4OExObnk0WU1ucEtibmo0R0x6dnJ3TFpEVFVkT04ya3JBb0RCRmFkaW9xcVdoNWtuaHZpQWxGV3FhUk9ZaXNxYnVzY2JsVkp0SXFWV1hWUGhQWkpnNWpIUnB0SkhPVmFpZFZ4WGhRU2NWd2hLdDFiZEhVS283RS9JOHhWdkFEQ3hJblRnQUFlTnBqWUdKQUJvd002SUFGTE1yRThCNEFBYlVBK2dBQSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnJtLWxtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVpnQUEwQUFBQUFDQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdDMDlUTHpJQUFBRk1BQUFBUWdBQUFGWldibDljWTIxaGNBQUFBWkFBQUFCakFBQUJXZ2M4RDFoamRuUWdBQUFCOUFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFINEFBQUFDQUFBQUFqLy93QURaMng1WmdBQUFnQUFBQUxTQUFBRFJJRnc2aVZvWldGa0FBQUUxQUFBQURFQUFBQTJHUGRFUzJob1pXRUFBQVVJQUFBQUhnQUFBQ1FGbUFHSmFHMTBlQUFBQlNnQUFBQW1BQUFBS0JGU0FiaHNiMk5oQUFBRlVBQUFBQllBQUFBV0JDd0RSbTFoZUhBQUFBVm9BQUFBSHdBQUFDQUFVQUJ4Ym1GdFpRQUFCWWdBQUFDMkFBQUJJSVhtSG5kd2IzTjBBQUFHUUFBQUFDQUFBQUEyQVFZQXRuamFZMkJnWUdRQWdzdmI3czBBMGJlM05leUUwUUJjeFFpVkFBQjQybU5nWkJKam5NREF5c0RBMU1tMG00R0JvUnRDTTk1bk1HUmtBb295c0RJendBQWpBeElJU0hOTkFWSWFES1hNa3YrTkdLS1kzakg4aEtrQkFMQ2NDbmNBQUhqYVkyQmdZR2FBWUJrR1JnWVFDQUh5R01GOEZnWUxJTTNGd01IQUJJU2FESWtNK1F5bC8vOER4VFNBN0R5R2t2Ly8vOS8rditUL2pQOVRvSHFoZ0pHTkFTN0F5QVFrbUJoUUFaSnFaaFlHOGdBck1vZU5IVVJ5Y0RJTUdnQUFVMzRPbndBQUlRSjVBQUFBQWYvL0FBSjQyajJTVFV3VFFSaUd2NWx1dTlDV3lyYjdVMmhwdXo5MFc2QXQ3T3gyQ3kyRktDSlVna0U0b0tZUS9NSEVpNGtlTUNZYVF6d1lQRUJpd29IZ3pZUkVZd3pFRUltSlJ3Nkd4Sk0zRHg1TVBPSEJBd2NqeFZrS1hyN005MDdtblhlZStRQ0RESURTZUExY3dFSjJFMEd1dE1VeXNHOXNldHpmU2xzdVRKZXc2WEprdHlOdnNSNzB0N1NGSEoxd01xY1RUcFZSdzgvZFhieDJPQy9qYVFBTTk0OVl0SUIvZ1FBaWdOdlVrMXl6bmJkTU5lQVMrQmlXREFzdGVMZDNXSDdvT3BHRW5wdkQvTDdiK3dxWnlOcGczZjd1Sjg4ZWxZc1BuajgxL0k3WEJlcFZvVjRpU0FEdFpoYnJpc0JMSXRmTWVnU2VHR1ZFblZIRmNRazFicjhOTmpWWWwyT2pmK3JuR2Q5RzdVdHQ3MlhRN1UvTjlDNjlCbUFnYzNTQUUrZ1RFRENoREFQVTAxSUZYdWxIWmhicFNWV2hycUpCdytwNVlvaHR5TU1HRUEyTmlKRzNhZTFEWmNiU2VZK3FKQzB6YndzNG9WUmNnbGlhSHIwU1RVVlViVEEzdkhDeFhDaFYwbllsNUVyTG1CV0NFdWY3T0pWSkZlODh2R3JuKzBydkZMa3phSmdacVRYQ2E5NldjakhPUktXUlpNb0s5cWh5bG1FRG9VU0lEQlp6R3BsMDN3QndHT1JwR1VjNzBBVVpBTmxTa2pTdHFyQ3F4UXFHS0hBMGprRFRTdldOZXU1VERZK1Q4T3BkRTcwd1dzSmtwT09TUnNMVlFpNVJYMnYrK1BlbHVUbWZGbXF2SGNiOUdzTlE1ZjNvUkYvM2orUE80YVZUWGh6bDFRaGVhSVdJOHdmSlUwZzZ6MUlTT2tWaE8zZUpBdWFXOTVaWFBxOWNTNlFuSnRNeHJhc3kwUkgvT3J1ME5GdGRYS3cyem1YNityUFZXMTJrMkRuanZLdnQ2SURPeVczcUdqMzVCMnBuY2NSU0xUV0FXSUZ3ZEZ3b2VUb3ZTaXArZm4xZFFjUG5xcEZNVjlnWWVHem5ld3J6Nkl6Mllld2VqdForcHdwUjMxanBoQmZON1BCcWgyU2RsOFU1cEk2cEtGbjh2NHN4eExDSllPTnhvMlhOYUJucmxWT2NlNjBRd2cyaVdrck5kcU5WU2daVkhUNXZ6azRHWWhFSmpmcTA4TkJxdURYVEdtMmFtdkxTNi80QjBmS2tpd0FBZU5wallHUmdZQUJpVDlWM0dmSDhObDhadUptZkEwVVlibTlyMkFtblpmK3pNL2t4dlFOeU9SaVlRS0lBV3lRTVhBQUFBSGphWTJCa1lHQjY5NStkSVlxcG5BRUltUHdZR0JsUUFSY0FWMlFESmdBQWVOcGp6R1pRWkFBQ1JsOGczc2RRRE1UdVRKWU11a3psREdaQVdoM0lsd1d4QVhIQ0JoZ0FBQUFBQUNvQUtnQXFBRkFBZUFEU0FSQUJQZ0ZxQWFJQUFIamFZMkJrWUdEZ1luQmdZR0VBQVNZZ1ptUUFpVGt3NklFRUFBckpBTUlBZU5wVmpVMEt3akFRUmwrMXJWVkJkNjZ6Y0p1U1pDUDBBTVVURkR4QWxVSi9JSGJ0TVR5QVIvQ0VUbXNRREV6bXpjdzM4d0VaVnlLbXR5Qm1FM2pKa1V2Z2hDM1B3Q2tyM2pLTjRyWG9zMWs1OFpJeis4QUpCeDZCVTNhOGFPbnduS0R0dlB3bEF6M2puRDAzYWhTT0hDTzVrUEFpMTcrbGI4OWhwV2RGbzRYTkhKUkRQNWFEdjlYSzVVWVZ5bmQ2Y2hCeVZsdWpuWEdpcXNUQWM2ZVpiWlVjbWF5b2FuOXZobDdaWElwL1M4SWhQcmszSnVVQUFIamFZMkJpd0ErNGdKaVJnWW1CbTRHSHdZVWhrQ0dJSVp3aEFnQUtSZ0c5KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6bG1taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZQUFBMEFBQUFBQjlnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJvQUFBQWNpeVBnQzA5VEx6SUFBQUZNQUFBQVFnQUFBRlpWZ2wrSVkyMWhjQUFBQVpBQUFBQlBBQUFCVWdOd0NYSmpkblFnQUFBQjRBQUFBQVFBQUFBRUFDRUNlV2RoYzNBQUFBSGtBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBZXdBQUFLa0FBQURNSW5iNTBWb1pXRmtBQUFFa0FBQUFERUFBQUEyR2ZwRkFtaG9aV0VBQUFURUFBQUFJQUFBQUNRR2NRTEVhRzEwZUFBQUJPUUFBQUFZQUFBQUdBcmRBSlpzYjJOaEFBQUUvQUFBQUE0QUFBQU9BbVlCWG0xaGVIQUFBQVVNQUFBQUh3QUFBQ0FBU2dDYWJtRnRaUUFBQlN3QUFBQzhBQUFCSS95MGVMUndiM04wQUFBRjZBQUFBQmdBQUFBdUFHMEFPSGphWTJCZ1lHUUFnc3ZiN3MwQTBiZTNOZXlFMFFCY3hRaVZBQUI0Mm1OZ1pOckdPSUdCbFlHQnFZdHBEd01EUXcrRVpuekFZTWpJQkJSbFlHVm1nQUZHQmlRUWtPYWFBcVRjR0NLWTN2MW5ZNGhpT3NnZ0JsTURBT2Y2Q3JZQUFIamFZMkJnWUdhQVlCa0dSZ1lROEFIeUdNRjhGZ1lESU0wQmhFeEEybzBobUNIaS8zOEU2Ly9lL3h2L3I0WHFBZ05HTmdZNGx4R2toNGtCRlRBeUVBbVlrVGtzSUlLVllXZ0FBQ2FaQytjQUFDRUNlUUFBQUFILy93QUNlTnBOa2x0ckUwRVV4K2VjMmQzWnpjNW1zN2UwWWR1azZhWnAya0xTWERiYjJqWXRpcjFZRVVGYmkwV0tZaTlpM3hRZkJhRitBQjhFNldPZkJGRm92b0ZQL1FDK2VIc1FSUENDOWxtdzFkbVVnaS9EelBrZGh2T2IveEFrZVVKZ0dIY0pKWXlVOTRGVUp0dE1JajlyKzRyOGNiSk5VV3pKUG8zTGNseHVNd1grVExZaHJ0ZXR2RFZZdDRJOGFGOFBEbkQzYUNPUEs0UWdLWXJsRno0bnkrU2F1RDFxRm9OOGZ4SThOMTJ2WmRGbE5BbEI1MXlQdW1waG8xaUJZdEEvV0lhd01RMzFXdHB6VFhEcnRlWTBORU1CRkphRUVZaGFNQUV4WTRvWHd3amZ1cWk1eDJtZVVIWEx0anhOM2xIOU1WMVR6WjJuSGtXZ0dUL2o2VkxyWmlQSEtHZVNGRkZNTUptbXFqT3JNOHpzMjFrNVE1R3JFc0tubDQ0S1drS2xRRlZ1SHgzbVVxQnBuRkpIa2dFQVVVMm81bSt2MjhucVhESGY2Ykt1R2hNRHh6NnZUdm0rSVhNdFJXTG54dC92K0JoZmszbXlRTWhBUStoVUlGWnFkb3c2dHJGU0krZzNZMTFoa2M1QmxucXVFdlNYYWF3dUVEdnBtd2J4VXMwUWg2cFdhZlpjOThDZDJiT1hFTG1ZdnFuTHhtaHBjKzNaMU1oZHA3dlAycDVQRDljS0dRVzVJdEZ4QWF2aC9kdTdQK2JLbG1uYmFxWFEybHE4bk15WXd0ejRrRERINTUrc2ppMFlQYktXSHVvOWYwOXhzMUZnRjVndTBTODBwbnRycE9QaUUwS3Y0QXV5U2JaaWw2QU1nN1NGVVROcVlTaW1GQk1MQTgvdDZrUlZnVVpMWlB3L0VNcGRqbkJoSWp2c2lJdEtuSFF3V0JTbW1BUHhJQ2NvcWduVkVOL2IxVzdqa1g5akxqaytxeW5NTUtkVHpnWGI0U1ZuNzZxczl6cXU2UzU1ZklYYlhjTVo5Y0VieW1ocjZiUnZzYUJRV3ZJM3JxL0x2TWRtVERFZjhtWERjVGp3SElROTZ4ZjVLQVVScVU2cHE2SGttOTZyQTBQU09hSWxVbloxd3puKzlwbks5Sng4MmlVcElQbXAzdTFiaDBtSjZ3aW9xdkYvSU9RZlFWbDZOM2phWTJCa1lHQUE0aVI1Lzh4NGZwdXZETnpNTDRBaURMZTNOZXlFMDlML1h6RUhNeDBFY2prWW1FQ2lBRThaREl3QUFBQjQybU5nWkdCZ092ai9GVU1Vc3cwRHcvL3B6TUVNUUJFVXdBWUFpTHNGT2dGc0FDRUFBQUFBQVUwQUFBS0RBQ1lDWlFBMEF6d0FHd0FBQUNvQUtnQXFBS1FCQ2dHWUFBQjQybU5nWkdCZ1lHUElaR0JpQUFFUXljZ0FFbk5nMEFNSkFBQU9NQURsQUhqYVRZMU5Dc0l3RUlVL3JiOG80a3BjQmx5M0pGbjJBRDJBaTY1MUVVdWhQeEQxQmg3REEzZ0N6K2VrQmpIRE1OOWtIdThCQ3k2TUNHL01uRzNraEFPbnlGTldQQ1BQcE41eUhVMldvdDhNeXNBSkJmdklVM1k4SXM5WTgrS0lvK0pPd3hrUFIxZmRtN05BUVUvSGJaaGVGQTZGSlVQTHpLVWJXcWthOC91eHd1bXdwOEo2YUlxK3V4VzlyNXl5bVZhNWF0cTJOZ0dzU1kxT3JiWWlLc1hkY3hXM2tLbkVJK1JRT24rdCswNlpUSmIvUEw0dWZBRGNRQ2U4ZU5wallHTEFEOWlBbUpHQmlVR1R3WXpCR2dBQ2x3Q20pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6bG1zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6bG1taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmxtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpybS1sbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OnJtLWxtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnIHRyYW5zZm9ybT0nc2NhbGUoMiAyKSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLjIyMDc0NScgeT0nLTc3LjQ2NzA1MicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQzLjQyMDk0NSAxOS40MjA0KSc+Rjx0c3BhbiB4PSc4LjAxMTAwMSc+UzwvdHNwYW4+CjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc0OC4zNTk0ODQnIHk9Jy03Ny40NjcwNTInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NC41OTcwNyAxOS40MjA0KSc+Rjx0c3BhbiB4PSc1Ni4xNDk3NCc+WDwvdHNwYW4+CjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScuMjIwNzQ1JyB5PSctNDUuNDM0NDY0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzkuNTI1NzQ1IDE5LjQyMDQpJz5TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ4LjM1OTQ4NCcgeT0nLTQ1LjQzNDQ2NCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQwLjcwMTg5IDE5LjQyMDQpJz5YPC90ZXh0Pgo8cGF0aCBkPSdNLTQyLjI5NjktNTQuMjAzMTJDLTQ3LjY0MDYtNDkuNjgzNTktNDguMzA4Ni00MS42NzU3OC00NC4wNTA4LTM2LjYzNjcyJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHBhdGggZD0nTS00My40MzM2MDktMzkuNjEzMjU2Qy00NC4yODUxNzYtMzguMzk0NTA3LTQ0LjI1NzgzNC0zNy4zMTYzODQtNDMuOTIxODk1LTM2LjQ4NDM1MkMtNDQuNjgzNjE0LTM2Ljk1MzEwNC00NS43NDYxMTEtMzcuMTYwMTMzLTQ3LjA4NTk1NC0zNi41MjM0MjEnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01OC41NTA2IC0yLjQ4NjUpJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTEuMzA1NDE0JyB5PSctNDUuNDM0NDY0Jz5vdXQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLjE3OTE1MycgeT0nLTQ4LjQ0MDk4MSc+4oiSPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzUuNTc1NjYyJyB5PSctNDguNDQwOTgxJz4xPC90ZXh0Pgo8L2c+CjxwYXRoIGQ9J00tLjcyNjYtNjAuNTM5MUgtMjMuODM5OCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J00tMjEuOTY0ODgtNTguMTQ4NDhDLTIyLjM0Mzc5LTU5LjU4MjA3LTIzLjE4NzUzOS02MC4yNTc4NTEtMjQuMDM5MTAyLTYwLjUzOTEwMUMtMjMuMTg3NTM5LTYwLjgxNjQ0NS0yMi4zNDM3OS02MS40OTIyMjYtMjEuOTY0ODgtNjIuOTI5NzMnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi41NDUxIC0xOS4xOTA3KSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTExLjMwNTQxNCcgeT0nLTQ1LjQzNDQ2NCc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS4xODA0MzInIHk9Jy00NS40MzQ0NjQnPihhbmE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTEuNjUyMTUnIHk9Jy00NS40MzQ0NjQnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTYuMzE4NzM0JyB5PSctNDUuNDM0NDY0Jz4pPC90ZXh0Pgo8L2c+CjxwYXRoIGQ9J00tMzUuOTY0OC0zNi42Njc5N1YtNTMuODA0NjknIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NDgnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8cGF0aCBkPSdNLTM4LjM1NTUxLTUxLjkyOTY4Qy0zNi45MTgwMDctNTIuMzA4NTgtMzYuMjQyMjI2LTUzLjE1MjMzNC0zNS45NjQ4ODItNTQuMDAzODk2Qy0zNS42ODM2MzItNTMuMTUyMzM0LTM1LjAwNzg1MS01Mi4zMDg1OC0zMy41NzAzNS01MS45Mjk2OCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTEuMzA1NDE0JyB5PSctNDUuNDM0NDY0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjIuMzEzOCAyLjE1NDkpJz5vdXQ8L3RleHQ+CjxwYXRoIGQ9J00xMi4xNzU4LTM2LjY2Nzk3Vi01My44MDQ2OScgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+CjxwYXRoIGQ9J005Ljc4NTE2LTUxLjkyOTY4QzExLjIxODc1LTUyLjMwODU4IDExLjg5ODQzOC01My4xNTIzMzQgMTIuMTc1NzgxLTU0LjAwMzg5NkMxMi40NTcwMzEtNTMuMTUyMzM0IDEzLjEzMjgxMy01Mi4zMDg1OCAxNC41NjY0MS01MS45Mjk2OCcgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg0OCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnLz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTEuMzA1NDE0JyB5PSctNDUuNDM0NDY0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS44MjU2IDEuNzQzNSknPmY8L3RleHQ+CjxwYXRoIGQ9J00zLjE2OC0yOC41MDM5SC0yNy43MzQ0JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1kYXNoYXJyYXk9JzIuNzg5NDEsMS41OTM5NScvPgo8cGF0aCBkPSdNLTI1Ljg2MzI1LTI2LjExMzMxQy0yNi4yMzgyNS0yNy41NDY5MDMtMjcuMDgyMDAyLTI4LjIyNjU5LTI3LjkzMzU2NS0yOC41MDM5MzRDLTI3LjA4MjAwMi0yOC43ODUxODQtMjYuMjM4MjUtMjkuNDYwOTY1LTI1Ljg2MzI1LTMwLjg5NDU2JyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODQ4JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xMS4zMDU0MTQnIHk9Jy00NS40MzQ0NjQnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC4zNjkyIDI0LjExNjcpJz5hbmE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMi40MTM4NDUnIHk9Jy00NS40MzQ0NjQnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC4zNjkyIDI0LjExNjcpJz5mPC90ZXh0Pgo8L2c+Cjwvc3ZnPg==" /></p>
<p>Thus, the type signature of <span class="math inline">\operatorname{\mathrm{ana}}</span> viewed as a higher-order operator is <span class="math display">\operatorname{\mathrm{ana}}\colon (X \to F X) \to (X \to S).</span> It turns a coalgebra, which we may view as one construction step, into a function that constructs an entire inductive data structure. If we pay attention to the commutative diagram above, we can see that there is a concise recursive formula defining <span class="math inline">\operatorname{\mathrm{ana}}</span>, <span class="math display"> \operatorname{\mathrm{ana}}f = \operatorname{\mathrm{out}}^{-1} \circ F (\operatorname{\mathrm{ana}}f) \circ f.</span> This is the same formula we had for <span class="math inline">\operatorname{\mathrm{cata}}</span>, but the order of composition reversed! This reversion, however, means that we are building structures instead of collapsing them.</p>
<p>Let’s do some examples with lists. Recall that the type <span class="math inline">L(A)</span> of lists with elements of type <span class="math inline">A</span> is a fixed point of the functor <span class="math display">P X = \operatorname{\mathrm{nil}}\mid \operatorname{\mathrm{cons}}\, A \times X.</span> Using the usual notation <span class="math inline">[a,b,c,\ldots]</span> to represent lists, the <span class="math inline">F</span>-coalgebra <span class="math inline">\operatorname{\mathrm{out}}</span> is defined as <span class="math display"> \begin{aligned}
\operatorname{\mathrm{out}}([\;]) &amp;= \operatorname{\mathrm{nil}}\\
\operatorname{\mathrm{out}}([a,b,c,\ldots]) &amp;= \operatorname{\mathrm{cons}}(a, [b,c,\ldots]).
\end{aligned}</span> One of the simplest list anamorphisms is a function that receives a natural number <span class="math inline">n</span> and returns a decreasing list from <span class="math inline">n</span> to <span class="math inline">1</span>. It is defined as <span class="math inline">\operatorname{\mathrm{ana}}g</span>, where <span class="math inline">g</span> is the coalgebra <span class="math display"> g(n) = \begin{cases}
    \operatorname{\mathrm{nil}},&amp; n &lt; 1 \\
    \operatorname{\mathrm{cons}}(n, n-1),&amp; \text{otherwise}.
\end{cases}
</span></p>
<p>In practice, it is most common to use an increasing list, however. The induction on this one is a little trickier but nothing an anamorphism can’t handle. To make it more fun, let’s construct a function <span class="math inline">\operatorname{\mathrm{range}} \colon \mathbb{Z}\times \mathbb{Z}\to L(\mathbb{Z})</span> taking a pair of integers to the closed integer interval between them. We want <span class="math inline">\operatorname{\mathrm{range}}(-2, 1) = [-2,-1,0,1]</span> and <span class="math inline">\operatorname{\mathrm{range}}(7,5) = [\;]</span>, for example. To achieve this, we will need a family of coalgebras <span class="math display"> g_b(n) = \begin{cases}
    \operatorname{\mathrm{nil}},&amp; n &gt; b \\
    \operatorname{\mathrm{cons}}(n, n+1), &amp; \text{otherwise}.
\end{cases}</span> Then, our range function is the anamorphism <span class="math display"> \operatorname{\mathrm{range}}(a,b) = (\operatorname{\mathrm{ana}}g_b)(a).</span></p>
<p>If you ever dealt with plotting libraries, you are probably familiar with a <code>linspace</code> method. It receives two real arguments <span class="math inline">a</span>, <span class="math inline">b</span>, and a natural argument <span class="math inline">n</span> and returns a list of <span class="math inline">n</span> points uniformly distributed between <span class="math inline">a</span> and <span class="math inline">b</span>. The construction of such a function <span class="math display">\operatorname{\mathrm{linspace}} \colon \mathbb{R}\times \mathbb{R}\times \mathbb{N}\to L(\mathbb{R})</span> is a simple variation on the <span class="math inline">\operatorname{\mathrm{range}}</span> we defined earlier. We start with a family of coalgebras <span class="math display"> g(b, n)(x) = \begin{cases}
    \operatorname{\mathrm{nil}},&amp; x &gt; b \\
    \operatorname{\mathrm{cons}}(x, x + \frac{b-a}{n}), &amp; \text{otherwise},
\end{cases}</span> and define it to be the anamorphism <span class="math display">\operatorname{\mathrm{linspace}}(a,b,n) = (\operatorname{\mathrm{ana}}g(b,n))(a).</span></p>
<p>To end this section, let’s turn to a example from number theory. We will construct the <a href="https://en.wikipedia.org/Sieve_of_Eratosthenes">sieve of Eratosthenes</a>.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> This algorithm receives a natural number <span class="math inline">n</span> and returns a list of all primes below <span class="math inline">n</span>. The idea is to start with a list of numbers between <span class="math inline">2</span> and <span class="math inline">n</span>, and to recursively refine it eliminating all multiples of a given prime. Let <span class="math inline">\operatorname{\mathrm{test}}(p)</span> be the predicate that tests if a number is not divisible by <span class="math inline">p</span>. You can implement it by testing if the remainder of the input by <span class="math inline">p</span> equals zero, for example. This refinement process is encapsulated by the function <span class="math inline">\operatorname{\mathrm{sieve}} = \operatorname{\mathrm{ana}}g</span> where <span class="math inline">g</span> is the coalgebra <span class="math display"> \begin{aligned}
\operatorname{\mathrm{g}}([\;]) &amp;= \operatorname{\mathrm{nil}}\\
\operatorname{\mathrm{g}}([p, x,\ldots]) &amp;= \operatorname{\mathrm{cons}}(p, (\operatorname{\mathrm{filter}}(\operatorname{\mathrm{test}}(p))([x,\ldots]))).
\end{aligned}
</span> And our prime-listing function is the composition <span class="math display"> \operatorname{\mathrm{era}}(n) = \operatorname{\mathrm{sieve}}(\operatorname{\mathrm{range}}(2,n)).</span> This process works because after each filtering, the list’s first element cannot be divisible by any number below it. Thus it must be prime. Notice that this function eventually stop because as soon as we reach an empty list, the algorithm returns a <span class="math inline">\operatorname{\mathrm{nil}}</span>.</p>
<p>Finally, to show the power of anamorphisms coupled with lazy evaluation, let’s use <span class="math inline">\operatorname{\mathrm{sieve}}</span> to compute a list of all primes. We begin by writing a list <span class="math inline">l</span> of all natural numbers starting at <span class="math inline">2</span>, <span class="math display">\begin{aligned}
h(x) &amp;= \operatorname{\mathrm{cons}}(x, x+1) \\
l &amp;= (\operatorname{\mathrm{ana}}h)(2).
\end{aligned}</span> This list must be infinite because, since <span class="math inline">h</span> never returns <span class="math inline">\operatorname{\mathrm{nil}}</span>, the anamorphism recurses forever. Unsurprisingly, the list of all primes is defined as <span class="math inline">\operatorname{\mathrm{primes}} = \operatorname{\mathrm{sieve}}(l)</span>. At first, this may not seem very useful since any computer would take infinite time to calculate <span class="math inline">\operatorname{\mathrm{primes}}</span>. But, after some thought, you will notice that the way <span class="math inline">\operatorname{\mathrm{sieve}}</span> calculates its output is rather special. After it produces an element of the list, it never touches that element again! Thus, although it’s impossible to properly calculate <span class="math inline">\operatorname{\mathrm{primes}}</span>, we have that for any natural <span class="math inline">N</span>, the first <span class="math inline">N</span> elements of <span class="math inline">\operatorname{\mathrm{primes}}</span> are calculated in a finite amount of time. So you can think of <span class="math inline">\operatorname{\mathrm{primes}}</span> as an iterator that generates <span class="math inline">\operatorname{\mathrm{era}}(n)</span> in finite time.</p>
<p>This last property is common to all anamorphisms. Although their output can be a possible infinite data structure (even if the input is finite), it is produced in a extremely structured manner. When a value is computed, we go to the next and it is never touched again. Therefore, we can still use an anamorphism to calculate finite data so long as we properly say when we wish to stop. In fact, if we take a look at programs such as games or operational systems, this is exactly the behaviour we want from them. Imagine if any OS terminated after a finite amount of steps… No, what we want is for the OS to run indefinitely producing some well-defined actions in finite time.</p>
<h2 id="sec:hylo">Building up to a collapse</h2>
<p>By now, we’ve seem two kinds of recursion schemes. Anamorphisms start with a seed value and end with a data structure constructed from it, while catamorphisms start with a data structure and collapse it to end with result. Both of these are powerful tools but their type signatures are too constrained. They must explicitly return or receive a data structure. What if we want to write a recursive function from a primitive value to another primitive value? Our next (and last for today) recursion scheme addresses exactly this.</p>
<p>Our strategy will be to use a inductive type as our middle man. The <em>hylomorphism</em> takes a value, applies an anamorphism to turn it into a data structure and then applies a catamorphism to collapse it into another value.<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> This means that we don’t need to go through yet another category to define it. No, given a functor <span class="math inline">F</span>, the type signature for <span class="math inline">\operatorname{\mathrm{hylo}}</span> is <span class="math display"> \operatorname{\mathrm{hylo}}\colon (F B \to B) \times (A \to F A) \to (A \to B)</span> and the definition is simply<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> <span class="math display"> \operatorname{\mathrm{hylo}}f\,g = \operatorname{\mathrm{cata}}f \circ \operatorname{\mathrm{ana}}g.</span></p>
<p>The etymology for hylomorphism is a little harder to motivate but let’s try anyway. The prefix <em>hylo-</em> comes from the Greek <span lang="grc">‘ὕλη’</span> and means <a href="https://outils.biblissima.fr/fr/eulexis-web/?lemma=%E1%BD%95%CE%BB%CE%B7&amp;dict=LSJ">“wood” or “matter”</a>. And as we’ve previously seem, the term morphism comes from the Greek word for form. The name hylomorphism is a pun on a Aristotelian theory of the same name which says that the being is composed from matter and form. Since I never really understood Aristotle’s writings and was unable to find another word starting with <em>hylo-</em> outside the context of philosophy, I will just try to improvise an intuition. Let’s think of algebras and coalgebras as ways to give form or create matter and a <span class="math inline">\operatorname{\mathrm{hylo}}</span> combines them into a single being. It’s kinda lame but was the best I could think of.</p>
<p>Although the first recursive function introduced in this post was the factorial (way back in the <a href="#sec:motivation">motivation</a>) we haven’t rewritten it as a recursion scheme yet. It’s time to fix that. If you open the definition of <span class="math inline">\operatorname{\mathrm{fat}}</span>, you will see that <span class="math inline">\operatorname{\mathrm{fat}}(n)</span> stand for the product of the first <span class="math inline">n</span> natural numbers, <span class="math display"> \operatorname{\mathrm{fat}}(n) = \prod_{k=1}^n k.</span> Thus, an algorithm to compute the factorial is to first construct a decreasing list of integers from <span class="math inline">n</span> to <span class="math inline">1</span> and then collapse it by multiplying all its elements. We’ve already constructed both these functions but let’s rewrite their definitions for the sake of completeness. We start with the coalgebra and algebra, <span class="math display">\begin{aligned}
g(n) &amp;= \begin{cases}
    \operatorname{\mathrm{nil}},&amp; n &lt; 1 \\
    \operatorname{\mathrm{cons}}(n, n-1),&amp; \text{otherwise},
\end{cases} \\
f(\operatorname{\mathrm{nil}}) &amp;= 1, \\
f(\operatorname{\mathrm{cons}}(x,y)) &amp;= x \cdot y,
\end{aligned}</span> and finally define the factorial as <span class="math inline">\operatorname{\mathrm{fat}}= \operatorname{\mathrm{hylo}}f\,g.</span></p>
<p>Time for a more complex example, let’s see how to use hylomorphisms to better shape the call procedure tree and get faster algorithms. Recall how we defined <span class="math inline">\exp</span> as a catamorphism. For what we knew at the time, it was fine but, at its <span class="math inline">O(n)</span> complexity, it’s just too slow. With a hylomorphism, we can do better than that. <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">The trick</a> is noticing that for even values, the exponential satisfies <span class="math inline">e^{2n} = (e^{n/2})^2</span>, which gives us a much better recursive relation. Thus, instead of multiplying <span class="math inline">e</span> <span class="math inline">n</span> times, we can construct a much smaller call tree and collapse it to get the desired result. We define a type <span class="math inline">\mathtt{CallTree}</span> as the fixed point of the functor <span class="math display">T X = \operatorname{\mathrm{leaf}} \mathbb{R}\mid \operatorname{\mathrm{square}} X \mid \operatorname{\mathrm{mult}} \mathbb{R}\times X.</span> This type encapsulates the call tree. As base cases, <span class="math inline">n</span> equal to zero or one means that we store <span class="math inline">e^n</span> on a <span class="math inline">\operatorname{\mathrm{leaf}}</span> node. If <span class="math inline">n</span> is even, we construct a <span class="math inline">\operatorname{\mathrm{square}}</span> node and pass <span class="math inline">n/2</span> to it, meaning that the value of this node will be squared on the algebra. Finally, if <span class="math inline">n</span> is odd, we store <span class="math inline">e</span> and <span class="math inline">n-1</span> on this node, which will be multiplied when folding with the algebra. The coalgebra that construct this structure is <span class="math display">
g(n) = \begin{cases}
    \operatorname{\mathrm{leaf}}(1),&amp; n=0 \\
    \operatorname{\mathrm{leaf}}(e),&amp; n=1 \\
    \operatorname{\mathrm{square}}(\frac{n}{2}),&amp; n \text{ is even} \\
    \operatorname{\mathrm{mult}}(e, n-1),&amp; n \text{ is odd}.
\end{cases}
</span> To collapse the tree, we will use the algebra <span class="math display">\begin{aligned}
f(\operatorname{\mathrm{leaf}}\,x) &amp;= x \\
f(\operatorname{\mathrm{square}}(x)) &amp;= x^2  \\
f(\operatorname{\mathrm{mult}}(x,y)) &amp;= x \cdot y.
\end{aligned}</span> Finally, we define the exponential as the hylomorphism <span class="math inline">\exp = \operatorname{\mathrm{hylo}}f\,g</span>.</p>
<p>When we analyzed the traceback for the exponential as a catamorphism, we noticed that it did a multiplication for each <span class="math inline">\operatorname{\mathrm{succ}}</span> that appeared until we reached <span class="math inline">\operatorname{\mathrm{zero}}</span>. Since a natural number <span class="math inline">n</span> is the <span class="math inline">n</span>-th successor of zero, this amounts to <span class="math inline">n</span> multiplications. Viewing a natural number in such a unary representation has its theoretical advantages but is too slow and cumbersome in practice. With our new definition using a hylomorphism, we let the binary representation of <span class="math inline">n</span> aid us in designing a more efficient call tree. Since the number of multiplications necessary is proportional to <span class="math inline">\log_2 n</span>, we get an algorithm with complexity <span class="math inline">O(\log n)</span>. This is much better! If you’re not impressed, take a look at the call tree generated for <span class="math inline">n=100</span> and see how it requires much less than 100 computations! Better yet, to compute <span class="math inline">e^{200}</span>, this tree would have to be augmented by only one node.</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDIuOS4xIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzczOS44MjA2OHB0JyBoZWlnaHQ9JzgyLjM4MzA0cHQnIHZpZXdCb3g9Jy0xNDQuMDAwMSAtMTQ0LjAwMDA2IDczOS44MjA2OCA4Mi4zODMwNCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6cm0tbG1yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWR3QUEwQUFBQUFDZHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQk1BQUFBQm9BQUFBY2l5UGdEVTlUTHpJQUFBRk1BQUFBUWdBQUFGWldjbDd2WTIxaGNBQUFBWkFBQUFCa0FBQUJXZ2tMRTg5amRuUWdBQUFCOUFBQUFBUUFBQUFFQUNFQ2VXZGhjM0FBQUFINEFBQUFDQUFBQUFqLy93QURaMng1WmdBQUFnQUFBQVBUQUFBRTlDUmR4WmRvWldGa0FBQUYxQUFBQURJQUFBQTJHY3hFVEdob1pXRUFBQVlJQUFBQUhnQUFBQ1FHUHdLTWFHMTBlQUFBQmlnQUFBQXdBQUFBTUJPU0FUQnNiMk5oQUFBR1dBQUFBQm9BQUFBYUI1d0dVRzFoZUhBQUFBWjBBQUFBSHdBQUFDQUFVZ0IyYm1GdFpRQUFCcFFBQUFDM0FBQUJLUjlNTTVGd2IzTjBBQUFIVEFBQUFDUUFBQUE2QWFRQlJuamFZMkJnWUdRQWdzdmI3czBBMGJlM05leUMwUUJjendpWEFBQjQybU5nWkx6UE9JR0JsWUdCcVpOcE53TURRemVFWnJ6UFlNaklCQlJsWUdWbWdBRkdCaVFRa09hYUFxUVNHVXFacGYrYk1FUXhiV000QkZNREFQSUpDdzBBQUhqYVkyQmdZR2FBWUJrR1JnWVFDQUh5R01GOEZnWUxJTTNGd01IQUJJU0pES2tNdVF5bC8vOER4VURzSEliQy8vLy9ML28vLy8vTS85T2dlcUdBa1kwQkxzRElCQ1NZR0ZBQkl3UGxBT1JtRmdpVEZXZ2ZBenNISnhjM3c2QUJBS0RPRHVzQUlRSjVBQUFBQWYvL0FBSjQybldUelc4YlJSakczNW0xZDcxeDdQWGErK0YxL2JWZWV4MnZFenRlNzNnZDRqaHhuRUpDb3BJV2lwMVdSVlZKUzRwQzB4WUJxbFFRRWdrWFZEVlNKUTY1OU1nNVFVSVZGeENIaWorQ1d3OElpZDZveElFMnpHN1RLcFhnTXBwNVY3UHZiNTduZVFHRERvQXFlQThZNEtDMmo2RGVPZUFDOE5qZVo0Ty9kUTRZVExld3ozamxvRmMrNEZqMFQrY0FlZldtcUl2bHBtam9LUFQ3dzRkNDcra1ZIUThCQXBBL2ZJSWVvWi9CaGliTVFCZWdSQXhaTWdybURISnFxR3dhQlZhV2xLYmRJdlJvdEpxMmtrRXNSMnRaUkl1dXY1S3l4TklieEdtNU1ucWtGZVVZRmtYM3pPd3dKY2xhVUpPTnBVcnZkbWU5dlZDc254UVlTMCsxdjF1MlN1VGkxbHE3UFZlSy9Kck9qSXZ1WEVQUlVoSXZTclg1Ym9uTFRKdzE3WGpEMUJzV2FjNzFKa3ZPTUxEdThhWXA3MzNLbTRVY1dGQ2x2STVSNEtLTVVTaWJSUGN3WHlKM01Ta2JYYVpwWjdHTTdrZEdtRkZyVWgxNXc4b2lWUXlkSHc1dWJRK3QxNHVKK2NjNFl4bXhZa1BtUGh1TkZtdGlvRDk1aFJYTzNQejZ2VXM3UnIzTTd6akxlclRTcThzQXZnZHdpSCtBR0lnQU9xR3ZGam5aVm1TUlNpQzdLaHdTYmRkSmFXUnJLeGZKNHcvRHVVVHA2ZC81U0k1aDZFVjZQdy9BVEtBZm9ROEwvdjBhcGtLYnZzNGNYVGh5L0cvRXQrRzU2UDlYWVNhU2NwTG5sZXh5ZTFHTWZYSzVmc2RyZitNNjBkNTJxcmxYZHprVWpJUi9XbXhycFk1NTZlcFZEKzdaWHo0Y2hYMndOT2cwLy9pUEUzaTZGdzY3V0tEY0dxUmdEQ29BUWYvdEJsZkRML1IyNVNNaWlUdUtnNCtKQmFJcEpuOWlwclMyL2NYZ2xLdVI2emQyeDh5Vys5Wmd5dTMvNHNrMGVUNVJMSDUxOGNMTzR2ZCtSL1RtMkhqbDAzY0hIMStvMzZHYXBXbnVOMmx2dnkveURYNUZKMXNseGd0ZDFDZyt5aXZhdFBLTlR2UWJUNDZiZ3pIWlNjNjZQR2I0c0JhUG5VQ2ZhOFYrOWRweEJlS1p2VlBYRU9JU281S3FLTDdYTkdzYk5HdStWeVduYkpackFmOVZLdTJnMnEwWm40WHpqV01sbGVaS2tmMUpLTk5SS2JEVUlRb3lpN3JJZlE2MFlSVlcxV1JaanBIcGowSXN3L0FCSnNSRjJMRFpmbWVscXRpZGphbjJkRS9BUWM3N0VKUVE1a01UdmRPclh4SkxGNExCcUpBU2N4TzNBZ0hFQzVlakk2TWNuMTVhTitLeDBjUlN4VjQ2R1daSGhHMkJsekFPaDZxcjB4NS9ndkt2NEErb2ZwbWp1YVp3Ukd3U2d4aFJ6TWxOVWNwaW4yeEZNelA5dTNjMUpNL1V6bVpxeFhqRHZqM2xrdWxOcE9RZTFGWjdXSG4yWjNVNnlaOXUrUmsrZklKVjZvY0J4ZU16NENlU0J2cmxLY3Q0b1hDeDZxVHVPYWwrSzJ2R0F2ZGVrM0FzMnhrZldMdFVlL1MrNThEQi9KcVFUeWZSU2ppWFhQZzJyN2ZTeXJsellScTdmd0dmYTlvN0FIamFZMkJrWUdBQTRyMk9uMy9HODl0OFplQm1mZzRVWWJpOXJXRVhuQmIrYjhlc3k3UU55T1ZnWUFLSkFnQ00xUTFaQUFCNDJtTmdaR0JnMnZiZmppR0syWkVCQ0poMUdSZ1pVQUVQQUU5T0F0SUFBQUZyQUNFQUFBQUFBVTBBQUFIMEFDQUJ2QUFjQVJZQUlRTkJBQ0FDRUFBaUFZZ0FIQUdLQUNFQmhRQVRBaXdBSUFBQUFDb0FLZ0FxQUlJQXdnRGlBVDRCZkFHNEFoZ0NSQUo2QUFCNDJtTmdaR0JnNEdGd1pXQmhBQUVtSUdaa0FJazVNT2lCQkFBTGZBREpBSGphWFkwN0RzSXdESVkvSGtXOEJzVEFuSVV4VlpLeEIrakFBVHF5bGFwU0gxTGFJM0FNRHNBWk9CMXVDQkxDa3VYUDltLy93Sm9iTTZhWWs3Q1B2T0RNTlhMQ2prZmtsZWhmc3AwdE42TGZCdVhFQ3k0Y0l5ZWN1RWRlY2VCSlE0dkhZcUJwdlpXUzA5TXhodXFwS0ZFNFVsRW9Na2t2Ri9ybjdqTjF3anIwV3RpRUpPKzdNZTk5VlNxWEdwVXAzK3BnSXVpc3RrWTc0MFJXaUlkbm9BN09TcjVNYmhTbEgrcStVemFWNXQrVjd5L2UrdlVvRGdCNDJtTmdZc0FQZUlDWWtZR0p3WVhCZzhHZklZQWhoQ0dVSVl3aG5DRUNBQnFVQXVzPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpybS1sbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJyB0cmFuc2Zvcm09J3NjYWxlKDIgMiknPgo8cGF0aCBkPSdNLTcxLjgwMDgtMzkuMDIzNDRILTM3LjEyNVYtNTEuODk0NTNILTcxLjgwMDhaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuNDYzMjI4JyB5PSctNDQuMjgyNzkyJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuMDE3MiknPnNxdWFyZTwvdGV4dD4KPHBhdGggZD0nTS0yNS4wMzkwNC0zOS4wMjM0NEg5LjYzNjc2Vi01MS44OTQ1M0gtMjUuMDM5MDRaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NC40NjMyMjgnIHk9Jy00NC4yODI3OTInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMyLjc0NjEpJz5zcXVhcmU8L3RleHQ+CjxwYXRoIGQ9J00yMS43MjY1LTQwLjk2MDk0SDQ4LjU3MDNWLTU0LjQ2NDhIMjEuNzI2NVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU0LjQ2MzIyOCcgeT0nLTQ0LjI4Mjc5MicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzkuNTA5MyknPm08dHNwYW4geD0nLTQ2LjQzODExMic+dWx0PC90c3Bhbj4KPC90ZXh0Pgo8cGF0aCBkPSdNNzIuNDYwOTUtMzEuMDA3NzZIODMuNTI3MzZWLTQxLjkzNzQ1SDcyLjQ2MDk1Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuNDYzMjI4JyB5PSctNDQuMjgyNzkyJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMzAuMjQzNCA5Ljk1NDIpJz5lPC90ZXh0Pgo8cGF0aCBkPSdNNjAuNjU2My00OC45ODA0Mkg5NS4zMzJWLTYxLjg0NzYxSDYwLjY1NjNaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NC40NjMyMjgnIHk9Jy00NC4yODI3OTInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExOC40NDAyIC05Ljk1NDEpJz5zcXVhcmU8L3RleHQ+CjxwYXRoIGQ9J00xMDcuNDE3NS00OC45ODA0MkgxNDIuMDkzM1YtNjEuODQ3NjFIMTA3LjQxNzVaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NC40NjMyMjgnIHk9Jy00NC4yODI3OTInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2NS4yMDMyIC05Ljk1NDEpJz5zcXVhcmU8L3RleHQ+CjxwYXRoIGQ9J00xNTQuMTgzOS00OC45ODA0MkgxODguODU5N1YtNjEuODQ3NjFIMTU0LjE4MzlaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NC40NjMyMjgnIHk9Jy00NC4yODI3OTInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIxMS45NjcyIC05Ljk1NDEpJz5zcXVhcmU8L3RleHQ+CjxwYXRoIGQ9J00yMDAuOTQ1NS01MC45MTc5MkgyMjcuNzg5M1YtNjQuNDIxOEgyMDAuOTQ1NVonIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU0LjQ2MzIyOCcgeT0nLTQ0LjI4Mjc5MicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjU4LjczMDIgLTkuOTU0MSknPm08dHNwYW4geD0nLTQ2LjQzODExMic+dWx0PC90c3Bhbj4KPC90ZXh0Pgo8cGF0aCBkPSdNMjUxLjY3OTg0LTQwLjk2MDk0SDI2Mi43NTAxNlYtNTEuODk0NTNIMjUxLjY3OTg0Wicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuNDYzMjI4JyB5PSctNDQuMjgyNzkyJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMDkuNDY0MiknPmU8L3RleHQ+CjxwYXRoIGQ9J00yMzkuODc5MS01OC45MzM1OUgyNzQuNTUwOVYtNzEuODAwNzhIMjM5Ljg3OTFaJyBzdHJva2U9JyMwMDAnIGZpbGw9J25vbmUnIHN0cm9rZS13aWR0aD0nLjM5ODUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcvPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NC40NjMyMjgnIHk9Jy00NC4yODI3OTInIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI5Ny42NjEyIC0xOS45MDgzKSc+c3F1YXJlPC90ZXh0Pgo8cGF0aCBkPSdNMjg2LjY0MDczLTYwLjg3MTA5SDI5Ny43MTEwNFYtNzEuODAwNzhIMjg2LjY0MDczWicgc3Ryb2tlPScjMDAwJyBmaWxsPSdub25lJyBzdHJva2Utd2lkdGg9Jy4zOTg1JyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnLz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuNDYzMjI4JyB5PSctNDQuMjgyNzkyJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzNDQuNDI0MiAtMTkuOTA4MyknPmU8L3RleHQ+CjxnIHN0cm9rZT0nIzAwMCcgZmlsbD0nbm9uZScgc3Ryb2tlLXdpZHRoPScuMzk4NScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJz4KPHBhdGggZD0nTS0zNi45MjU4LTQ1LjQ1NzAzSC0yNS4yMzgzJy8+CjxwYXRoIGQ9J005LjgzNTktNDYuMzgyODFMMjEuNTI3My00Ni45OTYwOScvPgo8cGF0aCBkPSdNNDguNzY5OC00NC4xNDA2MjZMNzIuMjYxOC0zNy45NzY1NicvPgo8cGF0aCBkPSdNNDguNzY5OC01MC4xNjAxNkw2MC40NTY4LTUyLjI2NTYzJy8+CjxwYXRoIGQ9J005NS41MzA4LTU1LjQxNDFIMTA3LjIxODgnLz4KPHBhdGggZD0nTTE0Mi4yOTI4LTU1LjQxNDFIMTUzLjk4NDgnLz4KPHBhdGggZD0nTTE4OS4wNTg4LTU2LjMzNTlMMjAwLjc0NTgtNTYuOTUzMScvPgo8cGF0aCBkPSdNMjI3Ljk4NzgtNTQuMDkzNzVMMjUxLjQ4MDgtNDcuOTI5NjknLz4KPHBhdGggZD0nTTIyNy45ODc4LTYwLjExNzJMMjM5LjY3OTgtNjIuMjE4OCcvPgo8cGF0aCBkPSdNMjc0Ljc0OTgtNjUuODUxNkwyODYuNDQxOC02Ni4xNzU4Jy8+CjwvZz4KPC9nPgo8L3N2Zz4=" /></p>
<p>Hylomorphisms really shine when an algorithm implements an intermediate data structure that is used but not returned. A special class of such are the divide-and-conquer algorithms, whose structure lend them to have elegant implementations as hylomorphisms. There are many examples such as merge sort, quick sort, convex hull and many others that can be written as a anamorphism that divides the input in a structured manner followed by a catamorphism that conquers the output from it. Please try to write any of these as a <span class="math inline">\operatorname{\mathrm{hylo}}</span>! If you pick your favorite algorithm, there is a great chance it can be written in a clear manner as a hylomorphism.</p>
<p>To end this section (and this post), we will do a last derivation showing that hylomorphisms do not need to be defined in the way they were. No, they accept a recursive definition in terms of themselves as any good recursion scheme should.</p>
<div class="Theorem">
<p>Given a <span class="math inline">F</span>-algebra <span class="math inline">f</span> and a <span class="math inline">F</span>-coalgebra <span class="math inline">g</span>, their hylomorphism satisfies <span class="math display"> \operatorname{\mathrm{hylo}}f\,g = f \circ F (\operatorname{\mathrm{hylo}}f\,g) \circ g.</span></p>
</div>
<div class="Proof">
<p>We begin by recalling the formulas for the other recursion schemes, <span class="math display">\begin{aligned}
\operatorname{\mathrm{cata}}f &amp;= f \circ F(\operatorname{\mathrm{cata}}f) \circ \operatorname{\mathrm{in}}^{-1}, \\
\operatorname{\mathrm{ana}}g &amp;= \operatorname{\mathrm{out}}^{-1} \mathbin{\circ} F(\operatorname{\mathrm{ana}}g) \circ g.
\end{aligned}</span> Since we’re assuming that the least and greatest fixed points of <span class="math inline">F</span> are equal, we have that <span class="math inline">\operatorname{\mathrm{in}}</span> and <span class="math inline">\operatorname{\mathrm{out}}</span> must be inverses to each other. Thus, the definition of <span class="math inline">\operatorname{\mathrm{hylo}}</span> becomes <span class="math display">\begin{aligned}
\operatorname{\mathrm{hylo}}f\,g &amp;= \operatorname{\mathrm{cata}}f \circ \operatorname{\mathrm{ana}}g \\
&amp;= f \circ F(\operatorname{\mathrm{cata}}f) \circ \operatorname{\mathrm{in}}^{-1} \circ \operatorname{\mathrm{out}}^{-1} \mathbin{\circ} F(\operatorname{\mathrm{ana}}g) \circ g \\
&amp;= f \circ F(\operatorname{\mathrm{cata}}f) \circ F(\operatorname{\mathrm{ana}}g) \circ g \\
&amp;= f \circ F(\operatorname{\mathrm{cata}}f \circ \operatorname{\mathrm{ana}}g) \circ g \\
&amp;= f \circ F(\operatorname{\mathrm{hylo}}f\,g) \circ g \\
\end{aligned}</span> This concludes the proof.</p>
</div>
<p>Although our definition of a <span class="math inline">\operatorname{\mathrm{hylo}}</span> is good to reason about, this formula has two advantages over it. The first one is practical: because there is less boilerplate happening, we only have half the function calls happening. As you can see in the proof’s second line, our definition requires <span class="math inline">\operatorname{\mathrm{hylo}}</span> to first recurse through <span class="math inline">\operatorname{\mathrm{ana}}</span>, stacking a pile of calls to <span class="math inline">\operatorname{\mathrm{out}}^{-1}</span>, to immediately after recurse through <span class="math inline">\operatorname{\mathrm{cata}}</span>, canceling each <span class="math inline">\operatorname{\mathrm{out}}^{-1}</span> with a <span class="math inline">\operatorname{\mathrm{in}}^{-1}</span>. This does not change the algorithm’s complexity but still hinders its efficiency. In very large programs that run for weeks, even the complexity constant hurts. There is a practical difference between a program that runs in a week and a program that runs in two.</p>
<p>The second reason is more theoretical: This last formula has no reference to fixed points. There is no explicit mention of any data structure whatsoever. All we have to do is give <span class="math inline">\operatorname{\mathrm{hylo}}</span> one rule saying how to construct each step and one rule saying how to destruct each step and the call stack becomes our intermediate data structure! This is much cleaner and spare us from thinking about least and greatest fixed points. For short, when thinking about hylomorphisms, use the definition as an anamorphism followed by a catamorphism but when actually implementing one, use this formula instead.</p>
<h2 id="sec:conclusion">Summary</h2>
<p>This was a long journey but we finally got to the end. Throughout it we met with our three heros: catamorphism, anamorphism, and hylomorphism, and I truly hope that the ideas they encapsulate will appear on your future programs.</p>
<p>Although these three are powerful tools, they’re not the only recursion schemes available. Oh no, there is an entire <a href="https://ipfs.io/ipfs/QmTppu1VDAQWsdiyVSZX6qb8PErdpwzNP2oKfEhcgaBvWR/guide-to-morphisms.pdf">zoo of them</a> and, as you may expect, every single one has an arcane ancient Greek prefix. Each recursion scheme encapsulates a common pattern of recursion and comes in two flavours: construction and destruction of an inductive type. The ones we’ve seem today are the schemes for structural recursion but if instead we wanted primitive recursion, we would use a para- or apomorphism. It is even possible to combine different schemes to end up with monsters such as the infamous <a href="https://wiki.haskell.org/Zygohistomorphic_prepromorphisms">zygohistomorphic prepromorphisms</a>. Moreover, as one can expect of anything related to category theory, all of them are special cases of <a href="https://www.researchgate.net/publication/220673192_Recursion_Schemes_from_Comonads">a certain categorical construction</a>.</p>
<p>Another topic I haven’t given the deserved attention are the fusion laws for a recursion scheme. The recursive formulas we derived for each scheme may be seem as certain algebraic equations that they must obey. Besides these, there are some other laws related to composition of schemes or other contexts. These give us some of the guarantees of structured programming we talked earlier. If a compiler knows that the code only use certain recursion schemes, it can use the fusion laws to substitute your code for something semantically equivalent but much more efficient. You get the type safe, organized code and the machine gets the faster, optimized one. Win-win.</p>
<p>Well, that’s all for today. Good recursion for y’all!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>This sum example is simple to code with a loop or linear recursion. Recursion schemes really shine when manipulating more complex data structures, such as trees with varying arity.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>This is also called <code>Option</code> in some languages and is specially useful to safely model partial functions and computations that may fail.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Choosing the letter <span class="math inline">N</span> was no accident.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Also known as <code>accumulate</code> or <code>foldr</code> in some languages. The ‘r’ means that this function folds a list from the right.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>This is not entirely true. Questions such as non-termination or laziness/strictness may break this structure in some languages, see <a href="https://wiki.haskell.org/Hask">this link</a> for a discussion concerning Haskell. Nevertheless, types are similar enough to a category to be worth it to think of them as forming one.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Take a look on chapter 1 of <a href="http://www.math.jhu.edu/~eriehl/context.pdf">Emily Riehl’s book</a> if you want to learn this (and much more) properly. Trust me, it’s a great book for the mathematically inclined.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>The technical term is <em>least fixed point</em>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>Fortunately, as functional languages have no side-effects, applying a catamorphism doesn’t make everyone start talking in a different language.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>Also called <code>unfold</code> in the context of lists.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>This example is adapted from an anamorphism in the lectures notes <a href="http://brendanfong.com/programmingcats_files/cats4progs-DRAFT.pdf">Programming with Categories</a> by Brendan Fong, Bartosz Milewski and David I. Spivak.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>As it stands, hylomorphisms are the theoretical analogous of me playing any construction game as a kid.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>To write that, we must assume that the least and the greatest fixed point of <span class="math inline">F</span> coincide. Although this assumption may sound strange, it always holds for languages such as Haskell.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<footer id="bottom-bar">
    <hr/>
    <span>&copy; Iago Leal de Freitas, 2020</span><br>
    <span>Made with <a href="https://www.gnu.org/software/make">make</a>
        and <a href="https://pandoc.org">pandoc</a>
    </span><br/>
    <span>Source @ <a href="https://github.com/iagoleal/site">Github</a></span>
</footer>
</body>
</html>
